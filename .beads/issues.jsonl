{"id":"cgm-01k","title":"Unified Model Download Modal","notes":"## Context \u0026 Goal\n\nReplace the two-modal download flow (Download Modal ‚Üí HuggingFaceRepoModal) with a single unified modal with source tabs.\n\n**Why it matters:** Current UX is fragmented - users must navigate between modals, can't search HF Hub, and can't use shorthand repo IDs.\n\n## Target Architecture\n\n```\nModelDownloadModal.vue (unified)\n‚îú‚îÄ‚îÄ HuggingFaceTab.vue (search + browse)\n‚îÇ   ‚îî‚îÄ‚îÄ HfFileBrowser.vue (file selection)\n‚îú‚îÄ‚îÄ CivitaiTab.vue (placeholder)\n‚îî‚îÄ‚îÄ DirectUrlTab.vue (direct URL flow)\n```\n\n## Key Requirements\n1. Tabs: HuggingFace | Civitai | Direct URL\n2. HF search via Enter key (not auto-trigger)\n3. Smart input detection (URL, repo ID, search query)\n4. Tab state persistence when switching\n5. File URL pre-selects file and navigates to parent folder\n\n## Plan Reference\n/home/ubuntu/.claude/plans/ancient-meandering-kite.md","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-28T02:31:42.271264584-05:00","created_by":"ubuntu","updated_at":"2026-01-28T03:48:16.224115631-05:00","closed_at":"2026-01-28T03:48:16.224115631-05:00","close_reason":"All child tasks completed via wave-runner"}
{"id":"cgm-04a","title":"Component: ModelDownloadModal (unified modal shell)","notes":"## Context \u0026 Goal\n\nCreate the main unified modal that contains all download tabs. This is the root component that ModelIndexSection will use.\n\n## Target State\n\n**Create `frontend/src/components/ModelDownloadModal.vue`:**\n\n```vue\n\u003ctemplate\u003e\n  \u003cBaseModal\n    v-if=\"show\"\n    title=\"DOWNLOAD NEW MODEL\"\n    size=\"xl\"\n    fixed-height\n    @close=\"handleClose\"\n  \u003e\n    \u003ctemplate #body\u003e\n      \u003cdiv class=\"download-modal\"\u003e\n        \u003c!-- Tab Buttons --\u003e\n        \u003cdiv class=\"tab-bar\"\u003e\n          \u003cbutton\n            v-for=\"tab in tabs\"\n            :key=\"tab.id\"\n            :class=\"['tab-btn', { active: activeTab === tab.id }]\"\n            @click=\"activeTab = tab.id\"\n          \u003e\n            {{ tab.icon }} {{ tab.label }}\n          \u003c/button\u003e\n        \u003c/div\u003e\n        \n        \u003c!-- Tab Content --\u003e\n        \u003cdiv class=\"tab-content\"\u003e\n          \u003cHuggingFaceTab\n            v-if=\"activeTab === 'huggingface'\"\n            @queue=\"handleQueue\"\n          /\u003e\n          \u003cCivitaiTab v-else-if=\"activeTab === 'civitai'\" /\u003e\n          \u003cDirectUrlTab\n            v-else-if=\"activeTab === 'direct'\"\n            @queue=\"handleDirectQueue\"\n          /\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/template\u003e\n    \n    \u003ctemplate #footer\u003e\n      \u003cBaseButton variant=\"secondary\" @click=\"handleClose\"\u003e\n        Cancel\n      \u003c/BaseButton\u003e\n    \u003c/template\u003e\n  \u003c/BaseModal\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nimport { ref } from 'vue'\nimport BaseModal from '@/components/base/BaseModal.vue'\nimport BaseButton from '@/components/base/BaseButton.vue'\nimport HuggingFaceTab from '@/components/download/HuggingFaceTab.vue'\nimport CivitaiTab from '@/components/download/CivitaiTab.vue'\nimport DirectUrlTab from '@/components/download/DirectUrlTab.vue'\nimport { useModelDownloadQueue } from '@/composables/useModelDownloadQueue'\n\nconst props = defineProps\u003c{\n  show: boolean\n}\u003e()\n\nconst emit = defineEmits\u003c{\n  close: []\n}\u003e()\n\nconst { addToQueue } = useModelDownloadQueue()\n\nconst tabs = [\n  { id: 'huggingface', label: 'HuggingFace', icon: 'ü§ó' },\n  { id: 'civitai', label: 'Civitai', icon: 'üé®' },\n  { id: 'direct', label: 'Direct URL', icon: 'üîó' }\n] as const\n\nconst activeTab = ref\u003c'huggingface' | 'civitai' | 'direct'\u003e('huggingface')\n\nfunction handleQueue(items: Array\u003c{ url: string; destination: string; filename: string }\u003e) {\n  addToQueue(items.map(item =\u003e ({\n    workflow: '__manual__',\n    filename: item.filename,\n    url: item.url,\n    targetPath: item.destination ? `${item.destination}/${item.filename}` : item.filename\n  })))\n  emit('close')\n}\n\nfunction handleDirectQueue(items: Array\u003c{ url: string; targetPath: string; filename: string }\u003e) {\n  addToQueue(items.map(item =\u003e ({\n    workflow: '__manual__',\n    filename: item.filename,\n    url: item.url,\n    targetPath: item.targetPath\n  })))\n  emit('close')\n}\n\nfunction handleClose() {\n  emit('close')\n}\n\u003c/script\u003e\n\n\u003cstyle scoped\u003e\n.download-modal {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n\n.tab-bar {\n  display: flex;\n  gap: var(--cg-space-1);\n  padding-bottom: var(--cg-space-3);\n  border-bottom: 1px solid var(--cg-color-border);\n  margin-bottom: var(--cg-space-3);\n}\n\n.tab-btn {\n  background: var(--cg-color-bg-tertiary);\n  border: 1px solid var(--cg-color-border);\n  color: var(--cg-color-text-secondary);\n  padding: var(--cg-space-2) var(--cg-space-3);\n  font-size: var(--cg-font-size-sm);\n  cursor: pointer;\n  transition: all 0.15s ease;\n}\n\n.tab-btn:hover {\n  background: var(--cg-color-bg-hover);\n  border-color: var(--cg-color-accent);\n  color: var(--cg-color-accent);\n}\n\n.tab-btn.active {\n  background: var(--cg-color-accent);\n  border-color: var(--cg-color-accent);\n  color: var(--cg-color-text-inverse);\n}\n\n.tab-content {\n  flex: 1;\n  min-height: 0;\n  overflow-y: auto;\n}\n\u003c/style\u003e\n```\n\n## Files Inventory\n\n**Files CREATED:**\n- frontend/src/components/ModelDownloadModal.vue\n\n**Files READ (reference only):**\n- frontend/src/components/download/HuggingFaceTab.vue\n- frontend/src/components/download/CivitaiTab.vue\n- frontend/src/components/download/DirectUrlTab.vue\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- None (depends on all tab components)\n\n**Cannot Run In Parallel With:**\n- cgm-efs (HuggingFaceTab) - imports it\n- cgm-ryx (DirectUrlTab) - imports it\n- cgm-e11 (CivitaiTab) - imports it\n\n**Depends On:**\n- cgm-efs (HuggingFaceTab)\n- cgm-ryx (DirectUrlTab)\n- cgm-e11 (CivitaiTab)\n\n## Estimated Scope\n- **Size:** Medium (~150 lines)\n- **Risk:** Low (composition of existing)\n\n## Acceptance Criteria\n- [ ] Modal opens with xl size and fixed-height\n- [ ] Three tabs visible: HuggingFace, Civitai, Direct URL\n- [ ] Tab switching preserves state in each tab\n- [ ] HuggingFace tab active by default\n- [ ] Queue events from tabs add to download queue\n- [ ] Modal closes after queuing\n- [ ] Cancel button closes modal\n\n## Testing Requirements\n- Click each tab ‚Üí content switches\n- Switch tabs ‚Üí state preserved\n- Queue download ‚Üí modal closes","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T02:33:50.426963224-05:00","created_by":"ubuntu","updated_at":"2026-01-28T03:11:16.159988987-05:00","closed_at":"2026-01-28T03:11:16.159988987-05:00","close_reason":"Implemented ModelDownloadModal with tab orchestration for HuggingFace, Civitai, and Direct URL tabs","dependencies":[{"issue_id":"cgm-04a","depends_on_id":"cgm-efs","type":"blocks","created_at":"2026-01-28T02:34:29.721601009-05:00","created_by":"ubuntu"},{"issue_id":"cgm-04a","depends_on_id":"cgm-ryx","type":"blocks","created_at":"2026-01-28T02:34:29.737047343-05:00","created_by":"ubuntu"},{"issue_id":"cgm-04a","depends_on_id":"cgm-e11","type":"blocks","created_at":"2026-01-28T02:34:29.761077877-05:00","created_by":"ubuntu"}]}
{"id":"cgm-0qc","title":"Add HuggingFace repo-info and subdirectories endpoints","notes":"## Context \u0026 Goal\n\nAdd two backend endpoints to support the HuggingFace repo browser modal:\n1. `/v2/workspace/huggingface/repo-info` - Lists files in an HF repo with sizes\n2. `/v2/workspace/models/subdirectories` - Lists available model directories for destination picker\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit-manager/server/api/v2/models.py`):\nNo HuggingFace-related endpoints exist. File has 508 lines.\n\n**Target** - Add imports at top and endpoints after existing ones (around line 500):\n\n### 1. Add imports (top of file, with other imports):\n```python\nimport os\nimport re\n\nfrom huggingface_hub import HfApi\n\nfrom comfygit_core.configs.model_config import ModelConfig\nfrom comfygit_core.services.huggingface_url import parse_huggingface_url\n```\n\n### 2. Add helper function:\n```python\nHF_MODEL_EXTS_EXTRA = [\".gguf\"]\n\ndef _shard_group(path: str) -\u003e str | None:\n    \"\"\"Detect sharded model files like model-00001-of-00003.safetensors\"\"\"\n    m = re.match(r\"^(.*)-(\\d{4,5})-of-(\\d{4,5})(\\.[^.]+)$\", path, flags=re.IGNORECASE)\n    if not m:\n        return None\n    return f\"{m.group(1)}{m.group(4)}\"\n```\n\n### 3. Add endpoints:\n```python\n@routes.get(\"/v2/workspace/huggingface/repo-info\")\n@requires_environment\nasync def workspace_huggingface_repo_info(request: web.Request, env) -\u003e web.Response:\n    \"\"\"Get file listing for a HuggingFace repository.\"\"\"\n    url = (request.query.get(\"url\") or \"\").strip()\n    if not url:\n        return web.json_response({\"error\": \"Missing required query param: url\"}, status=400)\n\n    # Use core parser for consistency with ModelDownloader\n    parsed = parse_huggingface_url(url)\n    if parsed.kind == \"unknown\":\n        return web.json_response({\"error\": \"Not a valid HuggingFace model URL\"}, status=400)\n    if not parsed.repo_id:\n        return web.json_response({\"error\": \"Could not extract repository ID from URL\"}, status=400)\n\n    repo_id = parsed.repo_id\n    revision = parsed.revision or \"main\"\n\n    token = os.environ.get(\"HF_TOKEN\") or os.environ.get(\"HUGGINGFACE_TOKEN\")\n    api = HfApi(token=token if token else None)\n\n    try:\n        info = api.model_info(repo_id=repo_id, revision=revision, files_metadata=True)\n    except Exception as e:\n        error_str = str(e)\n        if \"401\" in error_str or \"403\" in error_str:\n            return web.json_response({\n                \"error\": \"This repository requires authentication. Set HF_TOKEN environment variable.\"\n            }, status=401)\n        if \"404\" in error_str:\n            return web.json_response({\n                \"error\": f\"Repository not found: {repo_id}\"\n            }, status=404)\n        return web.json_response({\"error\": f\"Failed to fetch repo info: {e}\"}, status=400)\n\n    model_cfg = ModelConfig.load()\n    model_exts = set([e.lower() for e in (model_cfg.default_extensions or [])] + HF_MODEL_EXTS_EXTRA)\n\n    files = []\n    for sib in (info.siblings or []):\n        path = getattr(sib, \"rfilename\", None)\n        if not path:\n            continue\n        size = getattr(sib, \"size\", None) or 0\n        lower = path.lower()\n        is_model_file = any(lower.endswith(ext) for ext in model_exts)\n        files.append({\n            \"path\": path,\n            \"size\": size,\n            \"is_model_file\": is_model_file,\n            \"shard_group\": _shard_group(path),\n        })\n\n    return web.json_response({\n        \"repo_id\": repo_id,\n        \"revision\": revision,\n        \"files\": files,\n    })\n\n\n@routes.get(\"/v2/workspace/models/subdirectories\")\n@requires_environment\nasync def workspace_models_subdirectories(request: web.Request, env) -\u003e web.Response:\n    \"\"\"List available model subdirectories for destination picker.\"\"\"\n    model_cfg = ModelConfig.load()\n    standard = list(model_cfg.standard_directories or [])\n\n    models_dir = None\n    try:\n        models_dir = env.workspace.workspace_config_manager.get_models_directory()\n    except Exception:\n        pass\n\n    existing = []\n    if models_dir and models_dir.exists():\n        try:\n            existing = sorted([\n                p.name for p in models_dir.iterdir()\n                if p.is_dir() and not p.name.startswith(\".\")\n            ])\n        except Exception:\n            existing = []\n\n    merged = sorted(set(standard) | set(existing))\n\n    return web.json_response({\n        \"directories\": merged,\n        \"standard\": standard,\n        \"existing\": existing,\n    })\n```\n\n## Files Inventory\n\n**Files MODIFIED:**\n- /data/projects/comfygit-ai/comfygit-manager/server/api/v2/models.py (add ~80 lines)\n\n**Files READ (imports):**\n- comfygit_core.configs.model_config.ModelConfig\n- comfygit_core.services.huggingface_url.parse_huggingface_url\n\n## Dependencies\n\n**Depends on (in comfygit repo):**\n- cg-4tw: Core HuggingFace URL parser module (provides parse_huggingface_url)\n- cg-pvt: huggingface_hub dependency (provides HfApi)\n\n**Note:** comfygit-manager already depends on comfygit-core, so these imports work once the core beads are complete.\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Frontend beads (different codebase)\n\n**Cannot Run In Parallel With:**\n- Must wait for cg-4tw (core parser) and cg-pvt (huggingface_hub dep) to be merged into core\n\n**Blocking Reason:** Frontend service methods need these endpoints to exist\n\n## Estimated Scope\n- **Size:** Medium (~80 lines)\n- **Risk:** Medium (uses external HF API)\n\n## Acceptance Criteria\n- [ ] Both endpoints registered and responding\n- [ ] `/v2/workspace/huggingface/repo-info?url=https://huggingface.co/microsoft/VibeVoice-1.5B` returns file list\n- [ ] `/v2/workspace/models/subdirectories` returns directories array\n- [ ] Gated repos return helpful 401 error message\n- [ ] Uses `@requires_environment` decorator pattern\n- [ ] Uses core's `parse_huggingface_url` (no local URL parser duplication)\n\n## Testing Requirements\n- Manual curl tests against running server\n- Test with both public and gated repos (if HF_TOKEN available)\n- Verify URL parsing is consistent with ModelDownloader behavior","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:50:09.232319043-05:00","created_by":"ubuntu","updated_at":"2026-01-27T21:52:15.15505872-05:00","closed_at":"2026-01-27T21:52:15.15505872-05:00","close_reason":"Implemented both endpoints with 12 passing tests","dependencies":[{"issue_id":"cgm-0qc","depends_on_id":"cgm-4pl","type":"blocks","created_at":"2026-01-27T03:52:06.855473828-05:00","created_by":"ubuntu"}]}
{"id":"cgm-101","title":"Health check timeout fails silently ‚Äî user sees indefinite 80% with no feedback","notes":"# Bug: Health Check Timeout Fails Silently at 80%\n\n## Context \u0026 Goal\n\nAfter the orchestrator starts a new environment during a switch, it enters the \"validating\" state at 80% progress and runs a health check with a configurable timeout (default 90s from config, with 180s as a common override). During this entire window, the user sees a static \"80% ‚Äî Waiting for environment to be healthy...\" with no indication of progress or estimated time remaining.\n\nIf the health check times out (e.g., slow PyTorch import, large model loading), the orchestrator prints a generic log message and either rolls back or marks as failed. The user gets minimal feedback about what went wrong.\n\nThis creates a poor UX where the switch appears frozen at 80% for up to 3 minutes before finally failing.\n\n## Current State vs Target State\n\n**Current health check** (`server/orchestrator.py:1131-1171`):\n\\`\\`\\`python\ndef _wait_for_health(self, proc: subprocess.Popen, timeout: int) -\u003e bool:\n    start = time.time()\n    consecutive_successes = 0\n    port = 8188  # default, extracted from args\n\n    while time.time() - start \u003c timeout:\n        if proc.poll() is not None:\n            print(f\"[Orchestrator] Process died (exit {proc.returncode})\")\n            return False\n\n        if self._check_port_connection(port):\n            consecutive_successes += 1\n            if consecutive_successes \u003e= 3:\n                return True\n        else:\n            consecutive_successes = 0\n\n        time.sleep(2)\n\n    print(f\"[Orchestrator] Health check timeout after {timeout}s\")  # ‚Üê generic message\n    return False\n\\`\\`\\`\n\n**Current status at 80%** (`server/orchestrator.py:779-790`):\n\\`\\`\\`python\nif first_start:\n    write_switch_status(\n        self.metadata_dir,\n        state=\"validating\",\n        progress=80,\n        message=f\"Waiting for {self.current_env_name} to be healthy...\",\n        target_env=self.current_env_name,\n        source_env=source_env\n    )\n\n    health_timeout = self.config[\"orchestrator\"].get(\"health_check_timeout_s\", 90)\n    if self._wait_for_health(proc, timeout=health_timeout):\n        # success ...\n\\`\\`\\`\n\n**Target**: Update switch status during health check to show elapsed time and attempt count. Update the progress value incrementally between 80-95% as the health check progresses.\n\n**Target approach** ‚Äî pass a status callback into `_wait_for_health`:\n\\`\\`\\`python\ndef _wait_for_health(self, proc, timeout, status_callback=None):\n    start = time.time()\n    consecutive_successes = 0\n    attempts = 0\n\n    while time.time() - start \u003c timeout:\n        if proc.poll() is not None:\n            return False\n\n        attempts += 1\n        elapsed = int(time.time() - start)\n\n        if self._check_port_connection(port):\n            consecutive_successes += 1\n            if consecutive_successes \u003e= 3:\n                return True\n        else:\n            consecutive_successes = 0\n\n        # Update status with progress details\n        if status_callback:\n            pct = 80 + int(15 * elapsed / timeout)  # 80% ‚Üí 95%\n            status_callback(\n                progress=min(pct, 95),\n                message=f\"Health check: {elapsed}s/{timeout}s (attempt {attempts})\"\n            )\n\n        time.sleep(2)\n\n    return False\n\\`\\`\\`\n\nAlso improve the failure status to include the reason:\n\\`\\`\\`python\n# On timeout:\nwrite_switch_status(..., state=\"failed\", message=f\"Health check timed out after {timeout}s\")\n\n# On process crash:\nwrite_switch_status(..., state=\"failed\", message=f\"Process crashed with exit code {proc.returncode}\")\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/orchestrator.py (lines 779-790) - pass status callback to health check\n- server/orchestrator.py (lines 1131-1171) - accept callback, update status during loop\n- server/orchestrator.py (lines 813-838) - improve failure/rollback status messages\n\n**Files READ (reference only):**\n- server/orchestrator.py (lines 305-319) - write_switch_status function signature\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-ssk (frontend bug, different files)\n- cgm-74m (lock bug, different functions ‚Äî acquire_switch_lock vs _wait_for_health)\n\n**Cannot Run In Parallel With:**\n- Any bead modifying the health check or switch status writing in run_forever()\n\n## Estimated Scope\n- **Size:** Medium (~80 lines changed)\n- **Risk:** Low - isolated to health check path, no impact on lock/request logic\n\n## Acceptance Criteria\n- [ ] Health check progress updates from 80% to 95% during the timeout window\n- [ ] Status message shows elapsed time and attempt count\n- [ ] Timeout failure includes specific reason (timeout vs crash vs other)\n- [ ] Rollback status message includes why the switch failed\n- [ ] User can distinguish \"still checking\" from \"stuck\" in the UI\n\n## Testing Requirements\n- Existing tests: Check for health check unit tests\n- New tests: Mock slow-starting ComfyUI, verify status updates are written during health check\n- Manual: Switch to env with slow startup, verify UI shows progress updates at 80-95%","status":"open","priority":2,"issue_type":"bug","created_at":"2026-02-02T20:35:39.003104469-05:00","created_by":"ubuntu","updated_at":"2026-02-02T20:35:39.003104469-05:00"}
{"id":"cgm-15d","title":"Update HF auth error messages in core exceptions","notes":"## Context \u0026 Goal\nUpdate the error messages in DownloadErrorContext to mention that users can configure tokens via the Settings page or inline modal, not just environment variables.\n\n**Why it matters:** Current error messages only mention env vars. Users using the UI should know they can configure tokens through the interface.\n\n## Current State\n\n**File:** `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/models/exceptions.py`\n\nCurrent HuggingFace auth error message (around line 352-358):\n```python\nelif self.provider == \"huggingface\":\n    if self.error_category in (\"auth_missing\", \"auth_invalid\"):\n        return (\n            f\"HuggingFace model requires authentication (HTTP {self.http_status}). \"\n            \"Set the HF_TOKEN environment variable with your HuggingFace token. \"\n            \"Get your token from: https://huggingface.co/settings/tokens\"\n        )\n```\n\n## Target State\n\nFor `auth_missing` (no token configured at all):\n```python\nelif self.provider == \"huggingface\":\n    if self.error_category == \"auth_missing\":\n        return (\n            f\"HuggingFace model requires authentication (HTTP {self.http_status}). \"\n            f\"Configure your token in Settings ‚Üí API Credentials, or set the HF_TOKEN environment variable. \"\n            f\"Get your token from: https://huggingface.co/settings/tokens\"\n        )\n```\n\nFor `auth_invalid` (token exists but rejected):\n```python\n    elif self.error_category == \"auth_invalid\":\n        return (\n            f\"HuggingFace authentication failed (HTTP {self.http_status}). \"\n            f\"Your token may be invalid or expired. Update it in Settings ‚Üí API Credentials, \"\n            f\"or check your HF_TOKEN environment variable. \"\n            f\"Get a new token from: https://huggingface.co/settings/tokens\"\n        )\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/models/exceptions.py` - Update HF error messages\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All other beads (different file, no dependencies)\n\n**Cannot Run In Parallel With:**\n- Nothing specifically\n\n**Blocking Reason:**\n- None (standalone improvement)\n\n## Estimated Scope\n- **Size:** Small (\u003c20 lines)\n- **Risk:** Low (string changes only)\n\n## Adapter Recommendation\n**Prefer claude-sonnet over claude-haiku** for this task. While the changes are simple string edits, distinguishing between `auth_missing` vs `auth_invalid` error categories and crafting appropriate user-facing messages requires nuanced understanding. Haiku might merge the conditions or use inconsistent wording.\n\n## Acceptance Criteria\n- [ ] HF `auth_missing` error mentions \"Settings ‚Üí API Credentials\" first, env var as alternative\n- [ ] HF `auth_invalid` error has different wording (mentions \"invalid or expired\", \"Update\")\n- [ ] Both messages still include HF token URL\n- [ ] Messages are grammatically correct and user-friendly\n\n## Testing Requirements\n- Manual: Trigger auth error, verify new message appears\n- Run: `cd /data/projects/comfygit-ai/comfygit/packages/core \u0026\u0026 uv run pytest tests/ -v -k error`","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-29T15:28:25.49628675-05:00","created_by":"ubuntu","updated_at":"2026-01-29T16:02:57.065979921-05:00","closed_at":"2026-01-29T16:02:57.065979921-05:00","close_reason":"Closed"}
{"id":"cgm-1cj","title":"Improve workflow resolution modal UX for download intents","notes":"# Epic: Workflow Resolution Modal UX Improvements\n\n## Problem Statement\n\nWhen a workflow has models with embedded download URLs (via `properties.models` in ComfyUI nodes), the resolution modal UX is confusing:\n\n1. **Analysis step**: Shows \"3 pending download\" correctly ‚úì\n2. **Models step**: Shows empty \"No models need resolution\" - user has no choices to make but must click through\n3. **Review step**: Shows \"0 to download\" even though 3 models WILL download when Apply is clicked\n4. **Too many clicks**: User clicks through 4 screens when they only need 2 (Analysis ‚Üí Review ‚Üí Apply)\n\n## Solution\n\n1. **Fix download count** - Review step should count pending download intents\n2. **Skip Models step** - When only download intents exist (no user choices), skip directly to Review\n3. **Show download details** - Review step should show exactly what will be downloaded (filename, URL, path)\n4. **Update navigation** - Button text and navigation logic should reflect the streamlined flow\n\n## Success Criteria\n\n- Users with download-intent-only workflows see: Analysis ‚Üí Review ‚Üí Apply (3 clicks)\n- Review step accurately shows \"X to download\" matching actual download count\n- Review step shows detailed list of what will be downloaded\n- Existing flows with unresolved/ambiguous models still work correctly\n\n## Child Tasks\n\n- cgm-447: Fix downloadCount computed\n- comfygit-manager-yah: Skip Models step when only intents\n- comfygit-manager-n2o: Add download details section\n- comfygit-manager-xii: Update navigation logic\n- comfygit-manager-29f: Update button text\n- comfygit-manager-8y2: E2E test coverage","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-22T14:30:02.870833171-05:00","created_by":"ubuntu","updated_at":"2026-01-22T15:48:40.44174231-05:00","closed_at":"2026-01-22T15:48:40.44174231-05:00","close_reason":"All 6 child tasks completed. Post-fix applied for property_download_intent match type (see cgm-447 comment)."}
{"id":"cgm-1no","title":"Integration: Wire up ModelDownloadModal in ModelIndexSection","notes":"## Context \u0026 Goal\n\nReplace the inline download modal in ModelIndexSection with the new unified ModelDownloadModal component. Clean up old code.\n\n## Current State\n\nModelIndexSection.vue has:\n- Inline download modal HTML (lines 174-230)\n- HuggingFace detection logic (lines 301-303)\n- HuggingFaceRepoModal import and usage (lines 232-238)\n- Download state variables (lines 293-299)\n\n## Target State\n\n**Modify `frontend/src/components/ModelIndexSection.vue`:**\n\n1. Remove inline download modal template (lines 174-230)\n2. Remove HuggingFace detection computed (lines 301-303)\n3. Remove download-related state (downloadUrl, downloadTargetPath, etc.)\n4. Replace with simple ModelDownloadModal usage\n\n**Before (current):**\n```vue\n\u003c!-- Download New Model Modal (inline) --\u003e\n\u003cTeleport to=\"body\"\u003e\n  \u003cdiv v-if=\"showDownloadModal\" class=\"modal-overlay\" ...\u003e\n    \u003c!-- 50+ lines of inline modal --\u003e\n  \u003c/div\u003e\n\u003c/Teleport\u003e\n\n\u003c!-- HuggingFace Repo Modal --\u003e\n\u003cHuggingFaceRepoModal\n  :show=\"showHfRepoModal\"\n  :url=\"hfRepoUrl\"\n  @close=\"showHfRepoModal = false\"\n  @queue=\"handleQueueHfRepo\"\n/\u003e\n```\n\n**After (target):**\n```vue\n\u003c!-- Unified Model Download Modal --\u003e\n\u003cModelDownloadModal\n  :show=\"showDownloadModal\"\n  @close=\"showDownloadModal = false\"\n/\u003e\n```\n\n**Remove imports:**\n```typescript\n// Remove:\nimport HuggingFaceRepoModal from '@/components/HuggingFaceRepoModal.vue'\nimport { parseHuggingFaceUrl } from '@/utils/huggingface'\n\n// Add:\nimport ModelDownloadModal from '@/components/ModelDownloadModal.vue'\n```\n\n**Remove state:**\n```typescript\n// Remove these:\nconst downloadUrl = ref('')\nconst downloadTargetPath = ref('')\nconst showHfRepoModal = ref(false)\nconst hfRepoUrl = ref('')\nconst hfParsed = computed(...)\nconst isHfRepoUrl = computed(...)\nconst targetPathError = computed(...)\n```\n\n**Remove functions:**\n```typescript\n// Remove:\nfunction handleDownloadModel() { ... }\nfunction openHfRepoModal() { ... }\nfunction handleQueueHfRepo() { ... }\n```\n\n**Keep:**\n- showDownloadModal state variable\n- \"DOWNLOAD +\" button onClick opens modal\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/components/ModelIndexSection.vue\n  - Remove lines 174-238 (inline modal + HF modal)\n  - Remove lines 293-315 (download state + computed)\n  - Remove lines 417-465 (download functions)\n  - Add import for ModelDownloadModal\n  - Simplify to just `\u003cModelDownloadModal :show=\"showDownloadModal\" @close=\"...\" /\u003e`\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- None (final integration step)\n\n**Cannot Run In Parallel With:**\n- cgm-04a (ModelDownloadModal) - imports it\n\n**Depends On:**\n- cgm-04a (ModelDownloadModal must exist first)\n\n## Estimated Scope\n- **Size:** Medium (removing ~150 lines, adding ~10)\n- **Risk:** Medium (touches main component)\n\n## Acceptance Criteria\n- [ ] \"DOWNLOAD +\" button opens ModelDownloadModal\n- [ ] No inline modal code remains\n- [ ] No HuggingFaceRepoModal references\n- [ ] All download state removed from ModelIndexSection\n- [ ] Downloads still work end-to-end\n- [ ] TypeScript compiles without errors\n\n## Testing Requirements\n- Click \"DOWNLOAD +\" ‚Üí unified modal opens\n- Complete a download via each tab\n- Verify download queue receives items","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T02:34:10.993834529-05:00","created_by":"ubuntu","updated_at":"2026-01-28T03:28:01.879550106-05:00","closed_at":"2026-01-28T03:28:01.879550106-05:00","close_reason":"Successfully integrated ModelDownloadModal into ModelIndexSection. Removed ~150 lines of inline modal code and replaced with unified component. All 6 tests passing.","dependencies":[{"issue_id":"cgm-1no","depends_on_id":"cgm-04a","type":"blocks","created_at":"2026-01-28T02:34:29.775209765-05:00","created_by":"ubuntu"}]}
{"id":"cgm-1vv","title":"Update ModelDownloader to use hf_hub_download and validate paths","notes":"## Context \u0026 Goal\n\nUpdate the core ModelDownloader.download() method to:\n1. Reject HuggingFace repo browser URLs (`/tree/main`) with helpful error\n2. Use `hf_hub_download()` for HF file URLs (enables Xet storage optimization)\n3. Validate target paths to prevent \"Is a directory\" crash\n4. Hardlink from HF cache when possible, copy otherwise\n\nThis fixes the original bug where user pasted repo URL and got `[Errno 21] Is a directory`.\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/services/model_downloader.py`):\n- Uses `requests.get()` for all downloads\n- No HF URL validation\n- No target path directory check\n- Crashes with EISDIR if target is a directory\n\n**Target** - Modify download() method:\n\n**1. Add imports at top:**\n```python\nimport os\nfrom uuid import uuid4\n\nfrom huggingface_hub import hf_hub_download\nfrom tqdm.auto import tqdm\n\nfrom .huggingface_url import parse_huggingface_url\n```\n\n**2. Add target path validation (after Step 1 check, around line 278):**\n```python\n# Step 2: Validate target path\ntarget_path = request.target_path\n\n# Guard: target path must be within models dir\ntry:\n    models_root = self.models_dir.resolve()\n    resolved_target = target_path.resolve()\n    if models_root != resolved_target and models_root not in resolved_target.parents:\n        raise ValueError(\"Target path must be within the models directory.\")\nexcept FileNotFoundError:\n    pass  # resolve() can fail if parent does not exist; handled after mkdir\n\n# Guard: user gave a directory -\u003e error\nif target_path.exists() and target_path.is_dir():\n    raise ValueError(\n        f\"Target path '{target_path}' is a directory. \"\n        \"Please include a filename (e.g. checkpoints/model.safetensors).\"\n    )\nif target_path.suffix == \"\":\n    raise ValueError(\n        f\"Target path '{target_path}' does not look like a file path. \"\n        \"Please include a filename (e.g. checkpoints/model.safetensors).\"\n    )\n\ntarget_path.parent.mkdir(parents=True, exist_ok=True)\n```\n\n**3. Replace download logic (after validation, around line 293):**\n```python\n# Step 3-4: Download\nurl_type = self.detect_url_type(request.url)\n\nif url_type == \"huggingface\":\n    parsed = parse_huggingface_url(request.url)\n\n    if parsed.kind == \"repo\":\n        raise ValueError(\n            \"This HuggingFace URL points to a repository page (e.g. /tree/main). \"\n            \"Use the HuggingFace repo browser in the UI to select files, \"\n            \"or provide a direct /resolve/ URL.\"\n        )\n    if parsed.kind != \"file\" or not parsed.repo_id or not parsed.path_in_repo:\n        raise ValueError(\"Invalid HuggingFace file URL.\")\n\n    token = os.environ.get(\"HF_TOKEN\") or os.environ.get(\"HUGGINGFACE_TOKEN\")\n\n    def _make_tqdm_class(cb):\n        class _CbTqdm(tqdm):\n            def __init__(self, *args, **kwargs):\n                kwargs.setdefault(\"disable\", True)\n                super().__init__(*args, **kwargs)\n\n            def update(self, n=1):\n                super().update(n)\n                if cb and self.total:\n                    cb(int(self.n), int(self.total))\n        return _CbTqdm\n\n    # Download to HF cache (xet-enabled when available)\n    cache_path_str = hf_hub_download(\n        repo_id=parsed.repo_id,\n        filename=parsed.path_in_repo,\n        revision=parsed.revision or \"main\",\n        token=token if token else None,\n        tqdm_class=_make_tqdm_class(progress_callback),\n    )\n\n    cache_path = Path(cache_path_str).resolve()\n\n    # Stage in same dir for atomic replace\n    temp_path = target_path.with_name(f\".{target_path.name}.tmp-{uuid4().hex}\")\n    try:\n        # Hardlink if possible (fast, no extra disk usage on same filesystem)\n        try:\n            os.link(str(cache_path), str(temp_path))\n            # Hash from temp_path\n            hasher = blake3()\n            file_size = 0\n            with open(temp_path, \"rb\") as f:\n                for chunk in iter(lambda: f.read(1024 * 1024), b\"\"):\n                    hasher.update(chunk)\n                    file_size += len(chunk)\n        except OSError:\n            # Fall back to copy+hash (different filesystem)\n            hasher = blake3()\n            file_size = 0\n            with open(cache_path, \"rb\") as src, open(temp_path, \"wb\") as dst:\n                for chunk in iter(lambda: src.read(1024 * 1024), b\"\"):\n                    dst.write(chunk)\n                    hasher.update(chunk)\n                    file_size += len(chunk)\n\n        temp_path.replace(target_path)\n        temp_path = None\n    finally:\n        if temp_path and temp_path.exists():\n            try:\n                temp_path.unlink()\n            except Exception:\n                pass\n\n    # Continue with existing registration/indexing using file_size, hasher.hexdigest(), target_path\n    # ... (rest of method unchanged - Step 5 onwards)\n\nelse:\n    # Existing requests.get streaming download for Civitai/custom URLs\n    # ... (unchanged)\n```\n\n## Files Inventory\n\n**Files MODIFIED:**\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/services/model_downloader.py (~100 lines changed)\n\n**Files READ:**\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/services/huggingface_url.py (import)\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Frontend beads (different codebase)\n- Backend endpoint bead (different file)\n\n**Cannot Run In Parallel With:**\n- Must wait for: huggingface_url.py to exist, huggingface_hub dependency to be installed\n\n**Blocking Reason:** None - this is a leaf task\n\n## Estimated Scope\n- **Size:** Large (~100 lines changed)\n- **Risk:** High (core download logic, affects all downloads)\n\n## Acceptance Criteria\n- [ ] HF repo URLs (`/tree/main`) rejected with helpful error message\n- [ ] HF file URLs (`/resolve/main/...`) downloaded via hf_hub_download\n- [ ] Directory target paths rejected with helpful error\n- [ ] Hardlink used when possible (same filesystem as HF cache)\n- [ ] Copy fallback works for different filesystems\n- [ ] Progress callback still works\n- [ ] Existing Civitai/custom URL downloads unchanged\n- [ ] Model indexed correctly after download\n\n## Testing Requirements\n- Unit tests for path validation\n- Integration test with HF file URL\n- Test repo URL rejection\n- Test directory target path rejection\n- Verify existing download tests still pass","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:51:54.886152038-05:00","created_by":"ubuntu","updated_at":"2026-01-27T15:08:29.3013166-05:00","closed_at":"2026-01-27T15:08:29.3013166-05:00","close_reason":"Moved to comfygit repo as cg-tyx. This bead modifies model_downloader.py in comfygit-core, not comfygit-manager.","dependencies":[{"issue_id":"cgm-1vv","depends_on_id":"cgm-4pl","type":"blocks","created_at":"2026-01-27T03:52:09.843556273-05:00","created_by":"ubuntu"},{"issue_id":"cgm-1vv","depends_on_id":"cgm-i4i","type":"blocks","created_at":"2026-01-27T03:52:09.864249564-05:00","created_by":"ubuntu"}]}
{"id":"cgm-225","title":"Surface version-gated and uninstallable node feedback across all manager UI panels","description":"## Epic Goal\n\nSurface version-gated and uninstallable node feedback consistently across manager backend contracts and all frontend surfaces.\n\n## Why This Was Split\n\nThe original single-task bead mixed backend contract changes, shared frontend type changes, and three independent UI surfaces. That made dependencies implicit and increased merge/conflict risk.\n\nThis epic now decomposes into execution-safe tasks with explicit file ownership and dependencies.\n\n## Child Beads\n\n1. `cgm-225.1` Backend contract: workflow/status API serialization and stats semantics.\n2. `cgm-225.2` Frontend contract: TypeScript/composable/service/mock support for new fields.\n3. `cgm-225.3` Resolution modals: `WorkflowResolveModal` and `MissingResourcesPopup` UX.\n4. `cgm-225.4` Nodes panel: blocked classification API + nodes UI section.\n5. `cgm-225.5` Status/workflows list: count/reporting updates.\n\n## Verification Notes (Code Reality Check)\n\n- `server/api/v2/workflows.py:476` currently undercounts `missing_nodes` (`wf.uninstalled_count` only).\n- `server/api/v2/workflows.py:754-757` and `server/api/v2/workflows.py:766-770` ignore version-gated/uninstallable in resolution flags.\n- `server/api/v2/workflows.py:837-841` omits `builtin_versions_repository` in analyze-json parser creation.\n- `server/cgm_core/serializers.py:200-206` lacks version-gated/uninstallable counts in analyzed workflows.\n- `server/api/v2/nodes.py` currently has no blocked-node issue classification.\n- Frontend types/components currently have no formal support for these fields.\n\n## Phase Diagram\n\n- **Phase 1 (parallel):** `cgm-225.1`, `cgm-225.2`\n- **Phase 2 (parallel after Phase 1):** `cgm-225.3`, `cgm-225.4`, `cgm-225.5`\n- **Phase 3:** final integration pass and regression validation across backend/frontend tests\n\n## File Conflict Matrix\n\n- `server/api/v2/workflows.py`: owned by `cgm-225.1` only\n- `server/cgm_core/serializers.py`: owned by `cgm-225.1` only\n- `frontend/src/types/comfygit.ts`: owned by `cgm-225.2` only\n- `frontend/src/components/WorkflowResolveModal.vue`: owned by `cgm-225.3` only\n- `frontend/src/components/MissingResourcesPopup.vue`: owned by `cgm-225.3` only\n- `server/api/v2/nodes.py`: owned by `cgm-225.4` only\n- `frontend/src/components/NodesSection.vue`: owned by `cgm-225.4` only\n- `frontend/src/components/StatusSection.vue`: owned by `cgm-225.5` only\n- `frontend/src/components/WorkflowsSection.vue`: owned by `cgm-225.5` only\n\n## Critical Path\n\n`cgm-225.1` + `cgm-225.2` -\u003e `cgm-225.3` / `cgm-225.4` / `cgm-225.5`\n\n## Optimal Agent Assignment\n\n- Agent A: `cgm-225.1` (backend API + backend tests)\n- Agent B: `cgm-225.2` (frontend contract layer)\n- Agent C: `cgm-225.3` (resolution modal UI)\n- Agent D: `cgm-225.4` (nodes panel + endpoint)\n- Agent E: `cgm-225.5` (status/workflows summaries)\n\n## Epic Acceptance Criteria\n\n- [ ] Backend endpoints and status serialization include version-gated/uninstallable/guidance data.\n- [ ] Frontend contract types/services/composables support the new schema end-to-end.\n- [ ] Resolution modal and missing resources popup clearly surface blocked categories and guidance.\n- [ ] Nodes panel distinguishes blocked issues from generic missing/untracked states.\n- [ ] Status and workflows list correctly count/report version-gated and uninstallable node issues.\n- [ ] Updated backend/frontend tests cover the new behavior.\n","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-02-14T23:17:12.110500451-08:00","created_by":"ubuntu","updated_at":"2026-02-14T23:53:48.424427943-08:00","closed_at":"2026-02-14T23:53:48.424427943-08:00","close_reason":"All child beads implemented and merged in commit 762f883."}
{"id":"cgm-225.1","title":"Backend contract: surface version-gated/uninstallable/guidance in workflow APIs","description":"## Context\n\n`cgm-225` currently bundles backend contract work with multiple UI surfaces. This child task isolates backend API/schema behavior so frontend work can proceed against a stable contract.\n\n## Verified Current State\n\n- `server/api/v2/workflows.py:776-781` serializes only `nodes.resolved/unresolved/ambiguous`.\n- `server/api/v2/workflows.py:792` computes `total_nodes` without version-gated/uninstallable categories.\n- `server/api/v2/workflows.py:754-757` and `server/api/v2/workflows.py:766-770` compute `needs_user_input` / `is_fully_resolved` without version-gated/uninstallable.\n- `server/api/v2/workflows.py:837-841` instantiates `WorkflowDependencyParser(...)` without `builtin_versions_repository`.\n- `server/api/v2/workflows.py:476` sets workflows list `missing_nodes` from `wf.uninstalled_count` only.\n- `server/cgm_core/serializers.py:200-206` does not expose `nodes_version_gated_count` or `nodes_uninstallable_count`.\n\n## Target State\n\nBackend endpoints must expose and account for `ResolutionResult.nodes_version_gated`, `ResolutionResult.nodes_uninstallable`, and `ResolutionResult.node_guidance`.\n\n## File Touchpoints\n\n- WRITE: `server/api/v2/workflows.py`\n- WRITE: `server/cgm_core/serializers.py`\n- WRITE: `testing/integration/panel/test_workflow_endpoints.py`\n- WRITE: `testing/unit/test_serializers.py`\n- READ: `packages/core/src/comfygit_core/models/workflow.py` (contract reference)\n\n## Acceptance Criteria\n\n- [ ] `/v2/comfygit/workflow/{name}/analyze` response includes `nodes.version_gated`, `nodes.uninstallable`, and top-level `node_guidance`.\n- [ ] `/v2/comfygit/workflow/analyze-json` includes the same fields.\n- [ ] `WorkflowDependencyParser` in analyze-json receives `builtin_versions_repository` from `env.workflow_manager`.\n- [ ] `stats.total_nodes` includes version-gated and uninstallable categories.\n- [ ] `stats.needs_user_input` remains choice-driven (true for unresolved/ambiguous choices), and stays false for purely informational/version-gated/uninstallable-only scenarios.\n- [ ] `stats.is_fully_resolved` is false when version-gated or uninstallable nodes exist.\n- [ ] `/v2/comfygit/workflows` includes `version_gated_count` and `uninstallable_count` per workflow.\n- [ ] `serialize_environment_status()` includes `nodes_version_gated_count` and `nodes_uninstallable_count` in analyzed workflows.\n- [ ] Existing endpoint behavior for resolved/unresolved/ambiguous nodes and model stats remains intact.\n\n## Parallelization\n\nCan run in parallel with: frontend type/composable task.\nCannot run in parallel with: any task editing `server/api/v2/workflows.py` or `server/cgm_core/serializers.py`.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-14T23:28:28.255606643-08:00","created_by":"ubuntu","updated_at":"2026-02-14T23:53:47.969036324-08:00","closed_at":"2026-02-14T23:53:47.969036324-08:00","close_reason":"Implemented backend workflow/status contract updates for version-gated and uninstallable nodes with tests.","dependencies":[{"issue_id":"cgm-225.1","depends_on_id":"cgm-225","type":"parent-child","created_at":"2026-02-14T23:28:28.256539299-08:00","created_by":"ubuntu"}]}
{"id":"cgm-225.2","title":"Frontend contract: add types/composables for version-gated and uninstallable nodes","description":"## Context\n\nThis task creates the frontend data-contract layer for new backend fields so UI tasks can proceed without redefining shapes.\n\n## File Touchpoints\n\n- WRITE: `frontend/src/types/comfygit.ts`\n- WRITE: `frontend/src/composables/useWorkflowResolution.ts`\n- WRITE: `frontend/src/composables/useComfyGitService.ts`\n- WRITE: `frontend/src/services/mockApi.ts`\n- WRITE: `frontend/src/composables/__tests__/useWorkflowResolution.test.ts`\n\n## Target State\n\nAdd explicit frontend interfaces for version-gated/uninstallable node structures, guidance map, and workflow/status count fields introduced by backend contract work.\n\n## Acceptance Criteria\n\n- [ ] `FullResolutionResult` includes `nodes.version_gated`, `nodes.uninstallable`, and `node_guidance`.\n- [ ] `WorkflowInfo` supports `version_gated_count` and `uninstallable_count`.\n- [ ] `AnalyzedWorkflow` supports `nodes_version_gated_count` and `nodes_uninstallable_count`.\n- [ ] Any service/composable parsing assumptions match backend response shape (no runtime undefined access for new fields).\n- [ ] Mock API fixtures include representative version-gated/uninstallable examples.\n- [ ] `useWorkflowResolution` tests cover new fields presence and default behavior.\n\n## Parallelization\n\nCan run in parallel with: backend contract task.\nCannot run in parallel with: tasks that also modify `frontend/src/types/comfygit.ts`.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-14T23:28:28.358744794-08:00","created_by":"ubuntu","updated_at":"2026-02-14T23:53:48.065525439-08:00","closed_at":"2026-02-14T23:53:48.065525439-08:00","close_reason":"Implemented frontend types/composable/service/mock contract support for version-gated/uninstallable fields.","dependencies":[{"issue_id":"cgm-225.2","depends_on_id":"cgm-225","type":"parent-child","created_at":"2026-02-14T23:28:28.359754213-08:00","created_by":"ubuntu"}]}
{"id":"cgm-225.3","title":"Resolution modals: render version-gated/uninstallable nodes with guidance","description":"## Context\n\nResolution modals are the most user-critical missing surface. This task is UI-only on top of the stabilized backend/frontend contracts.\n\n## File Touchpoints\n\n- WRITE: `frontend/src/components/WorkflowResolveModal.vue`\n- WRITE: `frontend/src/components/MissingResourcesPopup.vue`\n- WRITE: `frontend/src/components/__tests__/WorkflowResolveModal.test.ts`\n- READ: `frontend/src/types/comfygit.ts`\n\n## Target State\n\nRender version-gated and uninstallable nodes clearly, surface `node_guidance` inline, and ensure counts/messages reflect blocking state.\n\n## Acceptance Criteria\n\n- [ ] Workflow resolve modal shows dedicated sections for version-gated and uninstallable nodes.\n- [ ] Modal displays `node_guidance` text adjacent to affected node types.\n- [ ] Modal summary/status text does not show \"all dependencies resolved\" when version-gated/uninstallable nodes exist.\n- [ ] Missing resources popup includes a dedicated \"requires newer ComfyUI\" (or equivalent) section for version-gated nodes.\n- [ ] UI copy for uninstallable nodes distinguishes them from generic not-found nodes.\n- [ ] Workflow resolve modal tests are updated for new sections and blocking-state messaging.\n\n## Dependencies\n\nDepends on backend contract task and frontend contract task.\n\n## Parallelization\n\nCan run in parallel with: status/workflows task and nodes panel task.\nCannot run in parallel with: any task editing `frontend/src/components/WorkflowResolveModal.vue` or `frontend/src/components/MissingResourcesPopup.vue`.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-14T23:28:28.454063605-08:00","created_by":"ubuntu","updated_at":"2026-02-14T23:53:48.152646011-08:00","closed_at":"2026-02-14T23:53:48.152646011-08:00","close_reason":"Implemented resolution modal and missing resources UI for blocked node categories and guidance.","dependencies":[{"issue_id":"cgm-225.3","depends_on_id":"cgm-225","type":"parent-child","created_at":"2026-02-14T23:28:28.455104835-08:00","created_by":"ubuntu"},{"issue_id":"cgm-225.3","depends_on_id":"cgm-225.1","type":"blocks","created_at":"2026-02-14T23:28:45.599010981-08:00","created_by":"ubuntu"},{"issue_id":"cgm-225.3","depends_on_id":"cgm-225.2","type":"blocks","created_at":"2026-02-14T23:28:45.692025866-08:00","created_by":"ubuntu"}]}
{"id":"cgm-225.4","title":"Nodes panel: add blocked-node classification and UI section","description":"## Context\n\nCurrent nodes endpoint/panel groups only installed/missing/untracked. It does not identify blocked node types from workflow resolution (version-gated / uninstallable).\n\n## File Touchpoints\n\n- WRITE: `server/api/v2/nodes.py`\n- WRITE: `frontend/src/components/NodesSection.vue`\n- WRITE: `testing/integration/panel/test_node_endpoints.py`\n- READ: `frontend/src/types/comfygit.ts`\n\n## Target State\n\nExpose `issue_type` metadata for blocked nodes and render a blocked grouping in nodes UI.\n\n## Acceptance Criteria\n\n- [ ] Nodes API includes `issue_type` for entries impacted by version-gated/uninstallable resolution states.\n- [ ] `issue_type` values are explicit and stable (e.g., `version_gated`, `uninstallable`).\n- [ ] Nodes panel shows a distinct BLOCKED section/state for those entries.\n- [ ] Blocked entries include enough context for user action (install unavailable vs ComfyUI version requirement).\n- [ ] Existing installed/missing/untracked behavior remains unchanged for unaffected nodes.\n- [ ] Node endpoint integration tests cover blocked classification.\n\n## Dependencies\n\nDepends on backend contract task and frontend contract task.\n\n## Parallelization\n\nCan run in parallel with: modal UI task and status/workflows task.\nCannot run in parallel with: tasks modifying `server/api/v2/nodes.py` or `frontend/src/components/NodesSection.vue`.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-14T23:28:28.552992199-08:00","created_by":"ubuntu","updated_at":"2026-02-14T23:53:48.243453403-08:00","closed_at":"2026-02-14T23:53:48.243453403-08:00","close_reason":"Implemented nodes endpoint/UI blocked classification and guidance surfacing.","dependencies":[{"issue_id":"cgm-225.4","depends_on_id":"cgm-225","type":"parent-child","created_at":"2026-02-14T23:28:28.55396175-08:00","created_by":"ubuntu"},{"issue_id":"cgm-225.4","depends_on_id":"cgm-225.1","type":"blocks","created_at":"2026-02-14T23:28:45.784102125-08:00","created_by":"ubuntu"},{"issue_id":"cgm-225.4","depends_on_id":"cgm-225.2","type":"blocks","created_at":"2026-02-14T23:28:45.874407577-08:00","created_by":"ubuntu"}]}
{"id":"cgm-225.5","title":"Status and workflows list: reflect version-gated/uninstallable counts","description":"## Context\n\nStatus panel and workflows list currently undercount node issues because they only use missing/uninstalled counts.\n\n## File Touchpoints\n\n- WRITE: `frontend/src/components/StatusSection.vue`\n- WRITE: `frontend/src/components/WorkflowsSection.vue`\n- WRITE: `frontend/src/components/__tests__/StatusSection.test.ts`\n- READ: `frontend/src/types/comfygit.ts`\n\n## Target State\n\nStatus and workflow list messaging should reflect version-gated and uninstallable counts from backend responses.\n\n## Acceptance Criteria\n\n- [ ] Status section summaries include version-gated/uninstallable node issue counts when present.\n- [ ] Workflows list issue subtitle/summary includes version-gated/uninstallable counts.\n- [ ] Workflows with only version-gated/uninstallable node issues do not appear as healthy/no-node-issues.\n- [ ] Existing summaries for missing models/download intents/category mismatches remain intact.\n- [ ] Status section tests cover new count rendering paths.\n\n## Dependencies\n\nDepends on backend contract task and frontend contract task.\n\n## Parallelization\n\nCan run in parallel with: modal UI task and nodes panel task.\nCannot run in parallel with: tasks modifying `frontend/src/components/StatusSection.vue` or `frontend/src/components/WorkflowsSection.vue`.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-14T23:28:28.648492562-08:00","created_by":"ubuntu","updated_at":"2026-02-14T23:53:48.330802722-08:00","closed_at":"2026-02-14T23:53:48.330802722-08:00","close_reason":"Implemented status/workflows count reporting updates for blocked node categories.","dependencies":[{"issue_id":"cgm-225.5","depends_on_id":"cgm-225","type":"parent-child","created_at":"2026-02-14T23:28:28.649418159-08:00","created_by":"ubuntu"},{"issue_id":"cgm-225.5","depends_on_id":"cgm-225.1","type":"blocks","created_at":"2026-02-14T23:28:45.971201777-08:00","created_by":"ubuntu"},{"issue_id":"cgm-225.5","depends_on_id":"cgm-225.2","type":"blocks","created_at":"2026-02-14T23:28:46.068409005-08:00","created_by":"ubuntu"}]}
{"id":"cgm-29f","title":"Update Analysis step banner to say 'Continue to Review' when no user input needed","notes":"# Context \u0026 Goal\n\n## Problem\nThe Analysis step shows a banner \"3 models pending download - click Continue to review\" but if we're skipping the Models step, the button should say \"Continue to Review\" not just \"Continue\". This provides clearer UX about where the user is going.\n\n## Why It Matters\nSmall polish that helps users understand the streamlined flow. When models step is skipped, users should know they're going directly to review.\n\n## How It Serves Project Goals\nClear, predictable UX with appropriate labeling.\n\n---\n\n# Current State vs Target State\n\n## Current Code\n\n**File:** `frontend/src/components/WorkflowResolveModal.vue`\n\nThe Continue button in footer and any banner text should reflect the actual next step.\n\n## Target Code\n\nUpdate button label to be dynamic:\n\n```vue\n\u003cBaseButton variant=\"primary\" @click=\"handleContinueFromAnalysis\"\u003e\n  {{ nextStepFromAnalysis === 'review' ? 'Continue to Review ‚Üí' : 'Continue' }}\n\u003c/BaseButton\u003e\n```\n\nAdd computed:\n\n```typescript\nconst nextStepFromAnalysis = computed(() =\u003e {\n  if (needsNodeResolution.value || hasNodesToInstall.value) {\n    return 'nodes'\n  } else if (needsModelResolution.value) {\n    return 'models'\n  }\n  return 'review'\n})\n```\n\n---\n\n# Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/WorkflowResolveModal.vue`\n  - Template: Update Continue button text in footer\n  - Script: Add nextStepFromAnalysis computed\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n---\n\n# Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-447 (different computed)\n- comfygit-manager-n2o (different section)\n\n**Cannot Run In Parallel With:**\n- comfygit-manager-yah, comfygit-manager-xii - should be done after those\n\n**Blocking Reason:**\n- Depends on skip-models decision being finalized\n\n---\n\n# Estimated Scope\n\n- **Size:** Small (\u003c30 lines)\n- **Risk:** Low (UI text only)\n\n---\n\n# Acceptance Criteria\n\n- [ ] When going to Review directly, button says \"Continue to Review ‚Üí\"\n- [ ] When going to Nodes or Models, button says \"Continue\"\n- [ ] Banner text matches button behavior\n\n---\n\n# Testing Requirements\n\n**Manual Verification:**\n1. Open workflow with only download intents\n2. Verify button says \"Continue to Review ‚Üí\"\n3. Open workflow with unresolved models\n4. Verify button says \"Continue\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-22T14:29:23.557392012-05:00","created_by":"ubuntu","updated_at":"2026-01-22T15:11:05.277396165-05:00","closed_at":"2026-01-22T15:11:05.277396165-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-29f","depends_on_id":"cgm-xii","type":"blocks","created_at":"2026-01-22T14:29:27.833642938-05:00","created_by":"ubuntu"},{"issue_id":"cgm-29f","depends_on_id":"cgm-1cj","type":"parent-child","created_at":"2026-01-22T14:30:08.824596243-05:00","created_by":"ubuntu"}]}
{"id":"cgm-2er","title":"Add git-based created_at date to environment detail modal","notes":"## Context \u0026 Goal\n\nThe Environment Details modal has placeholders for \\\"Created\\\" and \\\"Last Used\\\" dates (lines 111-122 of EnvironmentDetailsModal.vue), but the backend always returns `created_at: None`. The frontend conditionally renders these rows (`v-if=\\\"environment.created_at\\\"`), so they never appear.\n\n**Goal:** Populate `created_at` using the first git commit timestamp from the environment's `.cec/.git` directory. This is a reliable proxy ‚Äî `EnvironmentFactory.create()` always initializes a git repo with an initial commit, so the first commit date IS the creation date.\n\n**Why it matters:** Users want to know when environments were created. The data already exists in git history ‚Äî we just need to query it.\n\n## Current State vs Target State\n\n### Backend: `server/api/v2/environments.py`\n\n**Current (line 197):**\n```python\n\"created_at\": None,\n```\n\n**Target:** Add a helper function to get first commit date, then use it:\n```python\nimport subprocess\n\ndef _get_environment_created_at(env) -\u003e str | None:\n    \"\"\"Get environment creation date from first git commit.\"\"\"\n    git_dir = env.path / \".cec\" / \".git\"\n    if not git_dir.exists():\n        return None\n    try:\n        result = subprocess.run(\n            [\"git\", \"log\", \"--reverse\", \"--format=%aI\", \"-1\"],\n            cwd=str(env.path / \".cec\"),\n            capture_output=True,\n            text=True,\n            timeout=5,\n        )\n        if result.returncode == 0 and result.stdout.strip():\n            return result.stdout.strip()\n    except Exception:\n        pass\n    return None\n```\n\nThen in `get_environment_details()` (around line 187-197):\n```python\ncreated_at = await run_sync(_get_environment_created_at, env)\n# ...\n\"created_at\": created_at,\n```\n\nAlso update `_get_environment_info()` (line 115) ‚Äî keep returning None for list endpoint (avoid N subprocess calls).\n\n### Frontend: `frontend/src/components/EnvironmentDetailsModal.vue`\n\n**Current (lines 111-122):**\n```html\n\u003cdiv class=\"section-divider\" v-if=\"environment.created_at || environment.last_used\"\u003e\u003c/div\u003e\n\u003cdiv class=\"detail-row\" v-if=\"environment.created_at\"\u003e\n  \u003cspan class=\"label\"\u003eCreated:\u003c/span\u003e\n  \u003cspan class=\"value\"\u003e{{ formatDate(environment.created_at) }}\u003c/span\u003e\n\u003c/div\u003e\n\u003cdiv class=\"detail-row\" v-if=\"environment.last_used\"\u003e\n  ...\n\u003c/div\u003e\n```\n\n**Problem:** Uses `environment.created_at` (list endpoint, always None). Need to prefer detail endpoint value.\n\n**Target:**\n```html\n\u003cdiv class=\"section-divider\" v-if=\"detail?.created_at || environment.created_at\"\u003e\u003c/div\u003e\n\u003cdiv class=\"detail-row\" v-if=\"detail?.created_at || environment.created_at\"\u003e\n  \u003cspan class=\"label\"\u003eCreated:\u003c/span\u003e\n  \u003cspan class=\"value\"\u003e{{ formatDate(detail?.created_at ?? environment.created_at) }}\u003c/span\u003e\n\u003c/div\u003e\n```\n\nRemove the `last_used` row entirely ‚Äî no data source exists for it and adding one is out of scope.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `server/api/v2/environments.py` (add helper ~15 lines, update line 197) - Add git-based created_at to detail endpoint\n- `frontend/src/components/EnvironmentDetailsModal.vue` (lines 111-122) - Use detail?.created_at, remove last_used row\n\n**Files READ (reference only):**\n- `frontend/src/types/comfygit.ts` - Verify EnvironmentInfo already has `created_at: string` (line 188) ‚úì\n- `frontend/src/composables/useComfyGitService.ts` - Verify detail fetch already returns created_at ‚úì\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:** Any non-environment-modal work\n**Cannot Run In Parallel With:** Any other bead modifying EnvironmentDetailsModal.vue or environments.py\n**Standalone task** - no dependencies, no dependents\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines changed)\n- **Risk:** Low (isolated to detail modal, subprocess has timeout, graceful fallback to None)\n\n## Acceptance Criteria\n- [ ] Detail endpoint returns ISO 8601 timestamp for `created_at` (e.g., \"2026-01-29T21:49:05-05:00\")\n- [ ] Modal shows \"Created: X days ago\" (or relative time) below the section divider\n- [ ] If git log fails, `created_at` returns None and row is hidden (graceful degradation)\n- [ ] List endpoint still returns `created_at: None` (no perf regression)\n- [ ] `last_used` row removed from modal (dead code)\n- [ ] Frontend rebuilt (`cd frontend \u0026\u0026 npm run build`)\n\n## Testing Requirements\n- **Existing tests:** `testing/integration/panel/test_environment_endpoints.py` mocks created_at ‚Äî no change needed\n- **Manual verification:** Open Environment Details modal for any test environment and confirm \"Created\" row appears with correct date\n- **Edge case:** Environment with corrupted/missing .git ‚Äî should gracefully show no date","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-30T02:57:50.06825731-05:00","created_by":"ubuntu","updated_at":"2026-01-30T03:02:42.632059653-05:00","closed_at":"2026-01-30T03:02:42.632059653-05:00","close_reason":"Implemented git-based created_at in detail endpoint and updated modal to use it"}
{"id":"cgm-2v9","title":"Accelerator Packages Panel: Browse and toggle overlay packages from Manager UI","description":"## Feature: Accelerator Packages Panel in Manager UI\n\n### Summary\n\nAdd a new submenu/panel to the ComfyGit Manager UI that lets users browse, toggle, and manage accelerator overlay packages (sageattention, triton, xformers, etc.) directly from the ComfyUI canvas. Shows available overlays with compatibility detection, current install status, and one-click enable/disable.\n\n### Motivation\n\nAccelerator packages like SageAttention and Triton provide significant performance gains but are platform-specific (CUDA-only, specific GPU architectures). Currently users must know about these packages and install them manually. A UI panel in the manager makes discovery and installation accessible to non-technical users.\n\n### Dependencies\n\n- **cg-1pa** (ComfyGit core): UV Overlay System must be implemented first ‚Äî this panel consumes the overlay API\n- Stock overlays must be shipped with comfygit-core package (Phase 2 of cg-1pa)\n\n### Design\n\n**New panel/submenu** in the manager sidebar (alongside existing Environment, Git, Workflow panels):\n\n**Panel sections:**\n1. **Available Accelerators** ‚Äî Stock overlays from comfygit-core with category=\"accelerator\"\n   - Shows: name, description, compatibility badge (supported / unsupported / unknown)\n   - Toggle: enable/disable overlay for current environment\n   - Status: installed (green) / available (blue) / incompatible (grey)\n\n2. **Environment Overlays** ‚Äî Custom overlays from `.cec/overlays/`\n   - Shows any environment-specific overlays the creator shipped\n   - Same toggle UX\n\n3. **Current Dependencies** ‚Äî Read-only view of what's in the environment\n   - Shows installed packages relevant to acceleration/compute\n   - Helps users understand their current stack\n\n**Platform detection:**\n- Overlay metadata includes `requires = [\"cuda\"]` or similar\n- Manager queries system capabilities (CUDA availability, GPU type via orchestrator/backend detection)\n- Incompatible overlays shown greyed out with explanation (\"Requires CUDA ‚Äî not detected on this system\")\n\n**Workflow:**\n1. User opens Accelerators panel\n2. Sees available overlays with compatibility status\n3. Toggles an overlay on ‚Üí manager calls core API (equivalent to `cg env-config overlays enable \u003cname\u003e`)\n4. Optionally triggers sync to install the packages\n5. Panel updates to show new status\n\n### API Requirements (from core)\n\nThe manager needs these endpoints from comfygit-core:\n- `list_overlays()` ‚Äî All available overlays (stock + environment) with metadata\n- `get_active_overlays()` ‚Äî Currently enabled overlays for this environment\n- `enable_overlay(name)` / `disable_overlay(name)` ‚Äî Toggle activation\n- `get_platform_capabilities()` ‚Äî CUDA available, GPU type, etc. (may already exist via PyTorchBackendManager)\n\n### Key Files (Manager)\n\n- `js/panels/` ‚Äî New accelerator panel component (NEW)\n- `js/api/` ‚Äî API client for overlay endpoints (NEW)\n- `__init__.py` or `routes.py` ‚Äî New API routes for overlay management (NEW)\n- Orchestrator integration for triggering sync after overlay changes\n\n### Acceptance Criteria\n\n- [ ] New \"Accelerators\" or \"Packages\" panel visible in manager sidebar\n- [ ] Panel lists stock overlays with descriptions and compatibility badges\n- [ ] Toggle enables/disables overlays via core API\n- [ ] Incompatible overlays clearly indicated with reason\n- [ ] Current environment dependencies visible\n- [ ] Optional sync trigger after enabling/disabling\n- [ ] Works with both stock overlays and environment-specific custom overlays\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-14T15:11:04.038907745-08:00","created_by":"ubuntu","updated_at":"2026-02-14T15:11:04.038907745-08:00","comments":[{"id":2,"issue_id":"cgm-2v9","author":"ubuntu","text":"Depends on cg-1pa (UV Overlay System in comfygit core). Stock overlays and overlay API must be available before this panel can be built.","created_at":"2026-02-14T23:11:10Z"}]}
{"id":"cgm-328","title":"Add collapsible workflow/node/model lists to environment details modal","notes":"## Context \u0026 Goal\nThe environment details modal currently shows only numeric counts for workflows, nodes, and models. Users want to see the actual names in expandable/collapsible sections with scrollable lists.\n\nThis task updates the frontend modal to:\n1. Fetch detailed environment info when the modal opens (new API call)\n2. Replace static count rows with collapsible sections\n3. Show workflow names, node names, and model names in scrollable lists\n\n## Current State vs Target State\n\n**Current:** `EnvironmentDetailsModal.vue` (lines 30-45) renders counts as plain text:\n```html\n\u003cdiv class=\"detail-row\"\u003e\n  \u003cspan class=\"label\"\u003eWorkflows:\u003c/span\u003e\n  \u003cspan class=\"value\"\u003e{{ environment.workflow_count }}\u003c/span\u003e\n\u003c/div\u003e\n```\n\n**Target:** Each section becomes a collapsible disclosure with a scrollable list:\n```\nWorkflows (3)                    [‚ñº]\n  ‚îú‚îÄ‚îÄ workflow1.json             (synced)\n  ‚îú‚îÄ‚îÄ new_workflow.json          (new)\n  ‚îî‚îÄ‚îÄ changed.json               (modified)\n\nNodes (2)                        [‚ñº]\n  ‚îú‚îÄ‚îÄ ComfyUI-Impact-Pack       v1.0.0\n  ‚îî‚îÄ‚îÄ ComfyUI-Manager           v2.1.0\n\nModels (1 missing)               [‚ñº]\n  ‚îî‚îÄ‚îÄ model.safetensors          (checkpoints, required)\n       used by: workflow1.json, workflow2.json\n```\n\nWhen collapsed, shows just the count (current behavior). When expanded, shows the scrollable list with max-height ~200px.\n\n## Implementation Details\n\n### 1. Update TypeScript types (`frontend/src/types/comfygit.ts`)\n\nAdd a new interface AFTER `EnvironmentInfo` (after line 196). Do NOT modify `EnvironmentInfo` ‚Äî it's used for the list endpoint.\n\nNOTE: The frontend already has a `NodeInfo` interface (line 359) for the full nodes endpoint. The `EnvironmentDetail` type should use inline types to avoid collision.\n\n```typescript\nexport interface EnvironmentDetail extends EnvironmentInfo {\n  workflows: {\n    synced: string[]\n    new: string[]\n    modified: string[]\n    deleted: string[]\n  }\n  nodes: Array\u003c{\n    name: string\n    version: string | null\n    source: string\n  }\u003e\n  models: {\n    missing: Array\u003c{\n      filename: string\n      category: string\n      workflow_names: string[]\n      criticality: string   // \"required\" | \"flexible\" | \"optional\"\n      can_download: boolean\n    }\u003e\n  }\n}\n```\n\n### 2. Add service method (`frontend/src/composables/useComfyGitService.ts`)\n\n**Add import** of `EnvironmentDetail` to the type imports at line 2-30:\n```typescript\nimport type {\n  ...\n  EnvironmentInfo,\n  EnvironmentDetail,   // ADD THIS\n  ...\n} from '@/types/comfygit'\n```\n\n**Add method** after `getEnvironments()` (after line 470):\n```typescript\nasync function getEnvironmentDetails(name: string): Promise\u003cEnvironmentDetail | null\u003e {\n  if (USE_MOCK) return null\n  try {\n    return await fetchApi\u003cEnvironmentDetail\u003e(`/v2/comfygit/environments/${encodeURIComponent(name)}`)\n  } catch {\n    return null\n  }\n}\n```\n\n**Expose in return object** ‚Äî add `getEnvironmentDetails` after `getEnvironments` at line ~1694:\n```typescript\n    // Environment Management\n    getEnvironments,\n    getEnvironmentDetails,  // ADD THIS\n    switchEnvironment,\n```\n\n### 3. Update EnvironmentsSection.vue\n\n**Update destructure** at line 160:\n```typescript\n// CURRENT:\nconst { getEnvironments } = useComfyGitService()\n\n// TARGET:\nconst { getEnvironments, getEnvironmentDetails } = useComfyGitService()\n```\n\n**Add import** for `EnvironmentDetail` type at line 140:\n```typescript\nimport type { EnvironmentInfo, EnvironmentDetail } from '@/types/comfygit'\n```\n\n**Add detail ref** after line 168:\n```typescript\nconst environmentDetail = ref\u003cEnvironmentDetail | null\u003e(null)\n```\n\n**Update `showEnvironmentDetails`** at line 188-190:\n```typescript\n// CURRENT:\nfunction showEnvironmentDetails(env: EnvironmentInfo) {\n  selectedEnvironment.value = env\n}\n\n// TARGET:\nasync function showEnvironmentDetails(env: EnvironmentInfo) {\n  selectedEnvironment.value = env\n  environmentDetail.value = null\n  const detail = await getEnvironmentDetails(env.name)\n  if (detail) environmentDetail.value = detail\n}\n```\n\n**Pass detail to modal** at lines 121-127:\n```html\n\u003cEnvironmentDetailsModal\n  v-if=\"selectedEnvironment\"\n  :environment=\"selectedEnvironment\"\n  :detail=\"environmentDetail\"\n  :can-delete=\"environments.length \u003e 1\"\n  @close=\"selectedEnvironment = null; environmentDetail = null\"\n  @delete=\"handleDetailsDelete\"\n/\u003e\n```\n\n### 4. Update EnvironmentDetailsModal.vue\n\n**Add `detail` prop** to the component:\n```typescript\nimport type { EnvironmentInfo, EnvironmentDetail } from '@/types/comfygit'\n\ndefineProps\u003c{\n  environment: EnvironmentInfo\n  detail?: EnvironmentDetail | null\n  canDelete?: boolean\n}\u003e()\n```\n\n**Add collapsible state** in `\u003cscript setup\u003e`:\n```typescript\nimport { ref } from 'vue'\n\nconst expandedSections = ref\u003cSet\u003cstring\u003e\u003e(new Set())\nfunction toggleSection(section: string) {\n  if (expandedSections.value.has(section)) {\n    expandedSections.value.delete(section)\n  } else {\n    expandedSections.value.add(section)\n  }\n}\n```\n\n**Replace static count rows** (lines 30-45) with collapsible sections. Each section:\n- Header: clickable row with count + chevron (‚ñ∂/‚ñº)\n- Body: `v-show` toggled list with `max-height: 200px; overflow-y: auto`\n- Workflow items show sync state badge (synced=green, new=blue, modified=orange, deleted=red)\n- Node items show version in muted text\n- Model items show category, criticality badge, and \"used by\" workflow names\n- While `detail` is null/undefined, show just the count from `environment` prop (loading state)\n\n**CSS additions:**\n- `.collapsible-header` ‚Äî clickable flex row with cursor:pointer\n- `.chevron` ‚Äî rotation transition for expand/collapse indicator\n- `.collapsible-body` ‚Äî max-height, overflow-y:auto, transition\n- `.item-list` ‚Äî list styling\n- `.sync-badge` ‚Äî small colored badge for sync state\n- `.criticality-badge` ‚Äî badge for model criticality\n- Use existing CSS variables: `--cg-color-success`, `--cg-color-warning`, `--cg-color-error`, `--cg-color-info`, `--cg-color-text-muted`, etc.\n\n### 5. Rebuild frontend\n```bash\ncd /data/projects/comfygit-ai/comfygit-manager/frontend \u0026\u0026 npm run build\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/types/comfygit.ts (after line 196) ‚Äî add EnvironmentDetail interface\n- frontend/src/composables/useComfyGitService.ts ‚Äî add import (line ~14), method (after line 470), return entry (line ~1694)\n- frontend/src/components/EnvironmentDetailsModal.vue ‚Äî major rework: add detail prop, collapsible sections, new CSS\n- frontend/src/components/EnvironmentsSection.vue ‚Äî add import (line 140), destructure (line 160), ref (line 168), async fetch (line 188), prop binding (line 121)\n\n**Files READ (reference only):**\n- frontend/src/components/base/BaseModal.vue ‚Äî understand modal slot structure\n- frontend/THEMES.md ‚Äî theme variable reference\n\n**Files CREATED:**\n- None (js/ build output auto-generated by npm run build)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-e6c (backend endpoint) ‚Äî no file overlap, API contract defined in that bead\n\n**Cannot Run In Parallel With:**\n- N/A (but integration testing requires backend to be deployed)\n\n## Estimated Scope\n- **Size:** Medium (~120-150 lines across 4 files)\n- **Risk:** Low (UI-only changes, graceful fallback when detail is null)\n\n## Acceptance Criteria\n- [ ] `EnvironmentDetail` type added to comfygit.ts after EnvironmentInfo\n- [ ] `getEnvironmentDetails(name)` method added to useComfyGitService with proper encoding\n- [ ] EnvironmentsSection fetches detail on modal open, passes as prop\n- [ ] Modal shows collapsible Workflows section with names + sync state badges\n- [ ] Modal shows collapsible Nodes section with names + versions\n- [ ] Modal shows collapsible Models section with filenames + category + criticality + workflow_names\n- [ ] Sections collapsed by default showing just count\n- [ ] Lists scrollable with max-height ~200px\n- [ ] Graceful fallback: if detail is null, shows counts only (loading/error state)\n- [ ] Theme-consistent styling using existing CSS variables\n- [ ] No TypeScript name collision with existing NodeInfo type\n- [ ] Frontend builds successfully: `cd frontend \u0026\u0026 npm run build`\n\n## Testing Requirements\n- Visual: open details modal on environments with workflows/nodes/models\n- Visual: verify collapse/expand toggles work\n- Visual: verify scrolling with many items\n- Visual: verify fallback when API unavailable (shows counts only)\n- No automated tests required for MVP","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-30T01:33:54.16139816-05:00","created_by":"ubuntu","updated_at":"2026-01-30T02:08:55.918137152-05:00","closed_at":"2026-01-30T02:08:55.918137152-05:00","close_reason":"Implemented by sprint agents. Backend endpoint and frontend collapsible modal merged to dev."}
{"id":"cgm-38y","title":"Update MissingResourcesPopup to use is-saved endpoint","notes":"## Context \u0026 Goal\n\n**Problem:** MissingResourcesPopup currently checks `workflow?.path || workflow?.filename` which is always false because `beforeConfigureGraph` only receives raw JSON without file metadata.\n\n**Solution:** Call new `/v2/comfygit/workflow/is-saved` endpoint to detect saved workflows via content hash matching.\n\n**Why it matters:** Popup should only appear for unsaved workflows - saved ones are tracked in ComfyGit panel.\n\n---\n\n## Current State vs Target State\n\n### Current: `frontend/src/components/MissingResourcesPopup.vue` lines 398-403\n\n```typescript\nasync function analyzeWorkflow(workflow: any) {\n  // Skip for saved workflows - issues tracked in ComfyGit panel\n  if (workflow?.path || workflow?.filename) {\n    console.log('[ComfyGit] Workflow saved to disk, skipping popup')\n    return\n  }\n```\n\n### Target: Replace path check with API call\n\n```typescript\nasync function analyzeWorkflow(workflow: any) {\n  // Skip if user globally disabled popup\n  if (localStorage.getItem('comfygit:popup-disabled') === 'true') {\n    console.log('[ComfyGit] Popup globally disabled')\n    return\n  }\n\n  // Check if this workflow is saved on disk via content hash\n  try {\n    const response = await fetch('/v2/comfygit/workflow/is-saved', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ workflow })\n    })\n    if (response.ok) {\n      const result = await response.json()\n      if (result.is_saved) {\n        console.log(\\`[ComfyGit] Workflow matches saved file: \\${result.filename}, skipping popup\\`)\n        return\n      }\n    }\n  } catch (e) {\n    console.warn('[ComfyGit] Failed to check if workflow is saved:', e)\n    // On error, proceed with popup (safe default)\n  }\n  // ...\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/MissingResourcesPopup.vue` (lines 398-403) - Replace path check with API call\n\n**Files CREATED:**\n- None\n\n**Files READ (reference only):**\n- None\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend bead (cgm-kg0) - no file overlap\n\n**Cannot Run In Parallel With:**\n- None (but requires backend endpoint to exist for testing)\n\n**Blocking Reason:** \n- Backend endpoint must exist for integration testing, but code changes don't conflict\n\n---\n\n## Estimated Scope\n- **Size:** Small (~15 lines changed)\n- **Risk:** Low (isolated change in single function)\n\n---\n\n## Acceptance Criteria\n- [ ] Popup skips for saved workflows (API returns `is_saved: true`)\n- [ ] Popup shows for unsaved/modified workflows\n- [ ] Popup shows if API call fails (safe fallback)\n- [ ] Frontend build succeeds\n\n---\n\n## Testing Requirements\n- Manual: Load saved workflow ‚Üí no popup\n- Manual: Load unsaved workflow with missing nodes ‚Üí popup appears\n- Manual: Modify saved workflow ‚Üí popup appears (hash no longer matches)\n- Manual: Disable network ‚Üí popup still works (fallback behavior)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T22:17:34.929999482-05:00","created_by":"ubuntu","updated_at":"2026-01-26T23:00:19.316521067-05:00","closed_at":"2026-01-26T23:00:19.316521067-05:00","close_reason":"Implemented in sprint run-1769484386145645150. Backend endpoint + frontend integration complete with 7 tests.","dependencies":[{"issue_id":"cgm-38y","depends_on_id":"cgm-kg0","type":"blocks","created_at":"2026-01-26T22:17:42.332259383-05:00","created_by":"ubuntu"}]}
{"id":"cgm-447","title":"Fix downloadCount to include pending download intents","notes":"# Context \u0026 Goal\n\n## Problem\nThe Review step shows \"0 to download\" in the summary stats even when 3 models have download intents and WILL be downloaded when the user clicks \"Apply Resolution\". This is misleading and confusing.\n\n## Why It Matters\nUsers see incorrect information before committing to an action. They might think nothing will happen, but clicking Apply actually triggers downloads. This erodes trust in the UI.\n\n## How It Serves Project Goals\nComfyGit aims to give users clear visibility and control over their workflow dependencies. Accurate counts are fundamental to that.\n\n---\n\n# Current State vs Target State\n\n## Current Code (PROBLEM)\n\n**File:** `frontend/src/components/WorkflowResolveModal.vue` (lines 636-642)\n\n```typescript\nconst downloadCount = computed(() =\u003e {\n  let count = 0\n  for (const choice of modelChoices.value.values()) {\n    if (choice.action === 'download') count++\n  }\n  return count\n})\n```\n\nThis ONLY counts models where user explicitly made a choice with `action === 'download'`. Download intents (models with URLs from workflow properties) that the user didn't modify are NOT counted.\n\n## Target Code (SOLUTION)\n\n```typescript\nconst downloadCount = computed(() =\u003e {\n  let count = 0\n  \n  // Count explicit user download choices\n  for (const choice of modelChoices.value.values()) {\n    if (choice.action === 'download') count++\n  }\n  \n  // Count download intents that user hasn't cancelled\n  // These will be downloaded even without explicit user action\n  for (const model of downloadIntentModels.value) {\n    const choice = modelChoices.value.get(model.filename)\n    // If no choice made, intent is preserved (will download)\n    // If choice is cancel_download, it won't download (don't count)\n    if (!choice || (choice.action !== 'cancel_download' \u0026\u0026 choice.action !== 'skip' \u0026\u0026 choice.action !== 'optional')) {\n      // Only count if not already counted via explicit download choice\n      if (!choice || choice.action !== 'download') {\n        count++\n      }\n    }\n  }\n  \n  return count\n})\n```\n\n---\n\n# Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/WorkflowResolveModal.vue` (lines 636-642) - Fix downloadCount computed property\n\n**Files READ (reference only):**\n- `frontend/src/components/WorkflowResolveModal.vue` (lines 531-543) - downloadIntentModels computed property (already exists, reuse)\n- `frontend/src/types/comfygit.ts` - ModelChoice type definition\n\n**Files CREATED:**\n- None\n\n---\n\n# Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing else modifies this specific computed property\n\n**Cannot Run In Parallel With:**\n- Any other task modifying WorkflowResolveModal.vue lines 620-700\n\n**Blocking Reason:**\n- None - this is a leaf task\n\n---\n\n# Estimated Scope\n\n- **Size:** Small (\u003c50 lines) - single computed property change\n- **Risk:** Low (isolated computation, doesn't affect other logic)\n\n---\n\n# Acceptance Criteria\n\n- [ ] When 3 models have download intents and user makes no changes, Review shows \"3 to download\"\n- [ ] When user cancels one download intent, Review shows \"2 to download\"\n- [ ] When user explicitly sets download action on an intent, it's counted once (not double)\n- [ ] Existing behavior for user-initiated downloads (not intents) unchanged\n\n---\n\n# Testing Requirements\n\n**Manual Verification:**\n1. Open a workflow with models that have `property_download_intent` match type\n2. Click through to Review step without making any choices\n3. Verify \"X to download\" matches actual download intent count\n4. Go back, cancel one intent, verify count decreases","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-22T14:28:11.373610644-05:00","created_by":"ubuntu","updated_at":"2026-01-22T14:47:14.170541297-05:00","closed_at":"2026-01-22T14:47:14.170541297-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-447","depends_on_id":"cgm-1cj","type":"parent-child","created_at":"2026-01-22T14:30:08.767619632-05:00","created_by":"ubuntu"}],"comments":[{"id":1,"issue_id":"cgm-447","author":"ubuntu","text":"**Post-implementation fix (2026-01-22):** Original implementation only filtered for `match_type === 'download_intent'` but backend returns TWO match types for download intents: `download_intent` (from pyproject.toml) and `property_download_intent` (from workflow node properties/embedded URLs). Fixed `downloadIntentModels` computed to check for both: `m.match_type === 'download_intent' || m.match_type === 'property_download_intent'`. The E2E test mocked only `download_intent` so the gap wasn't caught until real-world testing.","created_at":"2026-01-22T20:48:33Z"}]}
{"id":"cgm-46e","title":"Test issue for worktree verification","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-14T18:57:30.926391833-05:00","created_by":"ubuntu","updated_at":"2026-01-22T14:39:25.944016425-05:00","closed_at":"2026-01-14T18:58:20.008630164-05:00","close_reason":"Tested from worktree - closing to verify sync"}
{"id":"cgm-487","title":"Add get/set_huggingface_token repository methods","notes":"## Context \u0026 Goal\nAdd getter and setter methods for HuggingFace token to WorkspaceConfigRepository, following the exact pattern of civitai_token methods.\n\n**Why it matters:** These methods provide the API for other components (model_downloader, backend API) to read/write the HF token with proper env var fallback.\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/repositories/workspace_config_repository.py`):\n- Has `set_civitai_token()` at lines 104-117\n- Has `get_civitai_token()` at lines 119-132\n- NO huggingface methods\n\n**Target - Add after line 163:**\n```python\ndef set_huggingface_token(self, token: str | None):\n    \"\"\"Set or clear HuggingFace API token.\"\"\"\n    data = self.config_file\n    if token:\n        if not data.api_credentials:\n            data.api_credentials = APICredentials(huggingface_token=token)\n        else:\n            data.api_credentials.huggingface_token = token\n        logger.info(\"HuggingFace API token configured\")\n    else:\n        if data.api_credentials:\n            data.api_credentials.huggingface_token = None\n        logger.info(\"HuggingFace API token cleared\")\n    self.save(data)\n\ndef get_huggingface_token(self) -\u003e str | None:\n    \"\"\"Get HuggingFace API token from config or environment.\n    \n    Priority: HF_TOKEN env \u003e HUGGING_FACE_HUB_TOKEN env \u003e config file\n    \"\"\"\n    # Priority: environment variable \u003e config file\n    env_token = os.environ.get(\"HF_TOKEN\") or os.environ.get(\"HUGGING_FACE_HUB_TOKEN\")\n    if env_token:\n        logger.debug(\"Using HuggingFace token from environment\")\n        return env_token\n\n    data = self.config_file\n    if data.api_credentials and data.api_credentials.huggingface_token:\n        logger.debug(\"Using HuggingFace token from config\")\n        return data.api_credentials.huggingface_token\n\n    return None\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/repositories/workspace_config_repository.py` (add after line 163) - Add get/set methods\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/models/workspace_config.py` - APICredentials import\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing (depends on APICredentials having huggingface_token field)\n\n**Cannot Run In Parallel With:**\n- cgm-iuy (APICredentials dataclass) - MUST complete first\n- Any bead modifying workspace_config_repository.py\n\n**Blocking Reason:**\n- model_downloader and backend API need these methods to exist\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Low (follows established pattern)\n\n## Acceptance Criteria\n- [ ] `set_huggingface_token(token)` saves token to config\n- [ ] `set_huggingface_token(None)` clears token from config\n- [ ] `get_huggingface_token()` returns env var if set (HF_TOKEN or HUGGING_FACE_HUB_TOKEN)\n- [ ] `get_huggingface_token()` falls back to config if no env var\n- [ ] `get_huggingface_token()` returns None if neither set\n- [ ] Existing tests still pass\n\n## Testing Requirements\n- Run existing core tests\n- Manual: Set token via method, verify config.json has it\n- Manual: Set HF_TOKEN env, verify it takes priority over config\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T15:26:29.181112713-05:00","created_by":"ubuntu","updated_at":"2026-01-29T16:15:58.353881171-05:00","closed_at":"2026-01-29T16:15:58.353881171-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-487","depends_on_id":"cgm-iuy","type":"blocks","created_at":"2026-01-29T15:26:44.571282735-05:00","created_by":"ubuntu"}]}
{"id":"cgm-4oy","title":"Add general crash retry with delay to orchestrator","notes":"\n## Context \u0026 Goal\n\nThe orchestrator (`server/orchestrator.py`) has no general-purpose crash retry logic. When ComfyUI crashes with a non-standard exit code (anything other than 0, 42, or 43), the only recovery mechanism is to retry once without `extra_args` from the workspace config. If no `extra_args` were used, or if the retry also fails, the orchestrator immediately gives up and exits.\n\nThis is a problem for transient failures like OOM kills (exit -9/SIGKILL from the Linux kernel), where GPU memory may not have been released yet from the prior process. A short delay and retry would likely succeed.\n\n**Real-world scenario:** ComfyUI loads ~20GB of models into VRAM on a 24GB GPU. User triggers restart via control server. Old process terminates, but GPU memory takes a moment to free. New ComfyUI process tries to initialize CUDA, gets OOM-killed by the kernel (exit -9). Orchestrator gives up immediately.\n\n## Current State vs Target State\n\n### Current: `__init__` (line 677-680)\n```python\n# Crash recovery flags for extra_args bypass\nself._skip_extra_args = False\nself._used_extra_args = False\n```\n\n### Target: `__init__`\n```python\n# Crash recovery flags for extra_args bypass\nself._skip_extra_args = False\nself._used_extra_args = False\n\n# General crash retry state\nself._crash_retry_count = 0\n```\n\n### Current: `DEFAULT_CONFIG` (line 464-483)\n```python\nDEFAULT_CONFIG = {\n    \"version\": \"1.0\",\n    \"orchestrator\": {\n        \"control_port\": 5050,\n        \"control_port_range\": [5050, 5100],\n        \"enable_control_server\": True,\n        \"log_level\": \"info\",\n        \"health_check_timeout_s\": 180,\n        \"sync_timeout_s\": 600,\n    },\n    ...\n}\n```\n\n### Target: `DEFAULT_CONFIG`\n```python\nDEFAULT_CONFIG = {\n    \"version\": \"1.0\",\n    \"orchestrator\": {\n        \"control_port\": 5050,\n        \"control_port_range\": [5050, 5100],\n        \"enable_control_server\": True,\n        \"log_level\": \"info\",\n        \"health_check_timeout_s\": 180,\n        \"sync_timeout_s\": 600,\n        \"crash_retry_max\": 3,\n        \"crash_retry_delay_s\": 10,\n    },\n    ...\n}\n```\n\n### Current: `_handle_crash_for_recovery` (lines 1013-1040)\n```python\ndef _handle_crash_for_recovery(self, exit_code: int) -\u003e bool:\n    if self._used_extra_args and not self._skip_extra_args:\n        print(\"[Orchestrator] Crash detected with extra_args, retrying without them...\")\n        self._skip_extra_args = True\n        write_switch_status(...)\n        return True\n    return False\n```\n\n### Target: `_handle_crash_for_recovery`\n```python\ndef _handle_crash_for_recovery(self, exit_code: int) -\u003e bool:\n    # Strategy 1: If we used extra_args, retry without them first (existing logic)\n    if self._used_extra_args and not self._skip_extra_args:\n        print(\"[Orchestrator] Crash detected with extra_args, retrying without them...\")\n        self._skip_extra_args = True\n        self._crash_retry_count += 1\n        write_switch_status(\n            self.metadata_dir,\n            state=\"recovering\",\n            progress=50,\n            message=\"ComfyUI crashed. Retrying without custom startup args...\",\n            error=f\"Crash with exit code {exit_code}\"\n        )\n        return True\n\n    # Strategy 2: General retry with delay (handles OOM, transient failures)\n    max_retries = self.config[\"orchestrator\"].get(\"crash_retry_max\", 3)\n    retry_delay = self.config[\"orchestrator\"].get(\"crash_retry_delay_s\", 10)\n\n    if self._crash_retry_count \u003c max_retries:\n        self._crash_retry_count += 1\n        print(f\"[Orchestrator] Crash retry {self._crash_retry_count}/{max_retries} \"\n              f\"(exit {exit_code}), waiting {retry_delay}s...\")\n        time.sleep(retry_delay)\n        return True\n\n    # All retries exhausted\n    print(f\"[Orchestrator] All {max_retries} retries exhausted\")\n    return False\n```\n\n### Current: `_clear_crash_recovery_flags` (lines 1042-1045)\n```python\ndef _clear_crash_recovery_flags(self) -\u003e None:\n    self._skip_extra_args = False\n    self._used_extra_args = False\n```\n\n### Target: `_clear_crash_recovery_flags`\n```python\ndef _clear_crash_recovery_flags(self) -\u003e None:\n    self._skip_extra_args = False\n    self._used_extra_args = False\n    self._crash_retry_count = 0\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/orchestrator.py (lines 464-483 DEFAULT_CONFIG, line 679 __init__, lines 1013-1045 crash recovery methods)\n\n**Files READ (reference only):**\n- testing/unit/test_orchestrator_loop.py - understand existing test patterns\n- testing/unit/test_comfyui_backend_flags.py - existing crash recovery tests\n- testing/conftest.py - understand fixtures\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing (this is the foundation bead)\n\n**Cannot Run In Parallel With:**\n- The test bead - REASON: tests validate the implementation changes\n\n**Blocking Reason:**\n- Implementation must exist before tests can validate it\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines changed)\n- **Risk:** Medium (touches crash recovery path in the supervision loop, but changes are additive)\n\n## Acceptance Criteria\n- [ ] DEFAULT_CONFIG includes crash_retry_max (default 3) and crash_retry_delay_s (default 10)\n- [ ] Orchestrator.__init__ initializes self._crash_retry_count = 0\n- [ ] _handle_crash_for_recovery tries extra_args bypass first (preserves existing behavior)\n- [ ] _handle_crash_for_recovery then does general retries with delay up to max\n- [ ] _handle_crash_for_recovery logs retry count, exit code, and delay\n- [ ] _clear_crash_recovery_flags resets _crash_retry_count to 0\n- [ ] time.sleep(retry_delay) is called between retries (uses the existing time import)\n- [ ] After max retries exhausted, returns False and orchestrator exits\n- [ ] Existing behavior preserved: exit 0 (clean), 42 (restart), 43 (switch) unchanged\n\n## Testing Requirements\n- Existing tests in test_orchestrator_loop.py and test_comfyui_backend_flags.py must still pass\n- New tests needed (see dependent bead)\n- Manual verification: restart ComfyUI under memory pressure, observe retry behavior in logs\n","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-29T22:15:15.500409449-05:00","created_by":"ubuntu","updated_at":"2026-01-30T00:22:35.128297987-05:00","closed_at":"2026-01-30T00:22:35.128297987-05:00","close_reason":"Implemented and all 53 tests passing"}
{"id":"cgm-4pl","title":"Add huggingface_hub dependency to comfygit-core","notes":"## Context \u0026 Goal\n\nAdd `huggingface_hub\u003e=0.32.0` as a dependency to comfygit-core. This enables:\n- Official HuggingFace Hub API for listing repo files\n- `hf_hub_download()` for downloading with Xet storage optimization\n- Proper caching semantics\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit/packages/core/pyproject.toml`):\n```toml\n[project]\ndependencies = [\n    \"aiohttp\",\n    \"blake3\",\n    \"packaging\",\n    \"psutil\",\n    \"pyyaml\",\n    \"requests\",\n    \"requirements-parser\",\n    \"tomlkit\",\n    \"uv\",\n    \"xxhash\",\n]\n```\n\n**Target**:\n```toml\n[project]\ndependencies = [\n    \"aiohttp\",\n    \"blake3\",\n    \"huggingface_hub\u003e=0.32.0\",\n    \"packaging\",\n    \"psutil\",\n    \"pyyaml\",\n    \"requests\",\n    \"requirements-parser\",\n    \"tomlkit\",\n    \"uv\",\n    \"xxhash\",\n]\n```\n\n## Files Inventory\n\n**Files MODIFIED:**\n- /data/projects/comfygit-ai/comfygit/packages/core/pyproject.toml - add dependency\n\n**Files READ:** None\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 1 beads (no file overlap)\n\n**Cannot Run In Parallel With:** None\n\n**Blocking Reason:** Core library beads need this dependency installed first\n\n## Estimated Scope\n- **Size:** Small (\u003c10 lines)\n- **Risk:** Low (additive change)\n\n## Acceptance Criteria\n- [ ] `huggingface_hub\u003e=0.32.0` added to dependencies list (alphabetically sorted)\n- [ ] `uv sync` succeeds in core package directory\n- [ ] `from huggingface_hub import HfApi, hf_hub_download` works in Python\n\n## Testing Requirements\n- Run `uv sync` in `/data/projects/comfygit-ai/comfygit/packages/core`\n- Verify import works: `uv run python -c \"from huggingface_hub import HfApi\"` ","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:48:44.945873995-05:00","created_by":"ubuntu","updated_at":"2026-01-27T15:08:26.919197703-05:00","closed_at":"2026-01-27T15:08:26.919197703-05:00","close_reason":"Moved to comfygit repo as cg-pvt. This bead modifies comfygit-core, not comfygit-manager."}
{"id":"cgm-4r7","title":"Write property_download_intent models to pyproject.toml in apply_resolution","notes":"## Context \u0026 Goal\n\n**Problem:** When a workflow has models with embedded download URLs (`property_download_intent` from node `properties.models`), clicking \"Apply Resolution\" doesn't write them to pyproject.toml. This means when the download completes, `_finalize_download` can't find them to update their status from \"unresolved\" to \"resolved\".\n\n**User sees:** After download completes, workflow still shows \"missing models\" until they save the workflow (Ctrl+S) which triggers a re-analysis.\n\n**Root cause traced in discussion:**\n- `property_download_intent` models are in `result.models_resolved` (not unresolved/ambiguous)\n- `apply_resolution` only calls `fix_resolution` when `result.has_issues` is True\n- `ResolutionResult.has_issues` doesn't include download intents (only unresolved/ambiguous)\n- `fix_resolution` only processes `models_unresolved` and `models_ambiguous`, not `models_resolved`\n- So `property_download_intent` models never get written to pyproject.toml\n\n## Current State vs Target State\n\n**Current code** (`server/api/v2/workflows.py`, lines 839-846):\n```python\n# Apply strategies to fix unresolved issues (writes to pyproject.toml)\nif result.has_issues:\n    result = await run_sync(\n        env.workflow_manager.fix_resolution,\n        result,\n        node_strategy,\n        model_strategy\n    )\n```\n\n**Target state:** Add a new block after the fix_resolution call (around line 895, after model choices handling) to write `property_download_intent` models:\n\n```python\n# Write property_download_intent models to pyproject (they're in models_resolved, not processed by fix_resolution)\nfrom comfygit_core.models.manifest import ManifestWorkflowModel\ntry:\n    for model in result.models_resolved:\n        if model.match_type == \"property_download_intent\" and model.model_source:\n            # Check if already in pyproject (avoid duplicates)\n            existing_models = env.pyproject.workflows.get_workflow_models(name)\n            already_exists = any(\n                m.filename == model.reference.widget_value and m.sources\n                for m in existing_models\n            )\n            if not already_exists:\n                # Determine category from node type\n                category = _get_category_for_node_type(model.reference.node_type) or \"models\"\n                \n                manifest_model = ManifestWorkflowModel(\n                    filename=model.reference.widget_value,\n                    category=category,\n                    criticality=\"required\",\n                    status=\"unresolved\",\n                    nodes=[model.reference],\n                    sources=[model.model_source],\n                    relative_path=str(model.target_path) if model.target_path else None\n                )\n                env.pyproject.workflows.add_workflow_model(name, manifest_model)\nexcept Exception:\n    pass  # Continue even if write fails - downloads will still work\n```\n\nAlso need a helper function for category:\n```python\ndef _get_category_for_node_type(node_type: str) -\u003e str | None:\n    \"\"\"Infer model category from loader node type.\"\"\"\n    node_type_lower = node_type.lower()\n    if \"checkpoint\" in node_type_lower:\n        return \"checkpoints\"\n    elif \"vae\" in node_type_lower:\n        return \"vae\"\n    elif \"lora\" in node_type_lower:\n        return \"loras\"\n    elif \"clip\" in node_type_lower:\n        return \"clip\"\n    elif \"controlnet\" in node_type_lower:\n        return \"controlnet\"\n    elif \"upscale\" in node_type_lower:\n        return \"upscale_models\"\n    return None\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/api/v2/workflows.py (around lines 895-930) - add property_download_intent write logic\n\n**Files READ (reference only):**\n- comfygit_core/managers/workflow_manager.py:217-266 - reference for _write_model_resolution_grouped pattern\n- comfygit_core/models/manifest.py - ManifestWorkflowModel import\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:** Any non-workflows.py backend tasks\n\n**Cannot Run In Parallel With:** Any other task modifying server/api/v2/workflows.py\n\n**Blocking Reason:** None - this is a standalone fix\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Medium (touches apply_resolution which is core workflow)\n\n## Acceptance Criteria\n\n- [ ] After clicking \"Apply Resolution\" on a workflow with property_download_intent models, those models appear in pyproject.toml under [workflow.models.\u003cworkflow-name\u003e]\n- [ ] The models have status=\"unresolved\" and sources=[url]\n- [ ] When download completes, _finalize_download finds and updates them to status=\"resolved\"\n- [ ] Workflow status updates automatically without needing to save/re-open\n- [ ] Existing download_intent (from pyproject) behavior unchanged\n- [ ] No duplicate entries created if user re-runs resolution\n\n## Testing Requirements\n\n**Manual Verification:**\n1. Open a workflow with models that have embedded URLs (property_download_intent)\n2. Go through resolution wizard, click Apply Resolution\n3. Check pyproject.toml - model should be listed with status=\"unresolved\" and sources=[url]\n4. Wait for download to complete\n5. Re-open panel - workflow should show resolved (no missing models)\n6. Do NOT need to save workflow (Ctrl+S) for this to work\n\n**Existing tests:** testing/integration/panel/test_workflow_endpoints.py covers apply_resolution but may need new test case\n\n**New test:** Add test case that verifies property_download_intent models are written to pyproject","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-22T20:58:24.394520078-05:00","created_by":"ubuntu","updated_at":"2026-01-22T21:04:12.022671057-05:00","closed_at":"2026-01-22T21:04:12.022671057-05:00","close_reason":"Implemented property_download_intent write to pyproject.toml in apply_resolution. Added helper function _get_category_for_node_type() and new code block to write models before download starts. All 46 workflow tests pass."}
{"id":"cgm-51s","title":"Strip local path sources at commit time","description":"Add safety-net stripping of local filesystem path sources from pyproject.toml during execute_commit, preventing local dev paths from entering git history","notes":"# Task: Strip Local Path Sources at Commit Time\n\n## 1. Context \u0026 Goal\nWhen a developer has local path sources in their pyproject.toml (e.g., from running\n`uv add --editable /path/to/package`), those paths should NEVER be committed to git.\nThis task adds a safety-net strip step during `execute_commit()` that removes any\n`[tool.uv.sources]` entries with local filesystem paths before the commit is written.\n\nThe logic already exists in `_strip_local_path_sources()` (environment.py lines 2343-2373)\nbut is only called during `finalize_import()` (line 2072). We need to also call it during\nthe commit flow, and refactor it to work with the batched in-memory config pattern.\n\n## 2. Current State vs Target State\n\n### Current State\n\n**environment.py lines 2343-2373:** `_strip_local_path_sources()` ‚Äî loads from disk, strips, saves:\n```python\ndef _strip_local_path_sources(self) -\u003e None:\n    \"\"\"Remove uv sources with local filesystem paths (editable dev installs).\"\"\"\n    config = self.pyproject.load()\n    sources = config.get(\"tool\", {}).get(\"uv\", {}).get(\"sources\", {})\n    if not sources:\n        return\n    to_remove = []\n    for pkg_name, source_config in sources.items():\n        if isinstance(source_config, dict) and \"path\" in source_config:\n            path_value = source_config[\"path\"]\n            if isinstance(path_value, str) and not path_value.startswith((\"http://\", \"https://\")):\n                to_remove.append(pkg_name)\n                logger.info(f\"Stripping local path source: {pkg_name} -\u003e {path_value}\")\n    if to_remove:\n        for pkg_name in to_remove:\n            del sources[pkg_name]\n        self.pyproject.save(config)\n```\n\n**environment.py line 2072:** Called in `finalize_import()` ‚Äî no config param.\n\n**environment.py lines 1643-1682:** `execute_commit()` ‚Äî uses batched in-memory config:\n```python\nconfig = self.pyproject.load()                    # line 1646\n# ... mutations ...\nself.pyproject.save(config)                        # line 1675\nself.commit(message)                               # line 1682\n```\n\n### Target State\n\nRefactor `_strip_local_path_sources()` to accept an optional in-memory config dict\n(for batched mode), and return the list of stripped package names (for logging):\n\n```python\ndef _strip_local_path_sources(self, config: dict | None = None) -\u003e list[str]:\n    \"\"\"Remove uv sources with local filesystem paths (editable dev installs).\n\n    When environments are exported from dev machines, they may contain\n    [tool.uv.sources.package-name] entries with local paths like:\n        path = \"/home/dev/projects/my-package\"\n        editable = true\n\n    These paths don't exist on other machines and cause sync failures.\n    This method removes any source entries that use local paths.\n\n    Args:\n        config: If provided, mutate this dict in-place (batched mode).\n                If None, load from disk and save after stripping (standalone mode).\n\n    Returns:\n        List of stripped package names.\n    \"\"\"\n    standalone = config is None\n    if standalone:\n        config = self.pyproject.load()\n\n    sources = config.get(\"tool\", {}).get(\"uv\", {}).get(\"sources\", {})\n    if not sources:\n        return []\n\n    # Find sources with local paths (not URLs)\n    to_remove = []\n    for pkg_name, source_config in sources.items():\n        if isinstance(source_config, dict) and \"path\" in source_config:\n            path_value = source_config[\"path\"]\n            if isinstance(path_value, str) and not path_value.startswith((\"http://\", \"https://\")):\n                to_remove.append(pkg_name)\n                logger.info(f\"Stripping local path source: {pkg_name} -\u003e {path_value}\")\n\n    if to_remove:\n        for pkg_name in to_remove:\n            del sources[pkg_name]\n        if standalone:\n            self.pyproject.save(config)\n\n    return to_remove\n```\n\nThen in `execute_commit()`, insert between line 1672 (orphan cleanup) and line 1675 (save):\n```python\n        # Strip local filesystem path sources (machine-specific, never committed)\n        stripped = self._strip_local_path_sources(config=config)\n        if stripped:\n            logger.info(f\"Stripped {len(stripped)} local path source(s) from commit: {', '.join(stripped)}\")\n\n        # Save all changes at once\n        self.pyproject.save(config)\n```\n\nThe existing call at line 2072 (`self._strip_local_path_sources()`) continues to work\nunchanged (standalone mode, no config param).\n\n## 3. Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/core/environment.py`\n  - Lines 2343-2373: Refactor `_strip_local_path_sources()` ‚Äî add optional config param, return list\n  - Lines 1672-1675: Add strip call before save in `execute_commit()`\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/core/environment.py`\n  - Line 2072: Existing call in `finalize_import()` ‚Äî verify it still works\n  - Lines 1614-1682: Full `execute_commit()` for context\n\n## 4. Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-amo (LocalUVConfigManager) ‚Äî different files entirely\n- cgm-5kf (sync injection) ‚Äî same file (environment.py) but different line ranges:\n  - This task: execute_commit (1614-1682) and _strip_local_path_sources (2343-2373)\n  - cgm-5kf: sync (543-600) and new cached_property (~124)\n  - 500+ lines apart ‚Äî no merge conflict risk\n\n**Cannot Run In Parallel With:**\n- Nothing (fully independent after epic is unblocked)\n\n**Blocking Reason:** None ‚Äî but cgm-asa (tests) depends on this\n\n## 5. Estimated Scope\n- **Size:** Small (~30 lines changed in environment.py)\n- **Risk:** Low-Medium (modifies core commit flow, but change is additive and backward-compatible)\n\n## 6. Acceptance Criteria\n- [ ] `_strip_local_path_sources(config=None)` ‚Äî standalone mode loads from disk, saves after (backward compat)\n- [ ] `_strip_local_path_sources(config=dict)` ‚Äî batched mode mutates dict in-place, does NOT save\n- [ ] Returns `list[str]` of stripped package names\n- [ ] Existing call in `finalize_import()` (line 2072) still works unchanged\n- [ ] `execute_commit()` calls stripping before save (between orphan cleanup and save)\n- [ ] Local path sources are removed from pyproject.toml before git commit\n- [ ] Stripped sources are logged with package names\n- [ ] Non-path sources (git URLs, index refs like `{\"index\": \"pytorch-cu128\"}`) are NOT stripped\n- [ ] HTTP/HTTPS URL sources are NOT stripped\n- [ ] Empty sources dict after stripping is handled gracefully\n\n## 7. Testing Requirements\n- **Existing tests:** Run full test suite, especially:\n  - `tests/integration/test_export_import.py` ‚Äî finalize_import flow\n  - Any tests that exercise execute_commit\n- **New tests needed (in cgm-asa):**\n  - Test committing with local path sources ‚Üí verify they're stripped from committed pyproject\n  - Test committing with non-path sources ‚Üí verify they survive unchanged\n  - Test `_strip_local_path_sources(config=dict)` mutates in-place correctly\n  - Test `_strip_local_path_sources()` (no arg) loads/saves from disk (backward compat)\n  - Test returns correct list of stripped package names\n  - Test with empty sources section ‚Üí returns empty list, no errors","status":"tombstone","priority":2,"issue_type":"task","created_at":"2026-01-30T16:46:06.275415679-05:00","created_by":"ubuntu","updated_at":"2026-01-30T17:02:36.898085309-05:00","deleted_at":"2026-01-30T17:02:36.898085309-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"cgm-5kf","title":"Integrate local UV config injection into sync flow","description":"Extend the PyTorch injection context manager to also inject local UV sources/indexes from .local-uv-config during uv sync","notes":"# Task: Integrate Local UV Config Injection into Sync Flow (DRY Refactor)\n\n## 1. Context \u0026 Goal\nThe existing `_inject_pytorch_config()` in pyproject_manager.py (lines 549-647) does two things:\n1. **Strip** existing PyTorch entries (lines 562-588) ‚Äî PyTorch-specific criteria\n2. **Inject** new entries (lines 590-647) ‚Äî generic: add indexes, sources, constraints\n\nThe injection half is **exactly** what local UV config needs too. Rather than duplicating\nthis logic, we should extract a shared `_inject_uv_overrides(config, overrides_dict)` method\nthat both PyTorch and local UV config use.\n\nThis DRY refactor means:\n- One injection codepath (fewer bugs, easier to maintain)\n- Both systems produce the same dict format: `{\"indexes\": [...], \"sources\": {...}, \"constraints\": [...]}`\n- The context manager handles multiple injection sources in a single snapshot/restore cycle\n\n## 2. Current State vs Target State\n\n### Current State\n\n**pyproject_manager.py line 360-428:** `pytorch_injection_context()` ‚Äî hardcoded for PyTorch only\n**pyproject_manager.py line 549-647:** `_inject_pytorch_config()` ‚Äî strip PyTorch + inject (interleaved)\n**uv_project_manager.py line 163-208:** `sync_project()` ‚Äî only accepts `pytorch_manager`\n**uv_project_manager.py line 508-625:** `sync_dependencies_progressive()` ‚Äî only threads `pytorch_manager`\n**environment.py line 122-124:** Only `pytorch_manager` cached property\n**environment.py line 594-599:** Only passes `pytorch_manager` to sync chain\n\n### Target State\n\n#### Step 1: Extract shared injection method in pyproject_manager.py\n\nExtract the injection half of `_inject_pytorch_config()` (lines 590-647) into a new\nshared method:\n\n```python\ndef _inject_uv_overrides(self, config: dict, overrides: dict) -\u003e None:\n    \"\"\"Inject UV configuration overrides into pyproject.toml config.\n    \n    This is the shared injection method used by both PyTorch and local UV config.\n    \n    Args:\n        config: The pyproject.toml config dict to modify in-place\n        overrides: Dict with keys:\n            - indexes: list[dict] with name/url/explicit\n            - sources: dict[str, dict] mapping package names to source configs\n            - constraints: list[str] constraint dependency strings\n    \"\"\"\n    import tomlkit\n    \n    # Ensure tool.uv section exists\n    if 'tool' not in config:\n        config['tool'] = tomlkit.table()\n    if 'uv' not in config['tool']:\n        config['tool']['uv'] = tomlkit.table()\n    uv_config = config['tool']['uv']\n\n    # Inject indexes\n    existing_indexes = uv_config.get('index', [])\n    if not isinstance(existing_indexes, list):\n        existing_indexes = [existing_indexes] if existing_indexes else []\n    for new_index in overrides.get('indexes', []):\n        exists = any(\n            idx.get('name') == new_index['name']\n            for idx in existing_indexes\n        )\n        if not exists:\n            index_table = tomlkit.table()\n            index_table['name'] = new_index['name']\n            index_table['url'] = new_index['url']\n            index_table['explicit'] = new_index.get('explicit', True)\n            existing_indexes.append(index_table)\n    if existing_indexes:\n        aot = tomlkit.aot()\n        for idx in existing_indexes:\n            if hasattr(idx, 'items'):\n                aot.append(idx)\n            else:\n                tbl = tomlkit.table()\n                for k, v in idx.items():\n                    tbl[k] = v\n                aot.append(tbl)\n        uv_config['index'] = aot\n\n    # Inject sources\n    if 'sources' not in uv_config:\n        uv_config['sources'] = tomlkit.table()\n    for package_name, source in overrides.get('sources', {}).items():\n        uv_config['sources'][package_name] = source\n\n    # Inject constraints\n    constraints = overrides.get('constraints', [])\n    if constraints:\n        existing_constraints = uv_config.get('constraint-dependencies', [])\n        for constraint in constraints:\n            if constraint not in existing_constraints:\n                existing_constraints.append(constraint)\n        uv_config['constraint-dependencies'] = existing_constraints\n```\n\n#### Step 2: Refactor `_inject_pytorch_config()` to use shared method\n\n```python\ndef _inject_pytorch_config(self, config: dict, pytorch_config: dict) -\u003e None:\n    \"\"\"Inject PyTorch-specific configuration into pyproject.toml config.\n    \n    IMPORTANT: First strips existing PyTorch config to handle \"polluted\" files,\n    then delegates to shared _inject_uv_overrides() for the actual injection.\n    \"\"\"\n    from ..constants import PYTORCH_CORE_PACKAGES\n\n    # FIRST: Strip existing PyTorch config (PyTorch-specific cleanup)\n    if 'tool' in config and 'uv' in config['tool']:\n        uv_config = config['tool']['uv']\n        # ... (existing strip logic lines 566-588, unchanged) ...\n\n    # THEN: Inject using shared method\n    self._inject_uv_overrides(config, pytorch_config)\n```\n\n#### Step 3: Extend the injection context to accept local UV config\n\n```python\ndef pytorch_injection_context(\n    self,\n    pytorch_manager: PyTorchBackendManager,\n    backend_override: str | None = None,\n    local_uv_config_manager: LocalUVConfigManager | None = None,  # NEW\n):\n    \"\"\"Context manager that temporarily injects machine-local config during sync.\n    \n    Handles PyTorch backend config and optionally local UV overrides,\n    all within a single snapshot/restore cycle.\n    \"\"\"\n    from contextlib import contextmanager\n\n    @contextmanager\n    def _injection_context():\n        original_content = self.path.read_text()\n        effective_backend = backend_override or \"unknown\"\n\n        try:\n            config = self.load()\n            python_version = config.get(\"tool\", {}).get(\"comfygit\", {}).get(\"python_version\")\n\n            # 1. Inject PyTorch config (strip existing + inject correct)\n            pytorch_config = pytorch_manager.get_pytorch_config(\n                backend_override=backend_override,\n                python_version=python_version,\n            )\n            self._inject_pytorch_config(config, pytorch_config)\n\n            # 2. Inject local UV config (if present)\n            if local_uv_config_manager:\n                local_config = local_uv_config_manager.get_injection_config()\n                if local_config:\n                    # Uses same shared method ‚Äî no stripping needed for local config\n                    self._inject_uv_overrides(config, local_config)\n                    logger.debug(\"Injected local UV config overrides\")\n\n            self.save(config)\n            effective_backend = backend_override or pytorch_manager.get_backend()\n            logger.debug(f\"Injected config for sync (backend: {effective_backend})\")\n\n            yield\n\n        except Exception:\n            logger.error(\"=== Sync Injection Failure ===\")\n            logger.error(f\"Backend: {effective_backend}\")\n            try:\n                logger.error(f\"Injected config:\\n{self.path.read_text()}\")\n            except Exception:\n                pass\n            raise\n\n        finally:\n            self.path.write_text(original_content)\n            self._config_cache = None\n            self._cache_mtime = None\n            logger.debug(\"Restored original pyproject.toml after injection\")\n\n    return _injection_context()\n```\n\n#### Step 4: Handle case where only local UV config exists (no PyTorch)\n\nThe current `sync_project()` only enters the injection context if `pytorch_manager` is\nprovided. We need to also enter it when `local_uv_config_manager` is provided.\n\n```python\n# uv_project_manager.py sync_project()\ndef sync_project(\n    self,\n    verbose: bool = False,\n    pytorch_manager: PyTorchBackendManager | None = None,\n    backend_override: str | None = None,\n    local_uv_config_manager: LocalUVConfigManager | None = None,  # NEW\n    **flags\n) -\u003e str:\n    needs_injection = pytorch_manager or (\n        local_uv_config_manager and local_uv_config_manager.exists()\n    )\n\n    if needs_injection:\n        if pytorch_manager:\n            from ..constants import PYTORCH_CORE_PACKAGES\n            flags['reinstall_package'] = list(PYTORCH_CORE_PACKAGES)\n            if backend_override:\n                lock_file = self.pyproject.path.parent / \"uv.lock\"\n                if lock_file.exists():\n                    lock_file.unlink()\n\n        with self.pyproject.pytorch_injection_context(\n            pytorch_manager=pytorch_manager,  # May be None\n            backend_override=backend_override,\n            local_uv_config_manager=local_uv_config_manager,\n        ):\n            result = self.uv.sync(verbose=verbose, **flags)\n            return result.stdout\n    else:\n        result = self.uv.sync(verbose=verbose, **flags)\n        return result.stdout\n```\n\n**WAIT** ‚Äî `pytorch_injection_context` currently requires `pytorch_manager` as a non-optional\nfirst arg. We need to make it optional OR rename the method.\n\n**Decision:** Rename to `sync_injection_context()` and make `pytorch_manager` optional:\n\n```python\ndef sync_injection_context(\n    self,\n    pytorch_manager: PyTorchBackendManager | None = None,\n    backend_override: str | None = None,\n    local_uv_config_manager: LocalUVConfigManager | None = None,\n):\n```\n\nKeep `pytorch_injection_context` as a thin backward-compatible alias that just calls\n`sync_injection_context(pytorch_manager=pytorch_manager, ...)`.\n\n#### Step 5: Thread `local_uv_config_manager` through the chain\n\n**environment.py** ‚Äî add cached property (~line 124):\n```python\n@cached_property\ndef local_uv_config_manager(self):\n    from ..managers.local_uv_config_manager import LocalUVConfigManager\n    return LocalUVConfigManager(self.cec_path)\n```\n\n**environment.py sync()** (~line 594-600) ‚Äî pass through:\n```python\nsync_result = self.uv_manager.sync_dependencies_progressive(\n    dry_run=dry_run,\n    callbacks=sync_callbacks,\n    verbose=verbose,\n    pytorch_manager=self.pytorch_manager,\n    backend_override=backend_override,\n    local_uv_config_manager=self.local_uv_config_manager,  # NEW\n)\n```\n\n**uv_project_manager.py sync_dependencies_progressive()** (~line 508) ‚Äî add param and pass through:\n```python\ndef sync_dependencies_progressive(\n    self,\n    dry_run: bool = False,\n    callbacks=None,\n    verbose: bool = False,\n    pytorch_manager: PyTorchBackendManager | None = None,\n    backend_override: str | None = None,\n    local_uv_config_manager: LocalUVConfigManager | None = None,  # NEW\n) -\u003e dict:\n    # ... in the while loop, pass to sync_project():\n    self.sync_project(\n        group=group_list,\n        dry_run=dry_run,\n        verbose=verbose,\n        pytorch_manager=pytorch_manager,\n        backend_override=backend_override,\n        local_uv_config_manager=local_uv_config_manager,  # NEW\n    )\n```\n\n## 3. Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/pyproject_manager.py`\n  - NEW method `_inject_uv_overrides()` (~30 lines, extracted from lines 590-647)\n  - REFACTOR `_inject_pytorch_config()` (lines 549-647) to call `_inject_uv_overrides()`\n  - RENAME `pytorch_injection_context()` ‚Üí `sync_injection_context()` (lines 360-428)\n  - ADD backward-compat alias `pytorch_injection_context`\n  - ADD `local_uv_config_manager` param to context manager\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/uv_project_manager.py`\n  - MODIFY `sync_project()` (lines 163-208) ‚Äî add `local_uv_config_manager` param, handle injection-without-pytorch case\n  - MODIFY `sync_dependencies_progressive()` (lines 508-625) ‚Äî add param, pass through\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/core/environment.py`\n  - ADD `local_uv_config_manager` cached property (~line 124)\n  - MODIFY `sync()` (~line 594-600) ‚Äî pass `local_uv_config_manager` to chain\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/local_uv_config_manager.py` ‚Äî From cgm-amo (dependency)\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/pytorch_backend_manager.py` ‚Äî `get_pytorch_config()` return format (lines 198-263)\n\n## 4. Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-51s (commit stripping) ‚Äî touches different methods in environment.py:\n  - This: sync() at ~line 594 + cached property at ~line 124\n  - cgm-51s: execute_commit() at ~line 1672 + _strip_local_path_sources() at ~line 2343\n  - These are 500+ lines apart, no merge conflict risk\n\n**Cannot Run In Parallel With:**\n- cgm-amo (LocalUVConfigManager) ‚Äî this task DEPENDS on it\n\n**Depends On:**\n- cgm-amo ‚Äî needs LocalUVConfigManager class to exist\n\n**Blocking Reason:**\n- Tests (cgm-asa) need this complete before they can test the full injection pipeline\n\n## 5. Estimated Scope\n- **Size:** Medium (~100 lines changed across 3 files, mostly refactoring existing code)\n- **Risk:** Medium (modifies sync pipeline, but the refactor is extractive ‚Äî moving code, not rewriting)\n\n## 6. Acceptance Criteria\n- [ ] `_inject_uv_overrides(config, overrides)` exists as shared method\n- [ ] `_inject_pytorch_config()` delegates to `_inject_uv_overrides()` after stripping\n- [ ] `sync_injection_context()` exists and accepts both `pytorch_manager` and `local_uv_config_manager` (both optional)\n- [ ] `pytorch_injection_context()` still works as backward-compatible alias\n- [ ] Local UV sources from `.local-uv-config` are injected during sync\n- [ ] Local UV indexes from `.local-uv-config` are injected during sync\n- [ ] Original pyproject.toml is ALWAYS restored after sync (even on failure)\n- [ ] When no `.local-uv-config` exists, behavior is identical to current (no regression)\n- [ ] When no `pytorch_manager` but `local_uv_config_manager` exists, injection still works\n- [ ] Both PyTorch AND local UV injection happen in same snapshot/restore cycle\n- [ ] `sync_project()` and `sync_dependencies_progressive()` accept and pass `local_uv_config_manager`\n- [ ] `environment.sync()` passes `self.local_uv_config_manager` into the chain\n- [ ] All existing PyTorch injection behavior is unchanged (same tests pass)\n\n## 7. Testing Requirements\n- **Existing tests MUST pass:** All PyTorch injection/stripping tests in:\n  - `tests/unit/managers/test_pytorch_injection.py`\n  - `tests/unit/managers/test_pytorch_stripping.py`\n  - `tests/integration/test_pytorch_reconfiguration.py`\n- **New tests needed (in cgm-asa):**\n  - Test `_inject_uv_overrides()` with indexes, sources, constraints\n  - Test `sync_injection_context()` with only local UV config (no pytorch)\n  - Test `sync_injection_context()` with both pytorch AND local UV config\n  - Test restoration on failure with both injection types\n  - Test backward compat: `pytorch_injection_context()` alias still works","status":"tombstone","priority":2,"issue_type":"task","created_at":"2026-01-30T16:46:51.846353561-05:00","created_by":"ubuntu","updated_at":"2026-01-30T17:02:36.898085309-05:00","deleted_at":"2026-01-30T17:02:36.898085309-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"cgm-5ns","title":"Update model_downloader to use workspace config for HF token","notes":"## Context \u0026 Goal\nUpdate the model downloader to use `workspace_config.get_huggingface_token()` instead of directly checking environment variables. This enables the UI-configured token to be used for downloads.\n\n**Why it matters:** Currently HF downloads only work with env vars. After this change, tokens set via UI will also work.\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/services/model_downloader.py`):\n\nLine 168-187 `_check_provider_auth()`:\n```python\nelif provider == \"huggingface\":\n    # Check HF_TOKEN environment variable\n    token = os.environ.get(\"HF_TOKEN\") or os.environ.get(\"HUGGING_FACE_HUB_TOKEN\")\n    return token is not None and token.strip() != \"\"\n```\n\nLine 285 in `_download_huggingface()`:\n```python\n# Get HF token from environment\ntoken = os.environ.get(\"HF_TOKEN\") or os.environ.get(\"HUGGINGFACE_TOKEN\")\n```\n\n**Target:**\n\nLine 168-187:\n```python\nelif provider == \"huggingface\":\n    # Check via workspace config (handles env var fallback)\n    if not self.workspace_config:\n        return False\n    token = self.workspace_config.get_huggingface_token()\n    return token is not None and token.strip() != \"\"\n```\n\nLine 285:\n```python\n# Get HF token from workspace config (handles env var \u003e config priority)\ntoken = self.workspace_config.get_huggingface_token() if self.workspace_config else None\n```\n\n## ‚ö†Ô∏è Breaking Change: Environment Variable Names\n\n**Before:** Line 285 checked `HUGGINGFACE_TOKEN` (non-standard)\n**After:** Repository method checks `HF_TOKEN` and `HUGGING_FACE_HUB_TOKEN` (official HF env vars)\n\nUsers with `HUGGINGFACE_TOKEN` set will need to rename to `HF_TOKEN`.\n\n**Rationale:** The official huggingface_hub library recognizes `HF_TOKEN` and `HUGGING_FACE_HUB_TOKEN`. Using consistent env var names avoids confusion.\n\n**Migration:** Add note to release notes if this ships.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/services/model_downloader.py` (lines 182-185, 285) - Use workspace config getter\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/repositories/workspace_config_repository.py` - Reference for method signature\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend API bead (different file)\n- Frontend beads (different package)\n\n**Cannot Run In Parallel With:**\n- cgm-487 (repository methods) - MUST complete first\n\n**Blocking Reason:**\n- None (leaf node in dependency tree for core changes)\n\n## Estimated Scope\n- **Size:** Small (\u003c20 lines changed)\n- **Risk:** Low (simple substitution, same behavior)\n\n## Acceptance Criteria\n- [ ] `_check_provider_auth(\"huggingface\")` uses workspace_config.get_huggingface_token()\n- [ ] `_download_huggingface()` uses workspace_config.get_huggingface_token()\n- [ ] Downloads work with HF_TOKEN env var set (existing behavior)\n- [ ] Downloads work with HUGGING_FACE_HUB_TOKEN env var set (existing behavior)\n- [ ] Downloads work with config-stored token (new behavior)\n- [ ] Existing model_downloader tests pass\n\n## Testing Requirements\n- Run: `cd /data/projects/comfygit-ai/comfygit/packages/core \u0026\u0026 uv run pytest tests/unit/services/test_model_downloader*.py -v`\n- Manual: Test download with token in config (not env)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T15:26:44.58665104-05:00","created_by":"ubuntu","updated_at":"2026-01-29T16:23:35.467700533-05:00","closed_at":"2026-01-29T16:23:35.467700533-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-5ns","depends_on_id":"cgm-487","type":"blocks","created_at":"2026-01-29T15:27:03.337449541-05:00","created_by":"ubuntu"}]}
{"id":"cgm-74m","title":"Switch lock not released on os._exit(43) ‚Äî causes stale 'switch already in progress' errors","notes":"# Bug: Switch Lock Not Released on os._exit(43)\n\n## Context \u0026 Goal\n\nWhen a user initiates an environment switch via the panel UI, the API endpoint acquires a switch lock file, writes the switch request, then exits via `os._exit(43)`. Because `os._exit()` bypasses all cleanup, the lock file is never released. The orchestrator is supposed to clean it up after completing the switch, but if the switch fails or the orchestrator dies mid-switch, the lock persists until its 300s age timeout expires. During that window, all subsequent switch attempts fail with \"Environment switch already in progress\" (HTTP 409).\n\nThis was observed in practice: after killing a stuck orchestrator and restarting, the UI still reported a switch was in progress until `orch clean` manually removed `.switch.lock`.\n\n## Current State vs Target State\n\n**Current code** (`server/api/v2/environments.py:305-328`):\n\\`\\`\\`python\n# Check for concurrent switch (acquire lock)\nmetadata_dir = workspace.path / \".metadata\"\nif not orchestrator.acquire_switch_lock(metadata_dir):\n    return web.json_response({\n        \"error\": \"Environment switch already in progress\"\n    }, status=409)\n\n# ... write switch request (line 317-319) ...\n\n# Schedule exit with code 43 (after response sent)\nimport asyncio\n\nasync def delayed_exit():\n    await asyncio.sleep(2)  # Give response time to send\n    os._exit(SWITCH_ENV_EXIT_CODE)  # ‚Üê bypasses all cleanup, lock never released\n\nasyncio.create_task(delayed_exit())\n\\`\\`\\`\n\n**Target**: The lock should either:\n- (a) Be released by the orchestrator after it reads the switch request file (the orchestrator already cleans up on success at ~line 800, but not on all failure paths), OR\n- (b) Store the orchestrator PID in the lock file so `acquire_switch_lock` can check if the owning process is still alive before respecting the lock\n\nRecommended approach (b) ‚Äî write the PID into the lock file instead of just `touch()`:\n\n**Target code** (`server/orchestrator.py:367-385`):\n\\`\\`\\`python\ndef acquire_switch_lock(metadata_dir: Path, timeout: int = 300) -\u003e bool:\n    lock_file = metadata_dir / \".switch.lock\"\n\n    if lock_file.exists():\n        # Check if stale by age\n        age = time.time() - lock_file.stat().st_mtime\n        if age \u003e timeout:\n            lock_file.unlink()\n        else:\n            # Check if owning process is still alive\n            try:\n                pid = int(lock_file.read_text().strip())\n                os.kill(pid, 0)  # Signal 0 = check existence\n                return False  # Process alive, lock is valid\n            except (ValueError, ProcessLookupError, PermissionError):\n                lock_file.unlink()  # Process dead, remove stale lock\n\n    lock_file.write_text(str(os.getpid()))\n    return True\n\\`\\`\\`\n\nAlso ensure orchestrator releases lock on ALL failure paths in `run_forever()`, not just the success path.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/orchestrator.py (lines 367-385) - acquire_switch_lock: write PID into lock, add liveness check\n- server/orchestrator.py (lines ~813-838) - ensure release_switch_lock called on rollback and failure paths\n\n**Files READ (reference only):**\n- server/api/v2/environments.py (lines 305-328) - understand lock acquisition flow\n- server/orchestrator.py (lines 795-838) - understand success/failure/rollback paths\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-ssk (frontend bug, different files entirely)\n- Health check timeout bead (different functions in same file, no overlap)\n\n**Cannot Run In Parallel With:**\n- Any bead that also modifies acquire_switch_lock or lock-related functions\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines changed)\n- **Risk:** Medium - touches lock logic that gates all environment switches\n\n## Acceptance Criteria\n- [ ] Lock file contains PID, not just empty touch\n- [ ] acquire_switch_lock checks PID liveness before respecting a non-stale lock\n- [ ] Dead-process lock is auto-cleaned regardless of age\n- [ ] release_switch_lock called in rollback path (line ~816) and failure path (line ~833)\n- [ ] Manual test: kill orchestrator mid-switch, verify next switch doesn't get 409\n\n## Testing Requirements\n- Existing tests: Check if orchestrator has unit tests for lock functions\n- New tests: Test acquire_switch_lock with dead PID in lock file, test with live PID, test age-based cleanup still works\n- Manual: Kill orchestrator during switch, attempt new switch immediately","status":"open","priority":2,"issue_type":"bug","created_at":"2026-02-02T20:35:11.807583243-05:00","created_by":"ubuntu","updated_at":"2026-02-02T20:35:11.807583243-05:00"}
{"id":"cgm-8a9","title":"Integrate BranchDetailModal into BranchSection","notes":"## Context \u0026 Goal\n\n**Problem:** BranchSection currently shows Delete/Switch buttons inline. Need to change UX so clicking a row opens BranchDetailModal instead.\n\n**Solution:** \n1. Remove inline Delete button entirely\n2. Keep Switch button for non-current branches (quick action)\n3. Make branch rows clickable to open the detail modal\n4. Handle modal events (delete, switch, close)\n\n---\n\n## Current State vs Target State\n\n### Current: BranchSection.vue lines 34-60\n```vue\n\u003cdiv v-else class=\"branch-list\"\u003e\n  \u003cBranchListItem\n    v-for=\"branch in branches\"\n    :key=\"branch.name\"\n    :branch-name=\"branch.name\"\n    :is-current=\"branch.is_current\"\n  \u003e\n    \u003ctemplate #actions\u003e\n      \u003cActionButton\n        v-if=\"!branch.is_current\"\n        variant=\"destructive\"\n        size=\"xs\"\n        @click=\"$emit('delete', branch.name)\"\n      \u003e\n        Delete\n      \u003c/ActionButton\u003e\n      \u003cActionButton\n        v-if=\"!branch.is_current\"\n        variant=\"secondary\"\n        size=\"xs\"\n        @click=\"$emit('switch', branch.name)\"\n      \u003e\n        Switch\n      \u003c/ActionButton\u003e\n    \u003c/template\u003e\n  \u003c/BranchListItem\u003e\n\u003c/div\u003e\n```\n\n### Target: Clickable rows + modal\n```vue\n\u003cdiv v-else class=\"branch-list\"\u003e\n  \u003cBranchListItem\n    v-for=\"branch in branches\"\n    :key=\"branch.name\"\n    :branch-name=\"branch.name\"\n    :is-current=\"branch.is_current\"\n    :clickable=\"true\"\n    :show-current-label=\"true\"\n    @click=\"openBranchDetail(branch)\"\n  \u003e\n    \u003ctemplate #actions\u003e\n      \u003cActionButton\n        v-if=\"!branch.is_current\"\n        variant=\"secondary\"\n        size=\"xs\"\n        @click.stop=\"$emit('switch', branch.name)\"\n      \u003e\n        Switch\n      \u003c/ActionButton\u003e\n    \u003c/template\u003e\n  \u003c/BranchListItem\u003e\n\u003c/div\u003e\n\n\u003c!-- Modal --\u003e\n\u003cBranchDetailModal\n  v-if=\"selectedBranch\"\n  :branch-name=\"selectedBranch.name\"\n  :is-current=\"selectedBranch.is_current\"\n  @close=\"selectedBranch = null\"\n  @delete=\"handleDeleteFromModal\"\n  @switch=\"handleSwitchFromModal\"\n/\u003e\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/BranchSection.vue` (lines 1-103) - Add modal integration, update template\n\n**Files READ (reference only):**\n- `frontend/src/components/BranchDetailModal.vue` - Import and use (created by cgm-w6s)\n- `frontend/src/components/base/molecules/BranchListItem.vue` - Verify clickable prop API\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing - this is the final integration step\n\n**Cannot Run In Parallel With:**\n- cgm-w6s - REASON: Must wait for BranchDetailModal to exist\n\n**Depends On:** cgm-w6s (BranchDetailModal component)\n\n---\n\n## Estimated Scope\n- **Size:** Small (~40 lines changed)\n- **Risk:** Low (changes contained to BranchSection)\n\n---\n\n## Acceptance Criteria\n- [ ] Clicking any branch row opens BranchDetailModal\n- [ ] Delete button removed from inline actions\n- [ ] Switch button remains for non-current branches (with @click.stop)\n- [ ] Current branch row shows only \"current\" label (no Switch button)\n- [ ] Modal delete event triggers existing delete flow in parent\n- [ ] Modal switch event triggers existing switch flow in parent\n- [ ] Modal closes after successful delete/switch action\n- [ ] Frontend builds without errors\n\n---\n\n## Testing Requirements\n- Manual: Click branch row ‚Üí modal opens\n- Manual: Click Switch button ‚Üí switch flow triggers (modal stays closed)\n- Manual: In modal, click Delete ‚Üí confirmation dialog ‚Üí branch deleted\n- Manual: In modal, click Switch ‚Üí switch flow triggers\n- Manual: Current branch ‚Üí no Switch button in list, no Switch/Delete in modal\n\n---\n\n## Implementation Steps\n\n1. **Add imports and state:**\n```typescript\nimport BranchDetailModal from './BranchDetailModal.vue'\nimport type { BranchInfo } from '@/types/comfygit'\n\nconst selectedBranch = ref\u003cBranchInfo | null\u003e(null)\n\nfunction openBranchDetail(branch: BranchInfo) {\n  selectedBranch.value = branch\n}\n\nfunction handleDeleteFromModal(branchName: string) {\n  selectedBranch.value = null\n  emit('delete', branchName)\n}\n\nfunction handleSwitchFromModal(branchName: string) {\n  selectedBranch.value = null\n  emit('switch', branchName)\n}\n```\n\n2. **Update template** - See target state above\n\n3. **Rebuild frontend:**\n```bash\ncd frontend \u0026\u0026 npm run build\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T20:32:45.666892684-05:00","created_by":"ubuntu","updated_at":"2026-01-28T21:07:54.407182814-05:00","closed_at":"2026-01-28T21:07:54.407182814-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-8a9","depends_on_id":"cgm-w6s","type":"blocks","created_at":"2026-01-28T20:33:12.006710817-05:00","created_by":"ubuntu"}]}
{"id":"cgm-8bc","title":"Wire HuggingFace detection into ModelIndexSection download modal","notes":"## Context \u0026 Goal\n\nModify the existing download modal in ModelIndexSection.vue to:\n1. Detect when user pastes a HuggingFace repo URL\n2. Show \"Browse Repo Files\" button instead of target path input\n3. Open HuggingFaceRepoModal when clicked\n4. Add target path validation to prevent \"Is a directory\" errors\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/ModelIndexSection.vue`):\n- Simple download modal with URL + target path inputs (lines 176-216)\n- State variables at lines 269-271: showDownloadModal, downloadUrl, downloadTargetPath\n- No HF URL detection\n- No target path validation\n\n**Target** - Modify existing component:\n\n**1. Add imports (script section, around line 237-238):**\n```typescript\nimport HuggingFaceRepoModal from '@/components/HuggingFaceRepoModal.vue'\nimport { parseHuggingFaceUrl } from '@/utils/huggingface'\n```\n\n**2. Add state (after line 271):**\n```typescript\nconst showHfRepoModal = ref(false)\nconst hfRepoUrl = ref('')\n```\n\n**3. Add computed for HF detection + path validation (after line 271):**\n```typescript\nconst hfParsed = computed(() =\u003e parseHuggingFaceUrl(downloadUrl.value))\nconst isHfRepoUrl = computed(() =\u003e hfParsed.value.kind === 'repo' \u0026\u0026 !!hfParsed.value.repoId)\n\nconst targetPathError = computed(() =\u003e {\n  const p = downloadTargetPath.value.trim()\n  if (!p) return null\n  const last = p.replace(/\\\\\\\\/g, '/').split('/').pop() || ''\n  const hasExt = last.includes('.') \u0026\u0026 !last.endsWith('.')\n  if (!hasExt) {\n    return 'Target path must include a filename (e.g. checkpoints/model.safetensors).'\n  }\n  return null\n})\n```\n\n**4. Add methods (after handleDownloadModel around line 391):**\n```typescript\nfunction openHfRepoModal() {\n  hfRepoUrl.value = downloadUrl.value.trim()\n  showHfRepoModal.value = true\n  showDownloadModal.value = false\n}\n\nfunction handleQueueHfRepo(items: Array\u003c{ workflow: string; filename: string; url: string; targetPath: string; size?: number; type?: string }\u003e) {\n  addToQueue(items)\n  showHfRepoModal.value = false\n  hfRepoUrl.value = ''\n  downloadUrl.value = ''\n  downloadTargetPath.value = ''\n}\n```\n\n**5. Update handleDownloadModel to check for repo URLs (modify existing function at line 374):**\n```typescript\nfunction handleDownloadModel() {\n  if (!downloadUrl.value.trim() || !downloadTargetPath.value.trim()) return\n  \n  const parsed = parseHuggingFaceUrl(downloadUrl.value.trim())\n  if (parsed.kind === 'repo') {\n    openHfRepoModal()\n    return\n  }\n  // ... rest unchanged\n}\n```\n\n**6. Update template - download modal body (replace lines 183-200):**\n```vue\n\u003cdiv class=\"modal-body\"\u003e\n  \u003cdiv class=\"input-group\"\u003e\n    \u003clabel\u003eDownload URL\u003c/label\u003e\n    \u003cBaseInput v-model=\"downloadUrl\" placeholder=\"https://huggingface.co/user/repo or https://.../resolve/...\" /\u003e\n  \u003c/div\u003e\n\n  \u003ctemplate v-if=\"isHfRepoUrl\"\u003e\n    \u003cp class=\"modal-note\"\u003e\n      HuggingFace repository detected. Click \u003cstrong\u003eBrowse Repo Files\u003c/strong\u003e to pick files.\n    \u003c/p\u003e\n  \u003c/template\u003e\n\n  \u003ctemplate v-else\u003e\n    \u003cdiv class=\"input-group\"\u003e\n      \u003clabel\u003eTarget Path (relative to models directory)\u003c/label\u003e\n      \u003cBaseInput v-model=\"downloadTargetPath\" placeholder=\"e.g. checkpoints/model.safetensors\" /\u003e\n      \u003cp v-if=\"targetPathError\" class=\"modal-error\"\u003e{{ targetPathError }}\u003c/p\u003e\n    \u003c/div\u003e\n    \u003cp class=\"modal-note\"\u003eModel will be queued for background download.\u003c/p\u003e\n  \u003c/template\u003e\n\u003c/div\u003e\n```\n\n**7. Update template - download modal footer (replace lines 202-212):**\n```vue\n\u003cdiv class=\"modal-footer\"\u003e\n  \u003cBaseButton variant=\"secondary\" @click=\"showDownloadModal = false\"\u003eCancel\u003c/BaseButton\u003e\n  \u003cBaseButton v-if=\"isHfRepoUrl\" variant=\"primary\" :disabled=\"!downloadUrl.trim()\" @click=\"openHfRepoModal\"\u003e\n    Browse Repo Files\n  \u003c/BaseButton\u003e\n  \u003cBaseButton v-else variant=\"primary\" :disabled=\"!downloadUrl.trim() || !downloadTargetPath.trim() || !!targetPathError\" @click=\"handleDownloadModel\"\u003e\n    Queue Download\n  \u003c/BaseButton\u003e\n\u003c/div\u003e\n```\n\n**8. Add HF modal near other modals (after line 216, before \u003c/template\u003e):**\n```vue\n\u003cHuggingFaceRepoModal\n  :show=\"showHfRepoModal\"\n  :url=\"hfRepoUrl\"\n  @close=\"showHfRepoModal = false\"\n  @queue=\"handleQueueHfRepo\"\n/\u003e\n```\n\n**9. Add CSS for error state (in \u003cstyle scoped\u003e section):**\n```css\n.modal-error {\n  font-size: 12px;\n  color: var(--cg-color-error);\n  margin-top: 4px;\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/components/ModelIndexSection.vue (~80 lines changed)\n\n**Files READ:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/utils/huggingface.ts (import)\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/components/HuggingFaceRepoModal.vue (import)\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend beads (different codebase)\n- Core library beads (different codebase)\n\n**Cannot Run In Parallel With:**\n- Must wait for: HuggingFaceRepoModal.vue, utils/huggingface.ts, types to exist\n\n**Blocking Reason:** This is the final integration point\n\n## Estimated Scope\n- **Size:** Medium (~80 lines changed)\n- **Risk:** Medium (modifies existing UI flow)\n\n## Acceptance Criteria\n- [ ] Pasting HF repo URL shows \"Browse Repo Files\" button\n- [ ] Pasting direct URL shows target path input\n- [ ] Target path without filename shows error\n- [ ] \"Browse Repo Files\" opens HuggingFaceRepoModal\n- [ ] Downloads queued from modal appear in download queue\n- [ ] Direct download (non-repo URL) still works\n\n## Testing Requirements\n- Test with HF repo URL: `https://huggingface.co/microsoft/VibeVoice-1.5B`\n- Test with direct URL: `https://huggingface.co/owner/repo/resolve/main/model.safetensors`\n- Test with non-HF URL: `https://civitai.com/...`\n- Test target path validation with directory-like paths","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:51:18.364387817-05:00","created_by":"ubuntu","updated_at":"2026-01-27T22:24:11.18271419-05:00","closed_at":"2026-01-27T22:24:11.18271419-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-8bc","depends_on_id":"cgm-ft3","type":"blocks","created_at":"2026-01-27T03:52:17.942434882-05:00","created_by":"ubuntu"},{"issue_id":"cgm-8bc","depends_on_id":"cgm-v93","type":"blocks","created_at":"2026-01-27T03:52:17.966000996-05:00","created_by":"ubuntu"}]}
{"id":"cgm-8y2","title":"Add E2E test for download-intent-only workflow resolution flow","notes":"# Context \u0026 Goal\n\n## Problem\nWe need automated test coverage for the new UX flow where workflows with only download intents skip the Models step and show accurate counts in Review.\n\n## Why It Matters\nRegression protection for the UX improvements. Without tests, future changes could break the streamlined flow.\n\n## How It Serves Project Goals\nTest coverage for critical user workflow.\n\n---\n\n# Current State vs Target State\n\n## Current State\nNo E2E test specifically for download-intent-only resolution flow.\n\n## Target State\nE2E test that:\n1. Opens a workflow with models that have property_download_intent\n2. Verifies Analysis shows correct pending download count\n3. Verifies clicking Continue skips Models step\n4. Verifies Review shows correct \"X to download\" count\n5. Verifies \"Models to Download\" section shows correct details\n\n---\n\n# Files Inventory\n\n**Files MODIFIED (write):**\n- None\n\n**Files READ (reference only):**\n- `e2e/tests/` - existing E2E test patterns\n- `testing/` - existing test helpers\n\n**Files CREATED:**\n- `e2e/tests/workflow-resolution-download-intents.spec.ts` - new E2E test file\n\n---\n\n# Parallelization Info\n\n**Can Run In Parallel With:**\n- All other beads (test file is independent)\n\n**Cannot Run In Parallel With:**\n- None\n\n**Blocking Reason:**\n- Should run AFTER all UX changes are complete to test final behavior\n\n---\n\n# Estimated Scope\n\n- **Size:** Medium (50-100 lines)\n- **Risk:** Low (additive test)\n\n---\n\n# Acceptance Criteria\n\n- [ ] E2E test exists and passes\n- [ ] Test covers Analysis ‚Üí Review skip\n- [ ] Test verifies download count accuracy\n- [ ] Test verifies download details section\n\n---\n\n# Testing Requirements\n\nThis IS the test. Run with:\n```bash\ncd e2e \u0026\u0026 npx playwright test workflow-resolution-download-intents.spec.ts\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-22T14:29:42.547696955-05:00","created_by":"ubuntu","updated_at":"2026-01-22T15:16:12.857276564-05:00","closed_at":"2026-01-22T15:16:12.857276564-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-8y2","depends_on_id":"cgm-447","type":"blocks","created_at":"2026-01-22T14:29:48.35113152-05:00","created_by":"ubuntu"},{"issue_id":"cgm-8y2","depends_on_id":"cgm-yah","type":"blocks","created_at":"2026-01-22T14:29:48.364508207-05:00","created_by":"ubuntu"},{"issue_id":"cgm-8y2","depends_on_id":"cgm-n2o","type":"blocks","created_at":"2026-01-22T14:29:48.378226713-05:00","created_by":"ubuntu"},{"issue_id":"cgm-8y2","depends_on_id":"cgm-xii","type":"blocks","created_at":"2026-01-22T14:29:48.392679516-05:00","created_by":"ubuntu"},{"issue_id":"cgm-8y2","depends_on_id":"cgm-1cj","type":"parent-child","created_at":"2026-01-22T14:30:08.841360198-05:00","created_by":"ubuntu"}]}
{"id":"cgm-94k","title":"Backend API: Manual model add/remove endpoints + env models response flag","notes":"## Context \u0026 Goal\n\nThe manager backend needs API endpoints for the frontend to add/remove manual models from workflows, and the existing environment models endpoint needs to indicate which models were manually added (so the UI can show a badge and allow removal).\n\n## Current State vs Target State\n\n**Current** (server/api/v2/models.py):\n- GET /v2/comfygit/models/environment (line 36-98) returns models aggregated from workflow analysis, no concept of manual vs auto-discovered\n- No endpoints for adding/removing models from workflow manifests\n\n**Target**: Add two new endpoints and modify the existing one.\n\n### New Endpoint: POST /v2/comfygit/models/environment/manual\n\n\\`\\`\\`python\n@routes.post(\"/v2/comfygit/models/environment/manual\")\n@logged_operation(\"add manual model\")\nasync def add_manual_model(request: web.Request, env) -\u003e web.Response:\n    \"\"\"Add a workspace model to a workflow manifest manually.\"\"\"\n    body = await request.json()\n    workflow = body.get(\"workflow\")      # required: workflow name\n    model_hash = body.get(\"model_hash\")  # required: CRC32 hash from workspace index\n    criticality = body.get(\"criticality\", \"required\")  # optional: required/flexible/optional\n    \n    # Validate inputs\n    if not workflow or not model_hash:\n        return web.json_response({\"error\": \"Missing required fields: workflow, model_hash\"}, status=400)\n    if criticality not in (\"required\", \"flexible\", \"optional\"):\n        return web.json_response({\"error\": \"Invalid criticality. Must be: required, flexible, optional\"}, status=400)\n    \n    try:\n        result = await run_sync(\n            env.model_manager.add_manual_model,\n            workflow_name=workflow,\n            model_hash=model_hash,\n            criticality=criticality,\n        )\n        return web.json_response({\n            \"status\": \"success\",\n            \"filename\": result.filename,\n            \"category\": result.category,\n            \"criticality\": result.criticality,\n        })\n    except ValueError as e:\n        return web.json_response({\"error\": str(e)}, status=400)\n    except Exception as e:\n        return web.json_response({\"error\": str(e)}, status=500)\n\\`\\`\\`\n\n### New Endpoint: DELETE /v2/comfygit/models/environment/manual\n\n\\`\\`\\`python\n@routes.delete(\"/v2/comfygit/models/environment/manual\")\n@logged_operation(\"remove manual model\")\nasync def remove_manual_model(request: web.Request, env) -\u003e web.Response:\n    \"\"\"Remove a manually-added model from a workflow manifest.\"\"\"\n    body = await request.json()\n    workflow = body.get(\"workflow\")\n    model_hash = body.get(\"model_hash\")\n    \n    if not workflow or not model_hash:\n        return web.json_response({\"error\": \"Missing required fields: workflow, model_hash\"}, status=400)\n    \n    try:\n        removed = await run_sync(\n            env.model_manager.remove_manual_model,\n            workflow_name=workflow,\n            model_hash=model_hash,\n        )\n        if not removed:\n            return web.json_response({\"error\": \"Model not found or is auto-discovered (has node references)\"}, status=404)\n        return web.json_response({\"status\": \"success\"})\n    except ValueError as e:\n        return web.json_response({\"error\": str(e)}, status=400)\n    except Exception as e:\n        return web.json_response({\"error\": str(e)}, status=500)\n\\`\\`\\`\n\n### Modified: GET /v2/comfygit/models/environment\n\nAdd \"is_manual\" flag to each model in the response. This requires reading the pyproject manifest directly to check if model entries have empty nodes[].\n\nIn the existing endpoint (line 36-98), after aggregating models from workflow analysis, also read manual models from pyproject:\n\n\\`\\`\\`python\n# After line 74 (existing models_map population), add:\n# Check for manual models (nodes=[]) in pyproject manifest\nfor wf_name in (wf.name for wf in status.workflow.analyzed_workflows):\n    wf_models = await run_sync(env.pyproject.workflows.get_workflow_models, wf_name)\n    for wf_model in wf_models:\n        if wf_model.hash and len(wf_model.nodes) == 0:\n            # Manual model entry\n            if wf_model.hash in models_map:\n                models_map[wf_model.hash][\"is_manual\"] = True\n            else:\n                # Model is manual-only (not auto-discovered)\n                models_map[wf_model.hash] = {\n                    \"filename\": wf_model.filename,\n                    \"hash\": wf_model.hash,\n                    \"type\": wf_model.category,\n                    \"size\": 0,  # Will be enriched from workspace index if available\n                    \"status\": \"available\",\n                    \"relative_path\": wf_model.relative_path,\n                    \"used_in_workflows\": [wf_name],\n                    \"is_manual\": True,\n                }\n\n# For non-manual models, ensure is_manual=False\nfor model_data in models_map.values():\n    if \"is_manual\" not in model_data:\n        model_data[\"is_manual\"] = False\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- /data/projects/comfygit-ai/comfygit-manager/server/api/v2/models.py (after line 98) - Add POST and DELETE endpoints for manual models\n- /data/projects/comfygit-ai/comfygit-manager/server/api/v2/models.py (lines 36-98) - Modify GET endpoint to include is_manual flag\n\n**Files READ (reference only):**\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/environment_model_manager.py - add_manual_model() and remove_manual_model()\n- /data/projects/comfygit-ai/comfygit-manager/server/cgm_core/decorators.py - requires_environment, logged_operation decorators\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Frontend types/service bead (different files, can code against planned API shape)\n\n**Cannot Run In Parallel With:**\n- Core bead (cgm-er5) - must complete first, backend calls core methods\n- Frontend UI bead - needs API to be testable\n\n**Blocking Reason:** Frontend needs API endpoints to function\n\n## Estimated Scope\n- **Size:** Medium (~80 lines new endpoints + ~20 lines modifying existing endpoint)\n- **Risk:** Medium (modifies existing GET endpoint response shape, but additively)\n\n## Acceptance Criteria\n- [ ] POST /v2/comfygit/models/environment/manual adds model to workflow manifest via core method\n- [ ] POST validates workflow, model_hash, criticality fields\n- [ ] DELETE /v2/comfygit/models/environment/manual removes manual model only\n- [ ] DELETE returns 404 if model not found or has node references\n- [ ] GET /v2/comfygit/models/environment now includes is_manual boolean on each model\n- [ ] Manual-only models (not auto-discovered) appear in the GET response with is_manual=true\n- [ ] Existing auto-discovered models have is_manual=false\n\n## Testing Requirements\n- Add tests to testing/unit/ or testing/integration/panel/\n- Test: POST success - model appears in manifest\n- Test: POST with invalid criticality returns 400\n- Test: POST with unknown hash returns 400\n- Test: DELETE success - manual model removed\n- Test: DELETE non-manual model returns 404\n- Test: GET includes is_manual flag correctly","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-30T14:32:48.209691892-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:32:48.209691892-05:00","dependencies":[{"issue_id":"cgm-94k","depends_on_id":"cgm-er5","type":"blocks","created_at":"2026-01-30T14:33:57.641995489-05:00","created_by":"ubuntu"}]}
{"id":"cgm-97e","title":"Normalize match_confidence scores in search-nodes endpoint","notes":"## Context \u0026 Goal\n\n**Problem:** The `/v2/comfygit/workflow/search-nodes` endpoint returns `match_confidence` values that can exceed 1.0 (e.g., 128%), causing the frontend `ConfidenceBadge` component to display nonsensical percentages like \"128%\".\n\n**Why it matters:** Users see confusing match percentages in the resolution modal that undermine trust in the search results. Multiple items may appear with \u003e100% confidence, which is mathematically nonsensical.\n\n**Root cause:** The core library `GlobalNodeResolver._calculate_match_score()` intentionally returns unbounded scores (for internal ranking), but the server passes these raw scores directly as `match_confidence` to the frontend.\n\n## Current State vs Target State\n\n**Current code** (`server/api/v2/workflows.py` lines 889-897):\n```python\nresults = []\nfor match in matches:\n    results.append({\n        \"package_id\": match.package_id,\n        \"match_confidence\": match.score,  # RAW SCORE - can be \u003e1.0!\n        \"match_type\": match.confidence,\n        \"description\": match.package_data.description if match.package_data else None,\n        \"repository\": match.package_data.repository if match.package_data else None,\n        \"is_installed\": match.package_id in installed\n    })\n```\n\n**Target code:**\n```python\n# Normalize scores to 0.0-1.0 range for frontend display\n# Find max score for normalization (minimum 1.0 to avoid division issues)\nmax_score = max((m.score for m in matches), default=1.0)\nmax_score = max(max_score, 1.0)  # Ensure at least 1.0\n\nresults = []\nfor match in matches:\n    # Normalize: highest score becomes 1.0, others scale proportionally\n    normalized_confidence = match.score / max_score\n    results.append({\n        \"package_id\": match.package_id,\n        \"match_confidence\": normalized_confidence,\n        \"match_type\": match.confidence,\n        \"description\": match.package_data.description if match.package_data else None,\n        \"repository\": match.package_data.repository if match.package_data else None,\n        \"is_installed\": match.package_id in installed\n    })\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `server/api/v2/workflows.py` (lines 889-897) - Add score normalization in search_nodes endpoint\n\n**Files READ (reference only):**\n- `frontend/src/components/base/atoms/ConfidenceBadge.vue` - Understand expected input range (0.0-1.0)\n- `.venv/lib/python3.14/site-packages/comfygit_core/resolvers/global_node_resolver.py` - Understand score calculation\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All beads that dont touch `server/api/v2/workflows.py` search_nodes function\n- Frontend-only beads (NodeResolutionStep, ModelResolutionStep)\n\n**Cannot Run In Parallel With:**\n- Any other bead modifying `search_nodes()` function in workflows.py\n\n**Blocking Reason:** None - this is a leaf task\n\n## Estimated Scope\n- **Size:** Small (\u003c20 lines changed)\n- **Risk:** Low (isolated endpoint, no shared state affected)\n\n## Acceptance Criteria\n- [ ] Search results return `match_confidence` values between 0.0 and 1.0\n- [ ] Highest-scoring result has confidence close to 1.0 (normalized max)\n- [ ] Relative ordering of results is preserved\n- [ ] ConfidenceBadge displays percentages between 0% and 100%\n- [ ] No regression in search result quality/ordering\n\n## Testing Requirements\n\n**Manual Testing:**\n1. Open resolution modal for a workflow with missing nodes\n2. Observe that potential matches show percentages ‚â§100%\n3. Verify the highest match shows ~100% and lower matches scale proportionally\n\n**Existing tests to verify:**\n- `testing/integration/panel/test_workflows.py` - workflow endpoints\n\n**New tests needed:**\n- Add test case for search_nodes normalization (optional - manual verification sufficient for MVP)","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-23T18:12:00.669374138-05:00","created_by":"ubuntu","updated_at":"2026-01-23T21:34:38.38001745-05:00","closed_at":"2026-01-23T21:34:38.38001745-05:00","close_reason":"Completed via sprint run-1769220521034348168"}
{"id":"cgm-ah6","title":"Issue created from worktree","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-14T18:58:48.059637033-05:00","created_by":"ubuntu","updated_at":"2026-01-22T14:40:52.827142291-05:00","closed_at":"2026-01-22T14:40:52.827142291-05:00","close_reason":"Placeholder issue from initial worktree setup, not needed"}
{"id":"cgm-amo","title":"Create LocalUVConfigManager","description":"Create the manager class that reads/writes the .local-uv-config file and add gitignore entry","notes":"# Task: Create LocalUVConfigManager\n\n## 1. Context \u0026 Goal\nCreate a new manager class that handles the `.local-uv-config` file ‚Äî a gitignored TOML file\nin `.cec/` that stores machine-local UV configuration (sources, indexes). This follows the\nexact same pattern as `PyTorchBackendManager` which manages `.pytorch-backend`.\n\nThe file allows developers to have local editable installs (e.g., `comfygit-core` pointing to\na local checkout) without those paths leaking into git history and breaking collaborators.\n\n**IMPORTANT**: The `get_injection_config()` method MUST return data in the same dict format\nthat `PyTorchBackendManager.get_pytorch_config()` returns, so both can share the same\ninjection codepath. The format is:\n```python\n{\n    \"indexes\": [{\"name\": str, \"url\": str, \"explicit\": bool}],\n    \"sources\": {\"package_name\": {\"path\": \"/...\", \"editable\": True}},\n    \"constraints\": []  # Always empty for local UV config (reserved for future use)\n}\n```\n\n## 2. Current State vs Target State\n\n### Current State\nNo mechanism exists for machine-local UV source overrides. Developers who run\n`uv add --editable /path/to/package` have that local path written directly into\n`pyproject.toml`, which gets committed and pushed.\n\n### Target State\nNew file: `.cec/.local-uv-config` (gitignored)\n```toml\n# Machine-local UV overrides (not committed to git)\n# These are injected during sync alongside PyTorch config\n\n[sources]\ncomfygit-core = { path = \"/data/projects/comfygit-ai/comfygit/packages/core\", editable = true }\n\n[[index]]\nname = \"corporate-pypi\"\nurl = \"https://pypi.corp.internal/simple/\"\nexplicit = true\n```\n\nNew manager class at:\n`/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/local_uv_config_manager.py`\n\nUpdated gitignore template at:\n`/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/git_manager.py` (line 71)\n\n### Manager API:\n```python\nclass LocalUVConfigManager:\n    \"\"\"Manages .local-uv-config file for machine-local UV overrides.\n    \n    Similar to PyTorchBackendManager, this stores config that is gitignored\n    and injected at sync time. The file format is TOML with [sources] and\n    [[index]] sections that map 1:1 to [tool.uv] sub-keys.\n    \"\"\"\n\n    def __init__(self, cec_path: Path): ...\n    def exists(self) -\u003e bool: ...\n    def load(self) -\u003e dict: ...\n    def save(self, config: dict) -\u003e None: ...\n    def add_source(self, package_name: str, source_config: dict) -\u003e None: ...\n    def remove_source(self, package_name: str) -\u003e None: ...\n    def add_index(self, name: str, url: str, explicit: bool = True) -\u003e None: ...\n    def remove_index(self, name: str) -\u003e None: ...\n    def get_injection_config(self) -\u003e dict | None:\n        \"\"\"Returns dict with 'indexes', 'sources', and 'constraints' keys\n        matching the same format as PyTorchBackendManager.get_pytorch_config().\n        Returns None if no .local-uv-config file exists.\n        \n        This format compatibility enables the shared _inject_uv_overrides()\n        method to handle both PyTorch and local UV injection identically.\n        \"\"\"\n        ...\n    def ensure_gitignore_entry(self) -\u003e None: ...\n```\n\n## 3. Files Inventory\n\n**Files CREATED:**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/local_uv_config_manager.py` - New manager class\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/git_manager.py` (line 68-71) - Add `.local-uv-config` to gitignore template\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/pytorch_backend_manager.py` - Pattern reference (same architecture)\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/pyproject_manager.py` (line 549-647) - `_inject_pytorch_config()` for understanding the shared injection config format\n\n### Gitignore Change (git_manager.py line ~71):\n```python\n# BEFORE (line 70-72):\n# Lock file (machine-specific due to PyTorch platform variants)\nuv.lock\n\"\"\"\n\n# AFTER:\n# Lock file (machine-specific due to PyTorch platform variants)\nuv.lock\n\n# Local UV config (machine-specific sources, indexes)\n.local-uv-config\n\"\"\"\n```\n\n## 4. Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-51s (commit-time stripping) - no file overlap, different files entirely\n\n**Cannot Run In Parallel With:**\n- cgm-5kf (sync injection) - INJECT depends on this manager class existing\n\n**Blocking Reason:**\n- The injection task needs LocalUVConfigManager to exist and produce compatible dicts\n\n## 5. Estimated Scope\n- **Size:** Medium (~120 lines for manager + ~3 lines gitignore change)\n- **Risk:** Low (new file, minimal touch to existing code)\n\n## 6. Acceptance Criteria\n- [ ] `LocalUVConfigManager` class exists with all methods listed above\n- [ ] `.local-uv-config` added to gitignore template in `git_manager.py`\n- [ ] Manager can create, load, save `.local-uv-config` TOML file\n- [ ] `add_source()` and `remove_source()` correctly modify the [sources] section\n- [ ] `add_index()` and `remove_index()` correctly modify the [[index]] array\n- [ ] `get_injection_config()` returns dict with keys: indexes, sources, constraints\n- [ ] `get_injection_config()` format matches PyTorchBackendManager.get_pytorch_config() output structure\n- [ ] `get_injection_config()` returns None when no file exists\n- [ ] `ensure_gitignore_entry()` adds entry if missing (like PyTorchBackendManager._ensure_gitignore_entry pattern at line 155-178)\n- [ ] File format matches the TOML structure shown above\n\n## 7. Testing Requirements\n- Unit tests for LocalUVConfigManager: load/save/add/remove operations\n- Test `get_injection_config()` returns correct structure matching shared format\n- Test `get_injection_config()` returns None when no file\n- Test `ensure_gitignore_entry()` idempotency\n- Tests go in: `/data/projects/comfygit-ai/comfygit/packages/core/tests/unit/managers/`","status":"tombstone","priority":2,"issue_type":"task","created_at":"2026-01-30T16:45:32.209145852-05:00","created_by":"ubuntu","updated_at":"2026-01-30T17:02:36.898085309-05:00","deleted_at":"2026-01-30T17:02:36.898085309-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"cgm-asa","title":"Tests for local UV config override system","description":"Comprehensive tests covering LocalUVConfigManager, sync injection, commit stripping, and end-to-end round-trip","notes":"# Task: Tests for Local UV Config Override System\n\n## 1. Context \u0026 Goal\nWrite comprehensive tests for the full local UV config override feature. Tests should cover:\n- LocalUVConfigManager unit tests (file I/O, add/remove operations)\n- Shared injection method (`_inject_uv_overrides`) ‚Äî the DRY refactor\n- Sync injection integration (context manager with local UV + PyTorch)\n- Commit-time stripping (local path sources removed before commit)\n- End-to-end: add local source ‚Üí sync ‚Üí commit ‚Üí verify clean pyproject\n\n## 2. Current State vs Target State\n\n### Current State\nNo tests exist for local UV config. Related existing tests to reference:\n- `tests/unit/managers/test_pytorch_injection.py` ‚Äî PyTorch injection tests\n- `tests/unit/managers/test_pytorch_stripping.py` (565 lines) ‚Äî PyTorch stripping tests\n- `tests/integration/test_export_import.py` ‚Äî Import flow (calls _strip_local_path_sources)\n\n### Target State\nNew test file(s) following the existing patterns from the test infrastructure.\n\n### Test Infrastructure (Verified):\n- **Fixtures:** `test_workspace` (workspace), `test_env` (minimal env with .cec, pyproject, git)\n- **Helpers:** `WorkflowBuilder`, `ModelIndexBuilder`, `PyprojectAssertions`\n- **Conftest fixtures:** `simulate_comfyui_save_workflow`, `load_workflow_fixture`\n- **Location:** Tests go in `tests/unit/managers/` for manager unit tests, `tests/integration/` for integration\n- **Pattern:** Use `TemporaryDirectory` or `tmp_path` fixtures, function-scoped for isolation\n- **Run:** `uv run pytest tests/ -v` from core package root\n\n### Test File Structure:\n\n```python\n# tests/unit/managers/test_local_uv_config_manager.py\n\nimport pytest\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nfrom comfygit_core.managers.local_uv_config_manager import LocalUVConfigManager\n\n\nclass TestLocalUVConfigManager:\n    \"\"\"Unit tests for LocalUVConfigManager.\"\"\"\n\n    def test_exists_false_when_no_file(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        assert not manager.exists()\n\n    def test_exists_true_after_save(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_source(\"pkg\", {\"path\": \"/foo\", \"editable\": True})\n        assert manager.exists()\n\n    def test_load_empty_returns_empty(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        assert manager.load() == {} or manager.load() is not None  # Depends on impl\n\n    def test_add_source_editable(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_source(\"my-pkg\", {\"path\": \"/home/dev/my-pkg\", \"editable\": True})\n        config = manager.load()\n        assert \"my-pkg\" in config.get(\"sources\", {})\n        assert config[\"sources\"][\"my-pkg\"][\"path\"] == \"/home/dev/my-pkg\"\n        assert config[\"sources\"][\"my-pkg\"][\"editable\"] is True\n\n    def test_add_source_index_ref(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_source(\"internal-pkg\", {\"index\": \"corp-pypi\"})\n        config = manager.load()\n        assert config[\"sources\"][\"internal-pkg\"][\"index\"] == \"corp-pypi\"\n\n    def test_remove_source(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_source(\"pkg\", {\"path\": \"/foo\", \"editable\": True})\n        manager.remove_source(\"pkg\")\n        config = manager.load()\n        assert \"pkg\" not in config.get(\"sources\", {})\n\n    def test_remove_nonexistent_source_no_error(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.remove_source(\"nonexistent\")  # Should not raise\n\n    def test_add_index(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_index(\"corp-pypi\", \"https://pypi.corp.internal/simple/\", explicit=True)\n        config = manager.load()\n        indexes = config.get(\"index\", [])\n        assert any(idx[\"name\"] == \"corp-pypi\" for idx in indexes)\n\n    def test_remove_index(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_index(\"corp-pypi\", \"https://pypi.corp.internal/simple/\")\n        manager.remove_index(\"corp-pypi\")\n        config = manager.load()\n        indexes = config.get(\"index\", [])\n        assert not any(idx.get(\"name\") == \"corp-pypi\" for idx in indexes)\n\n    def test_get_injection_config_none_when_no_file(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        assert manager.get_injection_config() is None\n\n    def test_get_injection_config_has_correct_format(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_source(\"pkg\", {\"path\": \"/foo\", \"editable\": True})\n        result = manager.get_injection_config()\n        assert \"indexes\" in result\n        assert \"sources\" in result\n        assert \"constraints\" in result\n        assert isinstance(result[\"indexes\"], list)\n        assert isinstance(result[\"sources\"], dict)\n        assert isinstance(result[\"constraints\"], list)\n\n    def test_get_injection_config_sources_only(self, tmp_path):\n        manager = LocalUVConfigManager(tmp_path)\n        manager.add_source(\"pkg\", {\"path\": \"/foo\", \"editable\": True})\n        result = manager.get_injection_config()\n        assert result[\"sources\"][\"pkg\"][\"path\"] == \"/foo\"\n        assert result[\"indexes\"] == []\n        assert result[\"constraints\"] == []\n\n    def test_ensure_gitignore_entry_adds_when_missing(self, tmp_path):\n        gitignore = tmp_path / \".gitignore\"\n        gitignore.write_text(\"*.pyc\\n\")\n        manager = LocalUVConfigManager(tmp_path)\n        manager.ensure_gitignore_entry()\n        content = gitignore.read_text()\n        assert \".local-uv-config\" in content\n\n    def test_ensure_gitignore_entry_idempotent(self, tmp_path):\n        gitignore = tmp_path / \".gitignore\"\n        gitignore.write_text(\".local-uv-config\\n\")\n        manager = LocalUVConfigManager(tmp_path)\n        manager.ensure_gitignore_entry()\n        content = gitignore.read_text()\n        assert content.count(\".local-uv-config\") == 1\n```\n\n```python\n# tests/unit/managers/test_uv_injection_shared.py\n\nimport pytest\nimport tomlkit\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nfrom comfygit_core.managers.pyproject_manager import PyprojectManager\n\n\nclass TestInjectUVOverrides:\n    \"\"\"Tests for the shared _inject_uv_overrides() method.\"\"\"\n\n    def _make_pyproject(self, tmp_path, config=None):\n        \"\"\"Helper to create a PyprojectManager with optional initial config.\"\"\"\n        path = tmp_path / \"pyproject.toml\"\n        if config:\n            path.write_text(tomlkit.dumps(config))\n        else:\n            path.write_text('[project]\\nname = \"test\"\\n')\n        return PyprojectManager(path)\n\n    def test_inject_indexes(self, tmp_path):\n        pm = self._make_pyproject(tmp_path)\n        config = pm.load()\n        pm._inject_uv_overrides(config, {\n            \"indexes\": [{\"name\": \"test-idx\", \"url\": \"https://example.com/simple/\", \"explicit\": True}],\n            \"sources\": {},\n            \"constraints\": [],\n        })\n        pm.save(config)\n        result = pm.load()\n        indexes = result[\"tool\"][\"uv\"][\"index\"]\n        assert any(idx[\"name\"] == \"test-idx\" for idx in indexes)\n\n    def test_inject_sources(self, tmp_path):\n        pm = self._make_pyproject(tmp_path)\n        config = pm.load()\n        pm._inject_uv_overrides(config, {\n            \"indexes\": [],\n            \"sources\": {\"my-pkg\": {\"path\": \"/foo\", \"editable\": True}},\n            \"constraints\": [],\n        })\n        pm.save(config)\n        result = pm.load()\n        assert result[\"tool\"][\"uv\"][\"sources\"][\"my-pkg\"][\"path\"] == \"/foo\"\n\n    def test_inject_constraints(self, tmp_path):\n        pm = self._make_pyproject(tmp_path)\n        config = pm.load()\n        pm._inject_uv_overrides(config, {\n            \"indexes\": [],\n            \"sources\": {},\n            \"constraints\": [\"numpy\u003c2.4\"],\n        })\n        pm.save(config)\n        result = pm.load()\n        assert \"numpy\u003c2.4\" in result[\"tool\"][\"uv\"][\"constraint-dependencies\"]\n\n    def test_inject_does_not_duplicate_indexes(self, tmp_path):\n        initial = {\"tool\": {\"uv\": {\"index\": [{\"name\": \"existing\", \"url\": \"https://a.com\", \"explicit\": True}]}}}\n        pm = self._make_pyproject(tmp_path, tomlkit.dumps(initial))  # Hmm, need proper setup\n        # ... test dedup logic\n\n    def test_inject_source_overwrites_existing(self, tmp_path):\n        # Existing source for pkg ‚Üí injection should overwrite\n        ...\n\n    def test_pytorch_injection_still_uses_shared_method(self, tmp_path):\n        \"\"\"Verify _inject_pytorch_config delegates to _inject_uv_overrides.\"\"\"\n        # This ensures the DRY refactor didn't break PyTorch\n        ...\n```\n\n```python\n# tests/unit/core/test_commit_stripping.py (or add to existing commit tests)\n\nclass TestCommitStripping:\n    \"\"\"Tests for local path source stripping during commit.\"\"\"\n\n    def test_strip_removes_local_path_source(self, test_env):\n        config = test_env.pyproject.load()\n        config.setdefault(\"tool\", {}).setdefault(\"uv\", {}).setdefault(\"sources\", {})\n        config[\"tool\"][\"uv\"][\"sources\"][\"my-pkg\"] = {\"path\": \"/home/dev/my-pkg\", \"editable\": True}\n        test_env.pyproject.save(config)\n\n        stripped = test_env._strip_local_path_sources(config=config)\n        assert \"my-pkg\" in stripped\n        assert \"my-pkg\" not in config.get(\"tool\", {}).get(\"uv\", {}).get(\"sources\", {})\n\n    def test_strip_preserves_index_ref_source(self, test_env):\n        config = test_env.pyproject.load()\n        config.setdefault(\"tool\", {}).setdefault(\"uv\", {}).setdefault(\"sources\", {})\n        config[\"tool\"][\"uv\"][\"sources\"][\"torch\"] = {\"index\": \"pytorch-cu128\"}\n        test_env.pyproject.save(config)\n\n        stripped = test_env._strip_local_path_sources(config=config)\n        assert stripped == []\n        assert \"torch\" in config[\"tool\"][\"uv\"][\"sources\"]\n\n    def test_strip_preserves_http_url_source(self, test_env):\n        config = test_env.pyproject.load()\n        config.setdefault(\"tool\", {}).setdefault(\"uv\", {}).setdefault(\"sources\", {})\n        config[\"tool\"][\"uv\"][\"sources\"][\"pkg\"] = {\"url\": \"https://example.com/pkg.tar.gz\"}\n        test_env.pyproject.save(config)\n\n        stripped = test_env._strip_local_path_sources(config=config)\n        assert stripped == []\n\n    def test_strip_standalone_mode_loads_and_saves(self, test_env):\n        # Write a local source to disk\n        config = test_env.pyproject.load()\n        config.setdefault(\"tool\", {}).setdefault(\"uv\", {}).setdefault(\"sources\", {})\n        config[\"tool\"][\"uv\"][\"sources\"][\"my-pkg\"] = {\"path\": \"/tmp/pkg\", \"editable\": True}\n        test_env.pyproject.save(config)\n\n        # Call without config arg (standalone mode)\n        stripped = test_env._strip_local_path_sources()\n        assert \"my-pkg\" in stripped\n\n        # Verify saved to disk\n        reloaded = test_env.pyproject.load()\n        assert \"my-pkg\" not in reloaded.get(\"tool\", {}).get(\"uv\", {}).get(\"sources\", {})\n\n    def test_strip_returns_empty_when_no_sources(self, test_env):\n        config = test_env.pyproject.load()\n        stripped = test_env._strip_local_path_sources(config=config)\n        assert stripped == []\n\n    def test_finalize_import_still_calls_strip(self, test_env):\n        \"\"\"Verify backward compat: finalize_import still works with no-arg call.\"\"\"\n        # This is a regression test\n        ...\n```\n\n## 3. Files Inventory\n\n**Files CREATED:**\n- `/data/projects/comfygit-ai/comfygit/packages/core/tests/unit/managers/test_local_uv_config_manager.py`\n- `/data/projects/comfygit-ai/comfygit/packages/core/tests/unit/managers/test_uv_injection_shared.py`\n- Tests for commit stripping may go in existing test files or new file in `tests/unit/core/`\n\n**Files READ (reference only):**\n- All implementation files from cgm-amo, cgm-51s, cgm-5kf\n- `tests/conftest.py` ‚Äî for fixture patterns\n- `tests/unit/managers/test_pytorch_injection.py` ‚Äî pattern reference\n- `tests/unit/managers/test_pytorch_stripping.py` ‚Äî pattern reference\n\n## 4. Parallelization Info\n\n**Depends On:**\n- cgm-amo (LocalUVConfigManager must exist)\n- cgm-51s (commit stripping must exist)\n- cgm-5kf (injection refactor must exist)\n\n**Can Run In Parallel With:** Nothing ‚Äî this is the final phase\n\n## 5. Estimated Scope\n- **Size:** Large (~250-300 lines of tests across 2-3 files)\n- **Risk:** Low (tests only, no production code changes)\n\n## 6. Acceptance Criteria\n- [ ] All unit tests pass for LocalUVConfigManager\n- [ ] Shared `_inject_uv_overrides()` tested independently\n- [ ] Injection context tested with local UV only, PyTorch only, and both together\n- [ ] Stripping tests verify local paths removed, non-paths preserved\n- [ ] Backward compat: standalone strip mode and `pytorch_injection_context()` alias\n- [ ] No regressions in existing test suite (especially pytorch tests)\n- [ ] `uv run pytest tests/ -v` passes from core package root\n\n## 7. Testing Requirements\n- Run: `cd /data/projects/comfygit-ai/comfygit/packages/core \u0026\u0026 uv run pytest tests/ -v`\n- Verify existing pytorch tests still pass after DRY refactor\n- Follow patterns in `tests/unit/managers/test_pytorch_stripping.py` for fixture setup","status":"tombstone","priority":2,"issue_type":"task","created_at":"2026-01-30T16:47:20.360449361-05:00","created_by":"ubuntu","updated_at":"2026-01-30T17:02:36.898085309-05:00","deleted_at":"2026-01-30T17:02:36.898085309-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"cgm-at2","title":"Add auto-advance after node resolution selection","notes":"## Context \u0026 Goal\n\n**Problem:** After selecting a package option for a missing node in the resolution modal, the user must manually click the right arrow to advance to the next unresolved node. This creates unnecessary friction.\n\n**Why it matters:** The resolution workflow should be smooth and efficient. Auto-advancing after a selection saves clicks and makes the process feel more guided.\n\n**Design decision:** Keep arrow buttons visible so users can manually navigate back to change previous selections. Auto-advance is a convenience, not a replacement for manual navigation.\n\n## Current State vs Target State\n\n**Current code** (`frontend/src/components/base/organisms/NodeResolutionStep.vue` lines 349-363):\n```typescript\n// Handlers - no auto-advance, user navigates manually\nfunction handleMarkOptional() {\n  if (!currentNode.value) return\n  emit('mark-optional', currentNode.value.node_type)\n}\n\nfunction handleSkip() {\n  if (!currentNode.value) return\n  emit('skip', currentNode.value.node_type)\n}\n\nfunction handleOptionSelected(index: number) {\n  if (!currentNode.value) return\n  emit('option-selected', currentNode.value.node_type, index)\n}\n```\n\n**Target code:**\n```typescript\n// Auto-advance helper: find next unresolved item and navigate to it\nfunction advanceToNextUnresolved() {\n  // Find next item after current that doesnt have a choice\n  for (let i = currentIndex.value + 1; i \u003c props.nodes.length; i++) {\n    const node = props.nodes[i]\n    if (!props.nodeChoices?.has(node.node_type)) {\n      goToItem(i)\n      return\n    }\n  }\n  // No more unresolved items - stay on current (user can see completion status)\n}\n\nfunction handleMarkOptional() {\n  if (!currentNode.value) return\n  emit('mark-optional', currentNode.value.node_type)\n  // Auto-advance after making a choice\n  nextTick(() =\u003e advanceToNextUnresolved())\n}\n\nfunction handleSkip() {\n  if (!currentNode.value) return\n  emit('skip', currentNode.value.node_type)\n  // Auto-advance after making a choice\n  nextTick(() =\u003e advanceToNextUnresolved())\n}\n\nfunction handleOptionSelected(index: number) {\n  if (!currentNode.value) return\n  emit('option-selected', currentNode.value.node_type, index)\n  // Auto-advance after making a choice\n  nextTick(() =\u003e advanceToNextUnresolved())\n}\n\n// Also handle search result selection\nfunction handleSearchResultSelected(result: NodeSearchResult) {\n  if (!currentNode.value) return\n  emit('manual-entry', currentNode.value.node_type, result.package_id)\n  // Auto-advance after selection\n  nextTick(() =\u003e advanceToNextUnresolved())\n}\n```\n\n**Note:** Need to import `nextTick` from vue if not already imported.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/base/organisms/NodeResolutionStep.vue` (lines 349-430) - Add auto-advance logic\n\n**Files READ (reference only):**\n- `frontend/src/components/base/molecules/NodeResolutionItem.vue` - Understand emitted events\n- `frontend/src/types/comfygit.ts` - NodeChoice type definition\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend-only beads (workflows.py changes)\n- ModelResolutionStep changes (separate file)\n- Any bead not touching NodeResolutionStep.vue\n\n**Cannot Run In Parallel With:**\n- Any other bead modifying NodeResolutionStep.vue\n\n**Blocking Reason:** None - this is a leaf task\n\n## Estimated Scope\n- **Size:** Small (~30 lines added)\n- **Risk:** Low (UI behavior change, easily reversible)\n\n## Acceptance Criteria\n- [ ] After selecting a package option, view auto-advances to next unresolved node\n- [ ] After marking a node as optional, view auto-advances to next unresolved node\n- [ ] After skipping a node, view auto-advances to next unresolved node\n- [ ] After selecting a search result, view auto-advances to next unresolved node\n- [ ] Arrow buttons remain visible and functional for manual back/forward navigation\n- [ ] If all nodes are resolved, view stays on current node (no error)\n- [ ] Counter still shows correct \"X/Y resolved\" status\n\n## Testing Requirements\n\n**Manual Testing:**\n1. Open resolution modal for a workflow with 2+ missing nodes\n2. Select a package for the first node\n3. Verify view auto-advances to second node\n4. Click back arrow to return to first node\n5. Verify you can change the selection\n6. Verify forward navigation still works manually\n\n**Existing tests:**\n- `frontend/src/components/__tests__/WorkflowResolveModal.test.ts`\n\n**New tests needed:**\n- Consider adding test for auto-advance behavior (optional for MVP)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-23T18:12:21.524769878-05:00","created_by":"ubuntu","updated_at":"2026-01-23T21:34:38.390435225-05:00","closed_at":"2026-01-23T21:34:38.390435225-05:00","close_reason":"Completed via sprint run-1769220521034348168"}
{"id":"cgm-bmt","title":"Route Missing Dependencies install through Manager queue API","notes":"## Context \u0026 Goal\n\n**Problem:** The Missing Dependencies popup installs nodes via direct API calls (`/v2/comfygit/nodes/{name}/install`) which fire in parallel, causing race conditions on pyproject.toml writes. Some nodes fail to be tracked, dependency groups are lost, and the UI falsely shows \"Installed\" for failed nodes.\n\n**Solution:** Route installations through the existing Manager queue system (`/v2/manager/queue/task`) which processes tasks sequentially - the same path that works correctly from the Manager UI.\n\n**Why it matters:** Users clicking \"Download All\" expect all nodes to install correctly. Currently 2-3 of 5 nodes may silently fail.\n\n---\n\n## Current State vs Target State\n\n### Current Code (BROKEN)\n\n**File:** `frontend/src/components/MissingResourcesPopup.vue` (lines 281-299, 314-320)\n\n```typescript\n// Individual install - calls direct API\nasync function installPackage(packageId: string) {\n  installingPackage.value = packageId\n  try {\n    await installNode(packageId)  // ‚Üê Direct API call\n    installedPackages.value.add(packageId)\n    installedCount.value++\n  } catch (e) {\n    console.error('[ComfyGit] Failed to install package:', e)\n  } finally {\n    installingPackage.value = null\n  }\n}\n\n// Install all - NO AWAIT = parallel fire-and-forget = race conditions\nfunction installAllNodes() {\n  for (const pkg of missingPackages.value) {\n    if (!installedPackages.value.has(pkg.package_id)) {\n      installPackage(pkg.package_id)  // ‚Üê NO await! All fire at once!\n    }\n  }\n}\n```\n\n**File:** `frontend/src/composables/useComfyGitService.ts` (lines 842-851)\n\n```typescript\nasync function installNode(nodeName: string): Promise\u003c{ status: 'success' | 'error', message?: string }\u003e {\n  return fetchApi(`/v2/comfygit/nodes/${encodeURIComponent(nodeName)}/install`, {\n    method: 'POST'\n  })  // ‚Üê Direct endpoint that races with other installs\n}\n```\n\n### Target Code (FIXED)\n\n**File:** `frontend/src/components/MissingResourcesPopup.vue`\n\n```typescript\n// NEW: Track queued packages (distinct from installing/installed)\nconst queuedPackages = ref\u003cSet\u003cstring\u003e\u003e(new Set())\n\n// NEW: Queue a single node install via Manager queue\nasync function queueInstallPackage(packageId: string) {\n  if (queuedPackages.value.has(packageId) || installedPackages.value.has(packageId)) return\n  \n  queuedPackages.value.add(packageId)\n  \n  try {\n    await queueNodeInstall({\n      id: packageId,\n      version: '',\n      selected_version: 'latest',\n      mode: 'remote',\n      channel: 'default'\n    })\n    // Don't mark as installed yet - wait for WebSocket event\n  } catch (e) {\n    queuedPackages.value.delete(packageId)\n    showToast({ type: 'error', message: `Failed to queue ${packageId}` })\n  }\n}\n\n// Install all - queue all tasks, queue processes them sequentially\nasync function installAllNodes() {\n  for (const pkg of missingPackages.value) {\n    if (!queuedPackages.value.has(pkg.package_id) \u0026\u0026 !installedPackages.value.has(pkg.package_id)) {\n      await queueInstallPackage(pkg.package_id)\n    }\n  }\n}\n\n// NEW: WebSocket handler for task completion\nfunction handleTaskCompleted(data: { ui_id: string, state: any }) {\n  // Find which package this task was for, update installedPackages or show error\n}\n```\n\n**File:** `frontend/src/composables/useComfyGitService.ts`\n\n```typescript\n// NEW: Queue node install via Manager queue API\nasync function queueNodeInstall(params: {\n  id: string\n  version: string\n  selected_version: string\n  mode: string\n  channel: string\n}): Promise\u003cvoid\u003e {\n  const task = {\n    kind: 'install',\n    params,\n    ui_id: crypto.randomUUID(),\n    client_id: 'comfygit-panel'  // or get from WebSocket\n  }\n  \n  // Queue the task\n  await fetchApi('/v2/manager/queue/task', {\n    method: 'POST',\n    body: JSON.stringify(task)\n  })\n  \n  // Start queue processing\n  await fetchApi('/v2/manager/queue/start')\n}\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/MissingResourcesPopup.vue` - Main changes: add queuedPackages state, refactor install functions to use queue, add WebSocket listener for completion events\n\n**Files MODIFIED (write):**\n- `frontend/src/composables/useComfyGitService.ts` - Add `queueNodeInstall()` function\n\n**Files READ (reference only):**\n- `legacy/ComfyUI_frontend/src/workbench/extensions/manager/services/comfyManagerService.ts` - Reference for queue API format\n- `legacy/ComfyUI_frontend/src/workbench/extensions/manager/types/generatedManagerTypes.ts` - Reference for InstallPackParams type\n- `server/comfygit_server.py` - Verify queue endpoint behavior\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:** None initially - this is the core change\n\n**Cannot Run In Parallel With:** bead for UI state changes (next bead) - same files\n\n**Blocking Reason:** This bead establishes the queue integration that the UI bead depends on\n\n---\n\n## Estimated Scope\n- **Size:** Medium (~100 lines changed)\n- **Risk:** Medium (changes core install flow, but backend already works)\n\n---\n\n## Acceptance Criteria\n- [ ] Clicking \"Install\" on a single node queues it via `/v2/manager/queue/task` instead of direct API\n- [ ] Clicking \"Install All\" queues all nodes, queue processes them one at a time\n- [ ] No race conditions on pyproject.toml - all nodes appear in manifest after install\n- [ ] All dependency groups are created for installed nodes\n- [ ] WebSocket events are received for task start/completion\n\n---\n\n## Testing Requirements\n- Manual test: Click \"Install All\" on 5 missing nodes, verify all 5 appear in manifest\n- Manual test: Check orchestrator logs show sequential processing (one node at a time)\n- Manual test: Nodes that require dependencies (like Depthflow) have their dependency groups written","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-24T03:05:07.589797131-05:00","created_by":"ubuntu","updated_at":"2026-01-24T03:10:43.945828858-05:00","closed_at":"2026-01-24T03:10:43.945828858-05:00","close_reason":"Implemented queue API integration for node installs. Changed from direct API calls to Manager queue API (/v2/manager/queue/task) which processes tasks sequentially, eliminating race conditions."}
{"id":"cgm-bz4","title":"Backend: Persist active model downloads to .cec/active-downloads.json","notes":"## Context \u0026 Goal\n\nWhen users download models directly (e.g., from HF browser) without going through workflow resolution, download intents only exist in the backend's in-memory \\`_active_downloads\\` dict and the frontend's Vue state. If the environment restarts (e.g., after a node install), these downloads are lost ‚Äî the user must re-enter all download info and restart them.\n\nThe existing \\`pending-downloads\\` system persists intents in pyproject.toml via \\`apply_resolution\\`, but that only covers workflow-bound downloads. Direct downloads (no workflow context) have no persistence.\n\n**Goal:** Write a lightweight \\`active-downloads.json\\` file in the environment's \\`.cec/\\` directory whenever a download is added to the queue, and remove entries when downloads complete. On reconnect, the \\`/pending-downloads\\` endpoint merges both pyproject intents and active-downloads.json, deduplicating by URL and reconciling against the model index.\n\n## Current State vs Target State\n\n### Current: Downloads are in-memory only (workflows.py:1460)\n\\`\\`\\`python\n_active_downloads: dict[str, dict] = {}  # url -\u003e {task, queues, result, cancelled, env, workflow, filename}\n\\`\\`\\`\nNo disk persistence for non-workflow downloads. Lost on restart.\n\n### Target: Add persistence helpers + integrate into download flow\n\n**New file: \\`server/cgm_utils/active_downloads.py\\`**\n\\`\\`\\`python\nimport json\nfrom pathlib import Path\n\ndef _get_active_downloads_path(env) -\u003e Path:\n    return env.paths.env_config / \"active-downloads.json\"\n\ndef load_active_downloads(env) -\u003e list[dict]:\n    path = _get_active_downloads_path(env)\n    if not path.exists():\n        return []\n    try:\n        data = json.loads(path.read_text())\n        return data.get(\"downloads\", [])\n    except (json.JSONDecodeError, KeyError):\n        return []\n\ndef save_active_download(env, url: str, filename: str, target_path: str, workflow: str = \"\"):\n    downloads = load_active_downloads(env)\n    # Deduplicate by URL\n    downloads = [d for d in downloads if d[\"url\"] != url]\n    downloads.append({\n        \"url\": url,\n        \"filename\": filename,\n        \"target_path\": target_path,\n        \"workflow\": workflow,\n        \"added_at\": int(time.time())\n    })\n    _write(env, downloads)\n\ndef remove_active_download(env, url: str):\n    downloads = load_active_downloads(env)\n    downloads = [d for d in downloads if d[\"url\"] != url]\n    _write(env, downloads)\n\ndef _write(env, downloads: list[dict]):\n    path = _get_active_downloads_path(env)\n    path.write_text(json.dumps({\"version\": 1, \"downloads\": downloads}, indent=2))\n\\`\\`\\`\n\n**Modify: \\`server/api/v2/workflows.py\\`**\n\n1. In \\`download_model_stream\\` (line ~1579), after adding to \\`_active_downloads\\`, call:\n\\`\\`\\`python\nsave_active_download(env, url, filename, target_path, workflow_name)\n\\`\\`\\`\n\n2. After download completes (line ~1669 cleanup block), call:\n\\`\\`\\`python\nremove_active_download(env, url)\n\\`\\`\\`\n\n3. Also remove on cancel (same block, cancelled branch).\n\n4. In \\`get_pending_downloads\\` (lines 1411-1452), merge active-downloads.json:\n\\`\\`\\`python\n# After collecting pyproject intents, also load active-downloads.json\nfrom cgm_utils.active_downloads import load_active_downloads\nactive = load_active_downloads(env)\nseen_urls = {p[\"url\"] for p in pending_downloads}\n\n# Reconcile: skip if model already exists in index\nfor dl in active:\n    if dl[\"url\"] in seen_urls:\n        continue\n    existing = env.workflow_manager.model_repository.find_by_source_url(dl[\"url\"])\n    if existing:\n        # Model already downloaded, clean up stale entry\n        remove_active_download(env, dl[\"url\"])\n        continue\n    pending_downloads.append({\n        \"workflow\": dl.get(\"workflow\", \"\"),\n        \"filename\": dl[\"filename\"],\n        \"url\": dl[\"url\"],\n        \"target_path\": dl[\"target_path\"],\n        \"size\": 0\n    })\n\\`\\`\\`\n\n## Files Inventory\n\n**Files CREATED:**\n- server/cgm_utils/active_downloads.py ‚Äî persistence helpers (load/save/remove)\n\n**Files MODIFIED (write):**\n- server/api/v2/workflows.py (lines ~1579, ~1669, ~1411-1452) ‚Äî integrate save/remove/merge\n\n**Files READ (reference only):**\n- packages/core/src/comfygit_core/repositories/model_repository.py:945 ‚Äî find_by_source_url used for reconciliation\n- server/api/v2/workflows.py:1460 ‚Äî existing _active_downloads dict\n- server/api/v2/workflows.py:1677-1712 ‚Äî _finalize_download\n\n## Parallelization Info\n\n**Can Run In Parallel With:** cgm-frontend-active-downloads (frontend bead) ‚Äî no file overlap\n**Cannot Run In Parallel With:** Nothing in current backlog\n\n## Estimated Scope\n- Size: Small-Medium (~80-120 LOC)\n- Risk: Low ‚Äî additive only, no existing behavior changes. Active-downloads.json is purely supplementary to pyproject intents.\n\n## Acceptance Criteria\n- [ ] active-downloads.json is written to .cec/ when a download starts\n- [ ] Entry is removed from active-downloads.json when download completes or is cancelled\n- [ ] /pending-downloads endpoint returns merged results from pyproject + active-downloads.json\n- [ ] Duplicate URLs between pyproject and active-downloads.json are deduplicated\n- [ ] Models already in the index (by source URL) are auto-cleaned from active-downloads.json\n- [ ] Missing or malformed active-downloads.json doesn't crash anything (graceful fallback)\n- [ ] Existing pyproject-based pending downloads behavior is unchanged\n\n## Testing Requirements\n- Unit test: active_downloads.py load/save/remove functions\n- Integration test: /pending-downloads returns active-downloads entries when no pyproject intents exist\n- Integration test: /pending-downloads deduplicates when same URL in both sources\n- Integration test: /pending-downloads auto-cleans entries for already-downloaded models\n- Existing test: uv run pytest testing/integration/panel/ should still pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-13T01:30:50.544491246-08:00","created_by":"ubuntu","updated_at":"2026-02-13T01:30:50.544491246-08:00"}
{"id":"cgm-cg9","title":"Add orchestrator heartbeat to enable dead-process detection","notes":"# Task: Add Orchestrator Heartbeat Mechanism\n\n## Context \u0026 Goal\n\nThe orchestrator writes its PID to `.orchestrator.pid` once at startup (line 695) but never updates it again. After 78+ hours of uptime, the orchestrator became unresponsive but the process was technically still alive (PID existed). There's currently no way to distinguish a healthy orchestrator from a zombie one beyond checking if the PID exists.\n\nA heartbeat mechanism would allow clients (the switch endpoint, CLI status commands, the frontend) to detect when the orchestrator is stuck or unresponsive, not just dead.\n\nThis is lower priority than the lock fix (cgm-74m) because the PID liveness check in that bead handles the most common failure case (dead process with stale lock). This bead addresses the rarer but harder case: alive-but-hung process.\n\n## Current State vs Target State\n\n**Current** (`server/orchestrator.py:342-365, 695`):\n\\`\\`\\`python\ndef write_orchestrator_pid(metadata_dir: Path) -\u003e None:\n    pid_file = metadata_dir / \".orchestrator.pid\"\n    pid_file.write_text(str(os.getpid()))\n    # Written once at line 695, never updated\n\\`\\`\\`\n\n**Target** ‚Äî periodic heartbeat update in the main loop:\n\\`\\`\\`python\ndef write_orchestrator_heartbeat(metadata_dir: Path) -\u003e None:\n    \"\"\"Update heartbeat file with current timestamp and PID.\"\"\"\n    hb_file = metadata_dir / \".orchestrator.heartbeat\"\n    hb_file.write_text(json.dumps({\n        \"pid\": os.getpid(),\n        \"timestamp\": time.time(),\n        \"uptime\": time.time() - START_TIME\n    }))\n\ndef is_orchestrator_healthy(metadata_dir: Path, max_stale_seconds: int = 30) -\u003e bool:\n    \"\"\"Check if orchestrator heartbeat is fresh.\"\"\"\n    hb_file = metadata_dir / \".orchestrator.heartbeat\"\n    if not hb_file.exists():\n        return False\n    try:\n        data = json.loads(hb_file.read_text())\n        age = time.time() - data[\"timestamp\"]\n        if age \u003e max_stale_seconds:\n            return False\n        # Also verify PID is alive\n        os.kill(data[\"pid\"], 0)\n        return True\n    except (json.JSONDecodeError, KeyError, ProcessLookupError, PermissionError):\n        return False\n\\`\\`\\`\n\nIn `_wait_with_polling()` (line 1253), add heartbeat write each iteration:\n\\`\\`\\`python\ndef _wait_with_polling(self, proc):\n    while True:\n        write_orchestrator_heartbeat(self.metadata_dir)  # ‚Üê add this\n        # ... existing polling logic ...\n\\`\\`\\`\n\nThen `orch status` CLI and the switch endpoint can use `is_orchestrator_healthy()` instead of just checking PID existence.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/orchestrator.py (lines 342-365) - add heartbeat write/read functions\n- server/orchestrator.py (lines 1253-1289) - write heartbeat in polling loop\n- server/orchestrator.py (lines 175-186) - update should_spawn_orchestrator_for_switch to use heartbeat\n\n**Files READ (reference only):**\n- server/api/v2/environments.py - understand where orchestrator health is checked before switch\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-ssk (frontend bug, different files)\n- cgm-101 (health check UX, different functions)\n\n**Cannot Run In Parallel With:**\n- cgm-74m (lock bug) ‚Äî both modify orchestrator.py lock/PID functions in overlapping areas (lines 342-386). However, they touch different functions so conflicts would be merge-level only, not logical.\n\n**Blocking Reason:** None ‚Äî this is a standalone enhancement\n\n## Estimated Scope\n- **Size:** Medium (~100 lines)\n- **Risk:** Low - additive change, no existing behavior modified\n\n## Acceptance Criteria\n- [ ] Heartbeat file updated every polling cycle (~0.5s)\n- [ ] Heartbeat contains PID, timestamp, and uptime\n- [ ] is_orchestrator_healthy() returns False for stale heartbeat (\u003e30s old)\n- [ ] is_orchestrator_healthy() returns False for dead PID\n- [ ] `cg orch status` shows \"Unhealthy\" when heartbeat is stale\n- [ ] Switch endpoint checks heartbeat health, not just PID existence\n\n## Testing Requirements\n- Existing tests: Check for orchestrator status tests\n- New tests: Test heartbeat write/read, test staleness detection, test dead-PID detection\n- Manual: Start orchestrator, verify heartbeat file updates; SIGSTOP the orchestrator, verify status shows unhealthy after 30s","status":"open","priority":3,"issue_type":"task","created_at":"2026-02-02T20:36:03.180504383-05:00","created_by":"ubuntu","updated_at":"2026-02-02T20:36:03.180504383-05:00"}
{"id":"cgm-d4z","title":"Add configurable keyboard shortcuts for ComfyGit panel and commit popover","notes":"## Context \u0026 Goal\n\n**Problem:** ComfyGit Manager has no keyboard shortcuts. Users must click the toolbar buttons to open the panel or commit popover. Power users expect keyboard shortcuts, and ComfyUI has a built-in system for extensions to register configurable keybindings that appear in Settings ‚Üí Keyboard Shortcuts.\n\n**Solution:** Register ComfyGit commands and keybindings using ComfyUI's extension API. This allows:\n1. Default shortcuts work out of the box\n2. Users can customize shortcuts in ComfyUI's Keyboard Shortcuts settings\n3. Shortcuts appear alongside other ComfyUI shortcuts in the UI\n\n**Proposed Shortcuts:**\n- `Ctrl+Shift+G` ‚Üí Open ComfyGit Panel\n- `Ctrl+Shift+C` ‚Üí Open Commit Popover (if in managed environment)\n\n---\n\n## Current State vs Target State\n\n### Current Code (frontend/src/main.ts, lines 498-538)\n\n```typescript\n// Register extension\napp.registerExtension({\n  name: 'Comfy.ComfyGitPanel',\n\n  // Hook into workflow loading to intercept missing resources\n  async beforeConfigureGraph(graphData: any, _missingNodeTypes: any[]) {\n    // ... existing code\n  },\n\n  async afterConfigureGraph(_missingNodeTypes: any[]) {\n    // ... existing code\n  },\n\n  async setup() {\n    // Create button group\n    const btnGroup = document.createElement('div')\n    // ... rest of setup\n  }\n})\n```\n\n### Target Code\n\n```typescript\n// Register extension\napp.registerExtension({\n  name: 'Comfy.ComfyGitPanel',\n\n  // Commands that can be triggered by keybindings or menu items\n  commands: [\n    {\n      id: 'ComfyGit.OpenPanel',\n      label: 'Open ComfyGit Panel',\n      icon: 'pi pi-folder-open',\n      function: () =\u003e showPanel()\n    },\n    {\n      id: 'ComfyGit.OpenCommitPopover',\n      label: 'Quick Commit',\n      icon: 'pi pi-check',\n      function: () =\u003e {\n        if (commitButton \u0026\u0026 !commitButton.disabled) {\n          showCommitPopover(commitButton)\n        }\n      }\n    }\n  ],\n\n  // Default keybindings (user can customize in Settings ‚Üí Keyboard Shortcuts)\n  keybindings: [\n    {\n      commandId: 'ComfyGit.OpenPanel',\n      combo: { key: 'g', ctrl: true, shift: true }\n    },\n    {\n      commandId: 'ComfyGit.OpenCommitPopover',\n      combo: { key: 'c', ctrl: true, shift: true }\n    }\n  ],\n\n  // Hook into workflow loading to intercept missing resources\n  async beforeConfigureGraph(graphData: any, _missingNodeTypes: any[]) {\n    // ... existing code unchanged\n  },\n\n  async afterConfigureGraph(_missingNodeTypes: any[]) {\n    // ... existing code unchanged\n  },\n\n  async setup() {\n    // ... existing code unchanged\n  }\n})\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/main.ts` (lines 498-510) - Add `commands` and `keybindings` arrays to registerExtension call\n\n**Files READ (reference only):**\n- `legacy/ComfyUI_frontend/src/types/comfy.ts` - ComfyExtension interface with commands/keybindings types\n- `legacy/ComfyUI_frontend/src/schemas/keyBindingSchema.ts` - Keybinding and KeyCombo types\n- `legacy/ComfyUI_frontend/src/extensions/core/groupNode.ts` - Example of commands/keybindings usage\n\n**Files CREATED:**\n- None\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any bead not touching frontend/src/main.ts\n\n**Cannot Run In Parallel With:**\n- Any bead modifying frontend/src/main.ts\n\n**Blocking Reason:** N/A (no dependents)\n\n---\n\n## Estimated Scope\n\n- **Size:** Small (~30 lines of new code)\n- **Risk:** Low (additive change, follows established pattern, no breaking changes)\n\n---\n\n## Acceptance Criteria\n\n- [ ] `Ctrl+Shift+G` opens the ComfyGit panel from anywhere in ComfyUI\n- [ ] `Ctrl+Shift+C` opens the commit popover (if commit button is enabled)\n- [ ] Both shortcuts appear in ComfyUI's Settings ‚Üí Keyboard Shortcuts menu\n- [ ] Users can rebind the shortcuts to different keys via the settings UI\n- [ ] Shortcuts work correctly - don't trigger when typing in input fields\n- [ ] Frontend builds without TypeScript errors\n\n---\n\n## Testing Requirements\n\n**Manual testing scenarios:**\n1. Press `Ctrl+Shift+G` from canvas ‚Üí Panel should open\n2. Press `Ctrl+Shift+C` from canvas ‚Üí Commit popover should open (if enabled)\n3. Open Settings ‚Üí Keyboard Shortcuts ‚Üí Search \"ComfyGit\" ‚Üí Both commands should appear\n4. Change keybinding for one command ‚Üí New keybinding should work\n5. Press shortcuts while typing in a text input ‚Üí Should NOT trigger (input should receive keys)\n6. Press `Ctrl+Shift+C` when commit button is disabled ‚Üí Should do nothing (no error)\n\n**No automated tests needed** - This uses ComfyUI's built-in keybinding system which is already tested. Manual verification is sufficient.\n\n---\n\n## Implementation Notes\n\nThe keybinding system in ComfyUI handles:\n- Ignoring shortcuts when typing in input fields (via `isReservedByTextInput` check)\n- Cross-platform Ctrl/Cmd handling (ctrl in combo means Ctrl on Windows/Linux, Cmd on Mac)\n- Persistence of user customizations via settings\n\nThe `function` in commands should be defensive - check that commitButton exists and is not disabled before showing the popover.\n\n**Command ID naming convention:** Use `ComfyGit.` prefix to namespace our commands and avoid conflicts with other extensions.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-29T14:30:54.779851196-05:00","created_by":"ubuntu","updated_at":"2026-01-29T23:57:55.388495753-05:00","closed_at":"2026-01-29T23:57:55.388495753-05:00","close_reason":"Already implemented - main.ts lines 502-531 have commands and keybindings arrays"}
{"id":"cgm-ddp","title":"Component: HfFileBrowser (refactor from HuggingFaceRepoModal)","notes":"## Context \u0026 Goal\n\nExtract the file browser logic from HuggingFaceRepoModal.vue into a reusable component. This component handles:\n- File list display with checkboxes\n- Shard grouping (multi-part model selection)\n- Search/filter\n- \"Models Only\" toggle\n- Selection state management\n- Destination selector\n\n## Current State\n\nAll logic lives in HuggingFaceRepoModal.vue (593 lines). Key sections:\n- File list template: lines 40-63\n- Selection logic: lines 227-271\n- Destination section: lines 65-90\n- Shard regex: line 161\n- formatSize utility: lines 207-216\n\n## Target State\n\n**Create `frontend/src/components/download/HfFileBrowser.vue`:**\n\nProps:\n```typescript\ninterface Props {\n  repoId: string\n  revision: string\n  initialPath?: string        // Pre-navigate to folder\n  preselectedFile?: string    // Pre-select this file\n}\n```\n\nEmits:\n```typescript\ninterface Emits {\n  (e: 'queue', items: HfDownloadItem[]): void\n  (e: 'back'): void  // Return to search\n}\n```\n\nInternal state:\n- files: HuggingFaceRepoFile[]\n- selected: Set\u003cstring\u003e\n- searchQuery: string\n- showOnlyModels: boolean\n- destBase, destSubfolder, destCustom\n- directories: string[]\n- loading, error\n\nFeatures to preserve:\n1. File list with checkbox selection\n2. Shard group detection and grouped selection\n3. Search filter\n4. \"Models Only\" toggle\n5. Auto-Select Models button\n6. Destination selector (base + subfolder or custom)\n7. Summary bar (count + size)\n8. Queue Download button\n\nAdd new feature:\n- Back button (‚óÑ) to return to search results\n- Use initialPath to filter files to that folder on load\n- Use preselectedFile to pre-check that file\n\n## Files Inventory\n\n**Files CREATED:**\n- frontend/src/components/download/HfFileBrowser.vue\n\n**Files READ (reference only):**\n- frontend/src/components/HuggingFaceRepoModal.vue - Copy/refactor logic from here\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-xxx (DirectUrlTab) - different file\n- cgm-xxx (CivitaiTab) - different file\n\n**Cannot Run In Parallel With:**\n- None in Phase 2\n\n**Depends On:**\n- cgm-ncr (types must exist for imports)\n\n## Estimated Scope\n- **Size:** Large (~400 lines, mostly moved from existing)\n- **Risk:** Medium (refactoring existing code)\n\n## Acceptance Criteria\n- [ ] Component renders file list with checkboxes\n- [ ] Clicking file toggles selection (with shard grouping)\n- [ ] Search filter works\n- [ ] \"Models Only\" toggle works\n- [ ] Auto-Select Models works\n- [ ] Destination selector works (dropdown + subfolder)\n- [ ] Summary shows count and total size\n- [ ] Back button emits 'back' event\n- [ ] Queue Download emits 'queue' with HfDownloadItem[]\n- [ ] Pre-selected file is checked on mount\n\n## Testing Requirements\n- Visual testing in browser\n- Ensure all existing HuggingFaceRepoModal functionality preserved","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T02:32:33.655669451-05:00","created_by":"ubuntu","updated_at":"2026-01-28T02:54:43.719825718-05:00","closed_at":"2026-01-28T02:54:43.719825718-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-ddp","depends_on_id":"cgm-ncr","type":"blocks","created_at":"2026-01-28T02:34:29.675250544-05:00","created_by":"ubuntu"}]}
{"id":"cgm-dq2","title":"Add tests for crash retry logic","notes":"\n## Context \u0026 Goal\n\nWrite comprehensive tests for the new general crash retry logic added to the orchestrator in bead cgm-4oy. Tests should validate the retry counter, delay behavior, config integration, and interaction with the existing extra_args bypass.\n\n## Current State vs Target State\n\n### Current: test_comfyui_backend_flags.py ends at line 653\nNo tests exist for general crash retry behavior.\n\n### Target: Add new test class(es) to testing/unit/test_comfyui_backend_flags.py\n\nAppend new classes at the end of `testing/unit/test_comfyui_backend_flags.py` since that file already contains all crash recovery tests (TestCrashRecoveryFlags, TestCrashRecoveryExtraArgsTracking, TestCrashRecoverySkipExtraArgs, TestCrashRecoveryInRunForever).\n\n**Important implementation notes:**\n- Patch `time.sleep` as `mocker.patch(\"time.sleep\")` -- this is the established pattern in the codebase (see test_orchestrator_abort.py and test_health_checking.py). It works because orchestrator.py calls `time.sleep()` through the module reference.\n- For `mock_proc.wait.side_effect`, use a flat list like `[-9, 0]` -- Mock returns values regardless of kwargs, so the `timeout=0.5` kwarg from `_wait_with_polling` is handled transparently. This matches the existing pattern in test_orchestrator_loop.py (e.g., line 49: `mock_proc.wait.side_effect = [42, 0]`).\n\n```python\n@pytest.mark.unit\nclass TestGeneralCrashRetry:\n    \"\"\"Test general crash retry with delay.\"\"\"\n\n    def test_crash_retry_count_initialized_to_zero(self, mock_workspace):\n        \"\"\"Should initialize _crash_retry_count to 0.\"\"\"\n        from server.orchestrator import Orchestrator\n        orch = Orchestrator(workspace_root=mock_workspace, initial_env=\"env1\", args=[])\n        assert orch._crash_retry_count == 0\n\n    def test_crash_retries_up_to_max(self, mock_workspace, mocker):\n        \"\"\"Should retry crash_retry_max times before giving up.\"\"\"\n        from server.orchestrator import Orchestrator\n        import json\n\n        config_file = mock_workspace / \".metadata\" / \"orchestrator_config.json\"\n        config_file.write_text(json.dumps({\n            \"version\": \"1.0\",\n            \"orchestrator\": {\n                \"enable_control_server\": False,\n                \"crash_retry_max\": 2,\n                \"crash_retry_delay_s\": 0\n            },\n            \"comfyui\": {\"extra_args\": []}\n        }))\n\n        orch = Orchestrator(workspace_root=mock_workspace, initial_env=\"env1\", args=[])\n        mocker.patch(\"time.sleep\")\n\n        # First crash: should retry\n        assert orch._handle_crash_for_recovery(-9) is True\n        assert orch._crash_retry_count == 1\n\n        # Second crash: should retry (max is 2)\n        assert orch._handle_crash_for_recovery(-9) is True\n        assert orch._crash_retry_count == 2\n\n        # Third crash: exhausted retries\n        assert orch._handle_crash_for_recovery(-9) is False\n\n    def test_crash_retry_sleeps_between_attempts(self, mock_workspace, mocker):\n        \"\"\"Should sleep crash_retry_delay_s between retries.\"\"\"\n        from server.orchestrator import Orchestrator\n        import json\n\n        config_file = mock_workspace / \".metadata\" / \"orchestrator_config.json\"\n        config_file.write_text(json.dumps({\n            \"version\": \"1.0\",\n            \"orchestrator\": {\n                \"enable_control_server\": False,\n                \"crash_retry_max\": 3,\n                \"crash_retry_delay_s\": 10\n            },\n            \"comfyui\": {\"extra_args\": []}\n        }))\n\n        orch = Orchestrator(workspace_root=mock_workspace, initial_env=\"env1\", args=[])\n        mock_sleep = mocker.patch(\"time.sleep\")\n\n        orch._handle_crash_for_recovery(-9)\n        mock_sleep.assert_called_with(10)\n\n    def test_crash_retry_uses_default_config(self, mock_workspace, mocker):\n        \"\"\"Should use default max=3 and delay=10 when not configured.\"\"\"\n        from server.orchestrator import Orchestrator\n\n        orch = Orchestrator(workspace_root=mock_workspace, initial_env=\"env1\", args=[])\n        mocker.patch(\"time.sleep\")\n\n        # Should allow 3 retries by default\n        for i in range(3):\n            assert orch._handle_crash_for_recovery(1) is True\n        assert orch._handle_crash_for_recovery(1) is False\n\n    def test_extra_args_bypass_happens_before_general_retry(self, mock_workspace, mocker):\n        \"\"\"Extra args bypass should be tried first, then general retries.\"\"\"\n        from server.orchestrator import Orchestrator\n        import json\n\n        config_file = mock_workspace / \".metadata\" / \"orchestrator_config.json\"\n        config_file.write_text(json.dumps({\n            \"version\": \"1.0\",\n            \"orchestrator\": {\n                \"enable_control_server\": False,\n                \"crash_retry_max\": 2,\n                \"crash_retry_delay_s\": 0\n            },\n            \"comfyui\": {\"extra_args\": [\"--bad-flag\"]}\n        }))\n\n        orch = Orchestrator(workspace_root=mock_workspace, initial_env=\"env1\", args=[])\n        mocker.patch(\"time.sleep\")\n\n        # Simulate first start used extra_args\n        orch._used_extra_args = True\n        orch._skip_extra_args = False\n\n        # First crash: should try extra_args bypass (count goes to 1)\n        assert orch._handle_crash_for_recovery(-9) is True\n        assert orch._skip_extra_args is True\n        assert orch._crash_retry_count == 1\n\n        # Simulate second start without extra_args\n        orch._used_extra_args = False\n\n        # Second crash: general retry (count goes to 2 = max), returns True\n        assert orch._handle_crash_for_recovery(-9) is True\n        assert orch._crash_retry_count == 2\n\n        # Third crash: count (2) \u003e= max (2), exhausted\n        assert orch._handle_crash_for_recovery(-9) is False\n\n    def test_clear_flags_resets_retry_count(self, mock_workspace):\n        \"\"\"_clear_crash_recovery_flags should reset _crash_retry_count.\"\"\"\n        from server.orchestrator import Orchestrator\n\n        orch = Orchestrator(workspace_root=mock_workspace, initial_env=\"env1\", args=[])\n        orch._crash_retry_count = 5\n\n        orch._clear_crash_recovery_flags()\n\n        assert orch._crash_retry_count == 0\n\n    def test_crash_retry_in_run_forever_loop(self, mock_workspace, mocker):\n        \"\"\"Full integration: crash with retry then success in main loop.\"\"\"\n        from server.orchestrator import Orchestrator\n        from unittest.mock import Mock\n        import json\n\n        config_file = mock_workspace / \".metadata\" / \"orchestrator_config.json\"\n        config_file.write_text(json.dumps({\n            \"version\": \"1.0\",\n            \"orchestrator\": {\n                \"enable_control_server\": False,\n                \"crash_retry_max\": 2,\n                \"crash_retry_delay_s\": 0\n            },\n            \"comfyui\": {\"extra_args\": []}\n        }))\n\n        mock_proc = Mock()\n        # First start: crash with -9 (OOM), second start: clean exit\n        mock_proc.wait.side_effect = [-9, 0]\n\n        mock_env = Mock()\n        mock_env.name = \"env1\"\n\n        mocker.patch.object(Orchestrator, \"_sync_environment\")\n        mocker.patch.object(Orchestrator, \"_start_comfyui\", return_value=mock_proc)\n        mocker.patch(\"time.sleep\")\n\n        orch = Orchestrator(workspace_root=mock_workspace, initial_env=\"env1\", args=[])\n        orch.workspace.get_environment = Mock(return_value=mock_env)\n\n        orch.run_forever()\n\n        # Should have started twice (crash + retry that succeeded)\n        assert orch._start_comfyui.call_count == 2\n\n\n@pytest.mark.unit\nclass TestDefaultConfigCrashRetry:\n    \"\"\"Test DEFAULT_CONFIG includes crash retry settings.\"\"\"\n\n    def test_default_config_has_crash_retry_max(self):\n        from server.orchestrator import DEFAULT_CONFIG\n        assert DEFAULT_CONFIG[\"orchestrator\"][\"crash_retry_max\"] == 3\n\n    def test_default_config_has_crash_retry_delay(self):\n        from server.orchestrator import DEFAULT_CONFIG\n        assert DEFAULT_CONFIG[\"orchestrator\"][\"crash_retry_delay_s\"] == 10\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- testing/unit/test_comfyui_backend_flags.py (append new test classes after line 653)\n\n**Files READ (reference only):**\n- server/orchestrator.py - the implementation being tested\n- testing/conftest.py - fixtures (mock_workspace, metadata_dir)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing - depends on cgm-4oy\n\n**Cannot Run In Parallel With:**\n- cgm-4oy - REASON: tests validate code from that bead\n\n**Blocking Reason:**\n- Implementation (cgm-4oy) must be complete before tests can pass\n\n## Estimated Scope\n- **Size:** Medium (~120 lines of test code)\n- **Risk:** Low (only adds tests, no production code changes)\n\n## Acceptance Criteria\n- [ ] All new tests pass with `uv run pytest testing/unit/test_comfyui_backend_flags.py -v`\n- [ ] All existing tests still pass with `uv run pytest testing/ -v`\n- [ ] Tests cover: retry counting, delay behavior, config integration, default values, extra_args interaction, retry count reset, full loop integration\n- [ ] No test sleeps (time.sleep mocked)\n\n## Testing Requirements\n- Run: `uv run pytest testing/unit/test_comfyui_backend_flags.py -v`\n- Run: `uv run pytest testing/unit/test_orchestrator_loop.py -v`\n- Run: `uv run pytest testing/ -v` (full suite)\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T22:15:52.814659161-05:00","created_by":"ubuntu","updated_at":"2026-01-30T00:22:35.130926858-05:00","closed_at":"2026-01-30T00:22:35.130926858-05:00","close_reason":"Implemented and all 53 tests passing","dependencies":[{"issue_id":"cgm-dq2","depends_on_id":"cgm-4oy","type":"blocks","created_at":"2026-01-29T22:15:56.682716238-05:00","created_by":"ubuntu"}]}
{"id":"cgm-e11","title":"Component: CivitaiTab (placeholder)","notes":"## Context \u0026 Goal\n\nCreate a placeholder tab for Civitai downloads. Shows \"Coming soon\" message for now.\n\n## Target State\n\n**Create `frontend/src/components/download/CivitaiTab.vue`:**\n\n```vue\n\u003ctemplate\u003e\n  \u003cdiv class=\"civitai-tab\"\u003e\n    \u003cdiv class=\"placeholder\"\u003e\n      \u003cdiv class=\"icon\"\u003eüé®\u003c/div\u003e\n      \u003ch3\u003eCivitai Integration\u003c/h3\u003e\n      \u003cp\u003eComing soon! Civitai model search and download will be available in a future update.\u003c/p\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\n// Placeholder - no logic needed yet\n\u003c/script\u003e\n\n\u003cstyle scoped\u003e\n.civitai-tab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-height: 300px;\n  padding: var(--cg-space-4);\n}\n\n.placeholder {\n  text-align: center;\n  color: var(--cg-color-text-muted);\n}\n\n.placeholder .icon {\n  font-size: 48px;\n  margin-bottom: var(--cg-space-3);\n}\n\n.placeholder h3 {\n  color: var(--cg-color-text-secondary);\n  margin: 0 0 var(--cg-space-2) 0;\n}\n\n.placeholder p {\n  margin: 0;\n  font-size: var(--cg-font-size-sm);\n}\n\u003c/style\u003e\n```\n\n## Files Inventory\n\n**Files CREATED:**\n- frontend/src/components/download/CivitaiTab.vue\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All Phase 2 tasks (different files)\n\n**Cannot Run In Parallel With:**\n- None\n\n## Estimated Scope\n- **Size:** Small (~50 lines)\n- **Risk:** Low (static placeholder)\n\n## Acceptance Criteria\n- [ ] Component renders \"Coming soon\" message\n- [ ] Centered layout with icon\n- [ ] Styled consistently with design system\n\n## Testing Requirements\n- Visual check only","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T02:32:59.369558705-05:00","created_by":"ubuntu","updated_at":"2026-01-28T02:40:12.569776062-05:00","closed_at":"2026-01-28T02:40:12.569776062-05:00","close_reason":"Closed"}
{"id":"cgm-e6c","title":"Add per-environment detail API endpoint","notes":"## Context \u0026 Goal\nThe environment details modal currently shows only counts (workflow_count, node_count, model_count) because the list endpoint only returns aggregate numbers. Users want to see the actual names of workflows, nodes, and models in each environment.\n\nThis task adds a new `GET /v2/comfygit/environments/{name}` endpoint that returns rich detail for a single environment, fetched on-demand when the user clicks \"Details\".\n\n## Current State vs Target State\n\n**Current:** `_get_environment_info()` in `server/api/v2/environments.py:104-120` calls `env.status()` but only returns `len()` of lists:\n```python\n\"workflow_count\": len(status.workflow.sync_status.synced) + len(status.workflow.sync_status.new) + len(status.workflow.sync_status.modified),\n\"node_count\": len(status.comparison.missing_nodes) + len(status.comparison.extra_nodes) + len(status.comparison.version_mismatches),\n\"model_count\": len(status.missing_models),\n```\n\n**Target:** New endpoint `GET /v2/comfygit/environments/{name}` returns:\n```python\n{\n    \"name\": \"env-name\",\n    \"is_current\": True,\n    \"path\": \"/path/to/env\",\n    \"current_branch\": \"main\",\n    \"created_at\": None,\n    \"workflows\": {\n        \"synced\": [\"workflow1.json\", \"workflow2.json\"],\n        \"new\": [\"new_workflow.json\"],\n        \"modified\": [\"changed.json\"],\n        \"deleted\": [\"removed.json\"]\n    },\n    \"nodes\": [\n        {\"name\": \"ComfyUI-Impact-Pack\", \"version\": \"1.0.0\", \"source\": \"registry\"},\n        ...\n    ],\n    \"models\": {\n        \"missing\": [\n            {\n                \"filename\": \"model.safetensors\",\n                \"category\": \"checkpoints\",\n                \"workflow_names\": [\"workflow1.json\", \"workflow2.json\"],\n                \"criticality\": \"required\",\n                \"can_download\": True\n            }\n        ]\n    },\n    \"workflow_count\": 3,\n    \"node_count\": 2,\n    \"model_count\": 1\n}\n```\n\n## Implementation Details\n\n### Step 1: Add missing import (line 13)\n\nAdd `CDEnvironmentNotFoundError` to the imports. Currently only `CDWorkspaceNotFoundError` is imported:\n\n```python\n# CURRENT (line 13):\nfrom comfygit_core.models.exceptions import CDWorkspaceNotFoundError\n\n# TARGET:\nfrom comfygit_core.models.exceptions import CDWorkspaceNotFoundError, CDEnvironmentNotFoundError\n```\n\n### Step 2: Add route handler AFTER `list_environments` (after line 167)\n\nPlace the new route after the existing `GET /v2/comfygit/environments` handler (line 167) to ensure aiohttp matches the exact path first, then the parameterized path.\n\n```python\n@routes.get(\"/v2/comfygit/environments/{name}\")\nasync def get_environment_details(request: web.Request) -\u003e web.Response:\n    \"\"\"Get detailed information for a specific environment.\"\"\"\n    is_managed, workspace, current_env = orchestrator.detect_environment_type()\n\n    if not is_managed or not workspace:\n        return web.json_response({\"error\": \"Not in managed workspace\"}, status=500)\n\n    name = request.match_info.get(\"name\", \"\").strip()\n    if not name:\n        return web.json_response({\"error\": \"Environment name required\"}, status=400)\n\n    try:\n        env = await run_sync(workspace.get_environment, name, auto_sync=False)\n    except CDEnvironmentNotFoundError:\n        return web.json_response({\"error\": f\"Environment '{name}' not found\"}, status=404)\n\n    try:\n        status = await run_sync(env.status)\n        tracked_nodes = await run_sync(env.list_nodes)\n\n        sync = status.workflow.sync_status\n        return web.json_response({\n            \"name\": env.name,\n            \"is_current\": env.name == current_env.name if current_env else False,\n            \"path\": str(env.path),\n            \"current_branch\": status.git.current_branch,\n            \"created_at\": None,\n            \"workflows\": {\n                \"synced\": list(sync.synced),\n                \"new\": list(sync.new),\n                \"modified\": list(sync.modified),\n                \"deleted\": list(sync.deleted),\n            },\n            \"nodes\": [\n                {\"name\": n.name, \"version\": n.version, \"source\": n.source}\n                for n in tracked_nodes\n            ],\n            \"models\": {\n                \"missing\": [\n                    {\n                        \"filename\": m.model.filename,\n                        \"category\": m.model.category,\n                        \"workflow_names\": m.workflow_names,\n                        \"criticality\": m.criticality,\n                        \"can_download\": m.can_download,\n                    }\n                    for m in status.missing_models\n                ]\n            },\n            \"workflow_count\": sync.total_count,\n            \"node_count\": len(tracked_nodes),\n            \"model_count\": len(status.missing_models),\n        })\n    except Exception as e:\n        return web.json_response({\"error\": \"internal_error\", \"message\": str(e)}, status=500)\n```\n\n### Key core library types (verified):\n\n**`env.status()` ‚Üí `EnvironmentStatus`** (core/models/environment.py:163):\n- `.workflow` ‚Üí `DetailedWorkflowStatus` with `.sync_status` ‚Üí `WorkflowSyncStatus`\n  - `WorkflowSyncStatus` fields: `synced: list[str]`, `new: list[str]`, `modified: list[str]`, `deleted: list[str]`\n  - Property: `total_count: int` (sum of all lists)\n- `.comparison` ‚Üí `EnvironmentComparison` with `.missing_nodes`, `.extra_nodes`, `.version_mismatches`\n- `.missing_models` ‚Üí `list[MissingModelInfo]`\n\n**`MissingModelInfo`** (core/models/environment.py:107):\n- `.model` ‚Üí `ManifestModel` (has `.filename`, `.hash`, `.size`, `.relative_path`, `.category`, `.sources`)\n- `.workflow_names` ‚Üí `list[str]` (which workflows need it)\n- `.criticality` ‚Üí `str` (\"required\", \"flexible\", \"optional\")\n- `.can_download` ‚Üí `bool`\n\n**IMPORTANT**: Access filename as `m.model.filename` NOT `m.filename` ‚Äî MissingModelInfo wraps ManifestModel.\n\n**`env.list_nodes()` ‚Üí `list[NodeInfo]`** (core/models/shared.py:16):\n- `.name`, `.registry_id`, `.repository`, `.version`, `.download_url`, `.source`, `.dependency_sources`, `.branch`, `.pinned_commit`\n- Works on ANY environment (reads pyproject.toml from disk, no running process needed)\n\n**`workspace.get_environment(name, auto_sync=False)` ‚Üí `Environment`** (core/workspace.py:373):\n- Signature: `get_environment(self, name: str, auto_sync: bool = True, progress=None) -\u003e Environment`\n- Default `auto_sync=True` ‚Äî use `False` for read-only operations\n- Raises: `CDEnvironmentNotFoundError` if not found\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/api/v2/environments.py\n  - Line 13: add `CDEnvironmentNotFoundError` to import\n  - After line 167: add new route handler (~50 lines)\n\n**Files READ (reference only):**\n- Core library types (already explored, signatures documented above)\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-328 (frontend modal) ‚Äî no file overlap, API contract defined above\n\n**Cannot Run In Parallel With:**\n- N/A\n\n## Estimated Scope\n- **Size:** Small (~50 lines new code + 1 import change)\n- **Risk:** Low (new endpoint, no changes to existing endpoints)\n\n## Acceptance Criteria\n- [ ] `CDEnvironmentNotFoundError` imported at line 13\n- [ ] GET /v2/comfygit/environments/{name} returns full detail response\n- [ ] Returns 404 for non-existent environment name\n- [ ] Returns 500 for non-managed workspace\n- [ ] Workflows categorized by sync state (synced/new/modified/deleted)\n- [ ] Nodes include name, version, source from env.list_nodes()\n- [ ] Models include filename, category, workflow_names, criticality, can_download from MissingModelInfo\n- [ ] workflow_count uses sync_status.total_count (correct total)\n- [ ] node_count = len(tracked_nodes) (all tracked, not just problem nodes)\n- [ ] Existing list endpoint at /v2/comfygit/environments unchanged\n- [ ] New route placed AFTER existing list route to avoid aiohttp matching conflicts\n\n## Testing Requirements\n- Manual: curl the endpoint against a running ComfyGit workspace\n- Optional: add panel API test in testing/integration/panel/","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-30T01:33:20.990488972-05:00","created_by":"ubuntu","updated_at":"2026-01-30T02:08:55.907804694-05:00","closed_at":"2026-01-30T02:08:55.907804694-05:00","close_reason":"Implemented by sprint agents. Backend endpoint and frontend collapsible modal merged to dev."}
{"id":"cgm-efs","title":"Component: HuggingFaceTab (search + browse orchestration)","notes":"## Context \u0026 Goal\n\nCreate the HuggingFace tab that orchestrates between search mode and browse mode. This is the main interface for HuggingFace downloads.\n\n## Target State\n\n**Create `frontend/src/components/download/HuggingFaceTab.vue`:**\n\nTwo modes:\n1. **Search mode**: Input bar + search results\n2. **Browse mode**: HfFileBrowser component\n\n```vue\n\u003ctemplate\u003e\n  \u003cdiv class=\"huggingface-tab\"\u003e\n    \u003c!-- Search Input (always visible) --\u003e\n    \u003cdiv class=\"search-section\"\u003e\n      \u003cdiv class=\"search-bar\"\u003e\n        \u003cBaseInput\n          v-model=\"searchInput\"\n          placeholder=\"Search repos, paste URL, or enter user/repo...\"\n          @keydown.enter=\"handleSearch\"\n        /\u003e\n        \u003cBaseButton variant=\"primary\" @click=\"handleSearch\" :loading=\"searching\"\u003e\n          Search\n        \u003c/BaseButton\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \n    \u003c!-- Search Results (search mode) --\u003e\n    \u003cdiv v-if=\"mode === 'search'\" class=\"search-results\"\u003e\n      \u003cdiv v-if=\"searching\" class=\"loading\"\u003eSearching...\u003c/div\u003e\n      \u003cdiv v-else-if=\"searchError\" class=\"error\"\u003e{{ searchError }}\u003c/div\u003e\n      \u003cdiv v-else-if=\"searchResults.length \u003e 0\" class=\"results-list\"\u003e\n        \u003cdiv\n          v-for=\"repo in searchResults\"\n          :key=\"repo.repo_id\"\n          class=\"repo-card\"\n          @click=\"selectRepo(repo.repo_id)\"\n        \u003e\n          \u003cdiv class=\"repo-header\"\u003e\n            \u003cspan class=\"repo-id\"\u003e{{ repo.repo_id }}\u003c/span\u003e\n            \u003cdiv class=\"repo-stats\"\u003e\n              \u003cspan\u003e‚¨áÔ∏è {{ formatNumber(repo.downloads) }}\u003c/span\u003e\n              \u003cspan\u003e‚≠ê {{ formatNumber(repo.likes) }}\u003c/span\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cp v-if=\"repo.description\" class=\"repo-desc\"\u003e{{ repo.description }}\u003c/p\u003e\n          \u003cdiv v-if=\"repo.tags.length\" class=\"repo-tags\"\u003e\n            \u003cspan v-for=\"tag in repo.tags.slice(0, 5)\" :key=\"tag\" class=\"tag\"\u003e{{ tag }}\u003c/span\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003cdiv v-else-if=\"hasSearched\" class=\"empty\"\u003eNo repositories found\u003c/div\u003e\n      \u003cdiv v-else class=\"hint\"\u003e\n        Enter a HuggingFace URL, repo ID (user/repo), or search term\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \n    \u003c!-- File Browser (browse mode) --\u003e\n    \u003cHfFileBrowser\n      v-else\n      :repo-id=\"selectedRepo!\"\n      :revision=\"selectedRevision\"\n      :initial-path=\"initialPath\"\n      :preselected-file=\"preselectedFile\"\n      @back=\"handleBack\"\n      @queue=\"$emit('queue', $event)\"\n    /\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\nState management:\n```typescript\nconst mode = ref\u003c'search' | 'browse'\u003e('search')\nconst searchInput = ref('')\nconst searchResults = ref\u003cHuggingFaceSearchResult[]\u003e([])\nconst searching = ref(false)\nconst searchError = ref\u003cstring | null\u003e(null)\nconst hasSearched = ref(false)\n\n// Browse mode state\nconst selectedRepo = ref\u003cstring | null\u003e(null)\nconst selectedRevision = ref('main')\nconst initialPath = ref\u003cstring | undefined\u003e()\nconst preselectedFile = ref\u003cstring | undefined\u003e()\n```\n\nSmart input handling in handleSearch():\n```typescript\nasync function handleSearch() {\n  const input = searchInput.value.trim()\n  if (!input) return\n  \n  // Try parsing as HuggingFace URL\n  const parsed = parseHuggingFaceUrl(input)\n  \n  if (parsed.kind === 'file' \u0026\u0026 parsed.repoId \u0026\u0026 parsed.path) {\n    // File URL: browse mode with pre-selection\n    selectedRepo.value = parsed.repoId\n    selectedRevision.value = parsed.revision || 'main'\n    initialPath.value = parsed.path.split('/').slice(0, -1).join('/') // Parent folder\n    preselectedFile.value = parsed.path\n    mode.value = 'browse'\n    return\n  }\n  \n  if (parsed.kind === 'repo' \u0026\u0026 parsed.repoId) {\n    // Repo URL: go to browse\n    selectedRepo.value = parsed.repoId\n    selectedRevision.value = parsed.revision || 'main'\n    mode.value = 'browse'\n    return\n  }\n  \n  // Check for shorthand repo ID (user/repo)\n  if (/^[\\w-]+\\/[\\w.-]+$/.test(input) \u0026\u0026 !input.includes('://')) {\n    selectedRepo.value = input\n    selectedRevision.value = 'main'\n    mode.value = 'browse'\n    return\n  }\n  \n  // Otherwise, search\n  searching.value = true\n  searchError.value = null\n  try {\n    const response = await searchHuggingFaceRepos(input)\n    searchResults.value = response.results\n    hasSearched.value = true\n  } catch (e) {\n    searchError.value = e instanceof Error ? e.message : 'Search failed'\n  } finally {\n    searching.value = false\n  }\n}\n```\n\n## Files Inventory\n\n**Files CREATED:**\n- frontend/src/components/download/HuggingFaceTab.vue\n\n**Files READ (reference only):**\n- frontend/src/utils/huggingface.ts - parseHuggingFaceUrl\n- frontend/src/composables/useComfyGitService.ts - searchHuggingFaceRepos\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- None (depends on HfFileBrowser)\n\n**Cannot Run In Parallel With:**\n- cgm-ddp (HfFileBrowser) - imports it\n\n**Depends On:**\n- cgm-ddp (HfFileBrowser must exist)\n- cgm-ncr (service method must exist)\n\n## Estimated Scope\n- **Size:** Large (~250 lines)\n- **Risk:** Medium (orchestration logic)\n\n## Acceptance Criteria\n- [ ] Search input with Enter key trigger\n- [ ] Search button works\n- [ ] URL detection auto-switches to browse mode\n- [ ] Shorthand \"user/repo\" detection works\n- [ ] Search results display as cards\n- [ ] Clicking result opens file browser\n- [ ] File URL pre-selects file\n- [ ] Back button returns to search results (preserving them)\n- [ ] Queue event bubbles up\n\n## Testing Requirements\n- Enter \"flux\" ‚Üí see search results\n- Paste full URL ‚Üí auto-browse\n- Paste \"Kijai/LTXV2_comfy\" ‚Üí auto-browse\n- Paste file URL ‚Üí browse with pre-selection\n- Click result ‚Üí browse files\n- Back ‚Üí return to results","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T02:33:28.620359636-05:00","created_by":"ubuntu","updated_at":"2026-01-28T03:03:36.207293915-05:00","closed_at":"2026-01-28T03:03:36.207293915-05:00","close_reason":"Implemented HuggingFaceTab with search/browse mode orchestration","dependencies":[{"issue_id":"cgm-efs","depends_on_id":"cgm-ddp","type":"blocks","created_at":"2026-01-28T02:34:29.690441208-05:00","created_by":"ubuntu"},{"issue_id":"cgm-efs","depends_on_id":"cgm-ncr","type":"blocks","created_at":"2026-01-28T02:34:29.708756631-05:00","created_by":"ubuntu"}]}
{"id":"cgm-er5","title":"Core: Add manual model add/remove methods to EnvironmentModelManager","notes":"## Context \u0026 Goal\n\nThe comfygit-core library has all the building blocks for manual model addition (ManifestWorkflowModel, pyproject.workflows.add_workflow_model(), ManifestModel, pyproject.models.add_model()) but no public API that wraps them for the manual-add use case. We need two methods on EnvironmentModelManager.\n\n## Current State vs Target State\n\n**Current** (`environment_model_manager.py`): Only has add_model_source(), remove_model_source(), get_models_without_sources(), detect_missing_models(), prepare_import_with_model_strategy(). No method to add/remove a model entry to a workflow manifest.\n\n**Target**: Add two new methods:\n\n\\`\\`\\`python\n# In EnvironmentModelManager (after line 193)\n\ndef add_manual_model(\n    self,\n    workflow_name: str,\n    model_hash: str,\n    criticality: str = \"required\",\n) -\u003e ManifestWorkflowModel:\n    \"\"\"Add an existing workspace model to a workflow manifest manually.\n    \n    Looks up the model in the workspace model repository by hash,\n    creates a ManifestWorkflowModel with nodes=[] (no node references),\n    adds it to the workflow's model list, and ensures the global models\n    table is also updated.\n    \n    Args:\n        workflow_name: Target workflow name in pyproject.toml\n        model_hash: CRC32 hash of model (must exist in workspace index)\n        criticality: \"required\", \"flexible\", or \"optional\"\n    \n    Returns:\n        The created ManifestWorkflowModel\n        \n    Raises:\n        ValueError: If model not found in workspace index or workflow doesn't exist\n    \"\"\"\n    # 1. Look up model in workspace repository\n    model_info = self.model_repository.get_model(model_hash)\n    if not model_info:\n        raise ValueError(f\"Model not found in workspace index: {model_hash}\")\n    \n    # 2. Verify workflow exists\n    all_workflows = self.pyproject.workflows.get_all_with_resolutions()\n    if workflow_name not in all_workflows:\n        raise ValueError(f\"Workflow not found: {workflow_name}\")\n    \n    # 3. Check if model already exists in this workflow\n    existing_models = self.pyproject.workflows.get_workflow_models(workflow_name)\n    for existing in existing_models:\n        if existing.hash == model_hash:\n            raise ValueError(f\"Model already exists in workflow '{workflow_name}': {model_info.filename}\")\n    \n    # 4. Create ManifestWorkflowModel with empty nodes (manual entry)\n    wf_model = ManifestWorkflowModel(\n        filename=model_info.filename,\n        category=model_info.category,\n        criticality=criticality,\n        status=\"resolved\",\n        nodes=[],  # No node references - this is a manual entry\n        hash=model_hash,\n        relative_path=model_info.relative_path,\n    )\n    \n    # 5. Add to workflow\n    self.pyproject.workflows.add_workflow_model(workflow_name, wf_model)\n    \n    # 6. Ensure global models table has this model\n    global_model = ManifestModel(\n        hash=model_hash,\n        filename=model_info.filename,\n        size=model_info.file_size,\n        relative_path=model_info.relative_path,\n        category=model_info.category,\n    )\n    self.pyproject.models.add_model(global_model)\n    \n    logger.info(f\"Manually added model {model_info.filename} to workflow '{workflow_name}'\")\n    return wf_model\n\n\ndef remove_manual_model(\n    self,\n    workflow_name: str,\n    model_hash: str,\n) -\u003e bool:\n    \"\"\"Remove a manually-added model from a workflow manifest.\n    \n    Only removes models with empty nodes[] (manual entries).\n    Auto-discovered models (with node references) cannot be removed this way.\n    \n    Args:\n        workflow_name: Target workflow name\n        model_hash: CRC32 hash of model to remove\n    \n    Returns:\n        True if removed, False if not found or not a manual entry\n        \n    Raises:\n        ValueError: If workflow doesn't exist\n    \"\"\"\n    all_workflows = self.pyproject.workflows.get_all_with_resolutions()\n    if workflow_name not in all_workflows:\n        raise ValueError(f\"Workflow not found: {workflow_name}\")\n    \n    models = self.pyproject.workflows.get_workflow_models(workflow_name)\n    \n    # Find the manual model (hash match + empty nodes)\n    new_models = []\n    removed = False\n    for m in models:\n        if m.hash == model_hash and len(m.nodes) == 0:\n            removed = True\n            logger.info(f\"Removed manual model {m.filename} from workflow '{workflow_name}'\")\n            continue\n        new_models.append(m)\n    \n    if removed:\n        self.pyproject.workflows.set_workflow_models(workflow_name, new_models)\n    \n    return removed\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/environment_model_manager.py (after line 193) - Add add_manual_model() and remove_manual_model() methods\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/environment_model_manager.py (line 11) - Add import for ManifestWorkflowModel, ManifestModel\n\n**Files READ (reference only):**\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/models/manifest.py - ManifestWorkflowModel and ManifestModel dataclasses\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/pyproject_manager.py - add_workflow_model(), set_workflow_models(), get_workflow_models() methods\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/repositories/model_repository.py - get_model() returns ModelWithLocation\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-??? (Frontend types/service - different repo)\n\n**Cannot Run In Parallel With:**\n- Backend API bead - needs these methods to exist first\n\n**Blocking Reason:** Backend API endpoint calls these methods\n\n## Estimated Scope\n- **Size:** Small (~60 lines of new code)\n- **Risk:** Low (additive methods, no existing code modified)\n\n## Acceptance Criteria\n- [ ] add_manual_model() creates ManifestWorkflowModel with nodes=[] and status=\"resolved\"\n- [ ] add_manual_model() also adds to global [tool.comfygit.models] table\n- [ ] add_manual_model() raises ValueError if model not in workspace index\n- [ ] add_manual_model() raises ValueError if model already in workflow\n- [ ] remove_manual_model() only removes models with empty nodes[] (manual entries)\n- [ ] remove_manual_model() preserves auto-discovered models with node references\n- [ ] Both methods validate workflow existence\n\n## Testing Requirements\n- Add tests to existing test suite in comfygit core\n- Test: add_manual_model happy path - model appears in workflow manifest\n- Test: add_manual_model duplicate rejection\n- Test: add_manual_model unknown model hash rejection\n- Test: remove_manual_model happy path - only removes manual entry\n- Test: remove_manual_model preserves auto-discovered models","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-30T14:32:15.355813715-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:32:15.355813715-05:00"}
{"id":"cgm-fc1","title":"Backend: HuggingFace search endpoint","notes":"## Context \u0026 Goal\n\nAdd a search endpoint to query HuggingFace Hub for model repositories. This enables the discovery/search UX in the unified modal.\n\n## Current State\n\nNo search endpoint exists. Only `/v2/workspace/huggingface/repo-info` for fetching known repos.\n\n## Target State\n\n**New endpoint in `server/api/v2/models.py`:**\n\n```python\n@routes.get(\"/v2/workspace/huggingface/search\")\n@requires_environment\nasync def huggingface_search(request: web.Request, env) -\u003e web.Response:\n    \"\"\"Search HuggingFace Hub for model repositories.\"\"\"\n    query = (request.query.get(\"query\") or \"\").strip()\n    if len(query) \u003c 2:\n        return web.json_response({\"error\": \"Query must be at least 2 characters\"}, status=400)\n    \n    limit = min(int(request.query.get(\"limit\", 10)), 20)\n    \n    token = os.environ.get(\"HF_TOKEN\") or os.environ.get(\"HUGGINGFACE_TOKEN\")\n    api = HfApi(token=token if token else None)\n    \n    try:\n        models = list(api.list_models(search=query, limit=limit, sort=\"downloads\", direction=-1))\n    except Exception as e:\n        return web.json_response({\"error\": f\"Search failed: {e}\"}, status=500)\n    \n    results = []\n    for m in models:\n        results.append({\n            \"repo_id\": m.id,\n            \"description\": getattr(m, 'description', None) or (m.card_data.description[:200] if hasattr(m, 'card_data') and m.card_data and hasattr(m.card_data, 'description') and m.card_data.description else None),\n            \"downloads\": getattr(m, 'downloads', 0) or 0,\n            \"likes\": getattr(m, 'likes', 0) or 0,\n            \"tags\": getattr(m, 'tags', []) or []\n        })\n    \n    return web.json_response({\"results\": results, \"query\": query})\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/api/v2/models.py - Add new endpoint after line 621 (after existing HF endpoints)\n\n**Files READ (reference only):**\n- server/api/v2/models.py lines 516-621 - Existing HF endpoint patterns\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-xxx (frontend types) - no file overlap\n- All other Phase 1 tasks\n\n**Cannot Run In Parallel With:**\n- None in Phase 1\n\n## Estimated Scope\n- **Size:** Small (~40 lines)\n- **Risk:** Low (isolated new endpoint)\n\n## Acceptance Criteria\n- [ ] GET /v2/workspace/huggingface/search?query=flux returns results\n- [ ] Returns 400 if query \u003c 2 chars\n- [ ] Results include repo_id, description, downloads, likes, tags\n- [ ] Respects limit parameter (max 20)\n\n## Testing Requirements\n- Manual test: `curl \"http://localhost:8188/v2/workspace/huggingface/search?query=flux\"`\n- Add unit test in testing/integration/panel/test_model_endpoints.py","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-28T02:31:57.480391967-05:00","created_by":"ubuntu","updated_at":"2026-01-28T02:41:58.477127944-05:00","closed_at":"2026-01-28T02:41:58.477127944-05:00","close_reason":"Closed"}
{"id":"cgm-fl4","title":"Frontend: Load active-downloads on reconnect and resume paused downloads","notes":"## Context \u0026 Goal\n\nThe backend bead (cgm-bz4) persists download intents to .cec/active-downloads.json and merges them into the /pending-downloads endpoint response. The frontend already calls loadPendingDownloads() on app mount (useModelDownloadQueue.ts:146) which adds items as 'paused'. No frontend code changes are strictly required for the basic flow ‚Äî the backend merge handles it transparently.\n\nHowever, there's an opportunity to improve the UX:\n\n1. Auto-resume downloads that were actively downloading (not just paused) before the restart\n2. Show a notification when pending downloads are restored from a previous session\n3. Ensure the download queue UI properly handles the restored items\n\n## Current State vs Target State\n\n### Current: loadPendingDownloads (useModelDownloadQueue.ts:146-183)\n- Loads from /pending-downloads on mount\n- Adds items as 'paused' status\n- User must manually click resume\n- No awareness of whether items came from pyproject intents vs active-downloads.json\n\n### Target:\n- Same load flow (backend merge is transparent)\n- If restored items have workflow=\"\" (direct downloads, no pyproject backing), auto-resume them instead of pausing\n- Optional: show a toast notification \"Resumed X download(s) from previous session\"\n\n**Modify: useModelDownloadQueue.ts (lines 146-183)**\n\\`\\`\\`typescript\nasync function loadPendingDownloads(): Promise\u003cvoid\u003e {\n  try {\n    const response = await fetch('/v2/comfygit/models/pending-downloads')\n    if (!response.ok) return\n    const data = await response.json()\n    if (!data.pending_downloads || data.pending_downloads.length === 0) return\n\n    let restoredCount = 0\n    for (const item of data.pending_downloads) {\n      if (queue.items.some(i =\u003e i.url === item.url \u0026\u0026 i.filename === item.filename)) continue\n\n      // Direct downloads (no workflow) were likely actively downloading ‚Äî auto-resume\n      const isDirectDownload = !item.workflow\n      const queueItem: DownloadQueueItem = {\n        id: generateId(),\n        workflow: item.workflow,\n        filename: item.filename,\n        url: item.url,\n        targetPath: item.target_path,\n        size: item.size || 0,\n        type: 'model',\n        status: isDirectDownload ? 'queued' : 'paused',\n        progress: 0, downloaded: 0, speed: 0, eta: 0, retries: 0\n      }\n      queue.items.push(queueItem)\n      if (isDirectDownload) restoredCount++\n    }\n\n    if (restoredCount \u003e 0) {\n      console.log(\\`[ComfyGit] Auto-resumed \\${restoredCount} download(s) from previous session\\`)\n      // Optionally show toast\n    }\n    if (queue.status === 'idle' \u0026\u0026 restoredCount \u003e 0) processQueue()\n  } catch (err) {\n    console.warn('[ComfyGit] Failed to load pending downloads:', err)\n  }\n}\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/composables/useModelDownloadQueue.ts (lines 146-183) ‚Äî enhance loadPendingDownloads\n\n**Files READ (reference only):**\n- frontend/src/types/comfygit.ts:707-722 ‚Äî DownloadQueueItem interface (no changes needed)\n- server/api/v2/workflows.py:1411-1452 ‚Äî /pending-downloads response shape\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:** cgm-bz4 (backend bead) ‚Äî no file overlap, frontend only reads the endpoint\n**Cannot Run In Parallel With:** Nothing in current backlog\n**Note:** This bead can be tested independently if the backend returns test data, but for full integration testing, cgm-bz4 should be done first.\n\n## Estimated Scope\n- Size: Small (~30-50 LOC change)\n- Risk: Low ‚Äî modifying existing function, additive logic only\n\n## Acceptance Criteria\n- [ ] Direct downloads (workflow=\"\") are auto-resumed on reconnect, not just paused\n- [ ] Workflow-bound downloads remain paused on reconnect (user reviews before resuming)\n- [ ] Duplicate downloads are still skipped (existing dedup logic preserved)\n- [ ] processQueue() is triggered when auto-resumed items are added\n- [ ] Console log shows count of auto-resumed downloads\n- [ ] Existing loadPendingDownloads behavior unchanged for pyproject-only intents\n\n## Testing Requirements\n- Frontend test: loadPendingDownloads correctly sets status='queued' for items with empty workflow\n- Frontend test: loadPendingDownloads correctly sets status='paused' for items with workflow\n- Frontend test: processQueue is called when auto-resumed items exist\n- Existing frontend tests should still pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-13T01:31:14.923036584-08:00","created_by":"ubuntu","updated_at":"2026-02-13T01:31:14.923036584-08:00","dependencies":[{"issue_id":"cgm-fl4","depends_on_id":"cgm-bz4","type":"blocks","created_at":"2026-02-13T01:31:19.041751874-08:00","created_by":"ubuntu"}]}
{"id":"cgm-ft3","title":"Create HuggingFaceRepoModal.vue component","notes":"## Context \u0026 Goal\n\nCreate the main UI component for browsing HuggingFace repository files. Users can:\n- See all files in a repo with sizes\n- Filter to model files only\n- Auto-select model files (including all shards of sharded models)\n- Choose destination directory from dropdown or enter custom path\n- Queue selected files for download\n\n## Current State vs Target State\n\n**Current**: Component does not exist\n\n**Target** - Create `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/HuggingFaceRepoModal.vue`\n\nThis is a large component (~400 lines). Key features:\n\n**Template Structure:**\n- Modal overlay with close on backdrop click\n- Header: repo name, revision pill\n- Body:\n  - Toolbar: search input, model/all toggle, auto-select/clear buttons\n  - File list: checkbox, path, size columns (needs max-height + scroll)\n  - Destination section: base directory dropdown + subfolder input OR custom path\n  - Summary: selected count + total size\n- Footer: Cancel + Queue Download buttons\n\n**Script Logic:**\n- Props: `show: boolean`, `url: string`\n- Emits: `close`, `queue` (array of download items)\n- Uses: `useComfyGitService` for API calls\n- State: files[], selected Set, destBase, destSubfolder, destCustom\n- Shard detection: regex `/^(.*)-(\\d{4,5})-of-(\\d{4,5})(\\.[^.]+)$/i`\n- Auto-select expands shard groups\n\n**Styling:**\n- Use CSS variables (--cg-color-*, --cg-radius-*, etc.)\n- File list needs `max-height: 300px; overflow-y: auto;` for large repos\n\nSee full implementation in context pack. Key imports:\n```typescript\nimport BaseInput from '@/components/base/BaseInput.vue'\nimport BaseButton from '@/components/base/BaseButton.vue'\nimport BaseSelect from '@/components/base/BaseSelect.vue'\nimport { useComfyGitService } from '@/composables/useComfyGitService'\nimport { buildHfResolveUrl, parseHuggingFaceUrl } from '@/utils/huggingface'\n```\n\n## Files Inventory\n\n**Files MODIFIED:** None\n\n**Files READ:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/components/base/BaseSelect.vue (for SelectOption interface)\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/components/base/BaseInput.vue\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/components/base/BaseButton.vue\n\n**Files CREATED:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/components/HuggingFaceRepoModal.vue\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend beads (different codebase)\n- Core library beads (different codebase)\n\n**Cannot Run In Parallel With:**\n- ModelIndexSection.vue modifications (both in frontend/src/components, but different files - CAN run in parallel)\n\n**Blocking Reason:** ModelIndexSection.vue needs to import and use this component\n\n## Estimated Scope\n- **Size:** Large (~400 lines)\n- **Risk:** Medium (complex UI state management)\n\n## Acceptance Criteria\n- [ ] Component renders modal when show=true\n- [ ] Loads and displays files from API\n- [ ] Model files filter works\n- [ ] Shard group selection works (selecting one selects all)\n- [ ] Auto-select model files button works\n- [ ] Destination dropdown populated from API\n- [ ] Custom path option works\n- [ ] Queue Download button emits correct items array\n- [ ] File list scrollable for large repos (max-height)\n\n## Testing Requirements\n- Manual testing with various HF repos:\n  - Small repo (few files)\n  - Large repo with many files (test scrolling)\n  - Sharded model repo (test auto-selection)\n- Test destination path options\n- Verify emitted download items have correct URLs and paths","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:50:48.224778166-05:00","created_by":"ubuntu","updated_at":"2026-01-27T22:14:14.866098868-05:00","closed_at":"2026-01-27T22:14:14.866098868-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-ft3","depends_on_id":"cgm-v93","type":"blocks","created_at":"2026-01-27T03:52:16.615058485-05:00","created_by":"ubuntu"},{"issue_id":"cgm-ft3","depends_on_id":"cgm-tuo","type":"blocks","created_at":"2026-01-27T03:52:16.62925915-05:00","created_by":"ubuntu"},{"issue_id":"cgm-ft3","depends_on_id":"cgm-huc","type":"blocks","created_at":"2026-01-27T03:52:16.642303176-05:00","created_by":"ubuntu"}]}
{"id":"cgm-hie","title":"Update Missing Dependencies popup UI states and error handling","notes":"## Context \u0026 Goal\n\n**Problem:** After routing through Manager queue (bead cgm-bmt), the UI needs to:\n1. Show \"Queued\" state for packages waiting in queue\n2. Listen for WebSocket events to know when packages finish installing\n3. Show toast errors when installation fails\n4. Trigger restart notification after all packages complete\n\n**Why it matters:** Users need clear feedback on what's happening during installation.\n\n---\n\n## Current State vs Target State\n\n### Current Code\n\n**File:** `frontend/src/components/MissingResourcesPopup.vue`\n\n```vue\n\u003c!-- Template lines 39-48: Button states only show Install/Installing/Installed --\u003e\n\u003cBaseButton\n  v-if=\"!installedPackages.has(pkg.package_id)\"\n  size=\"sm\"\n  variant=\"secondary\"\n  :disabled=\"installingPackage === pkg.package_id\"\n  @click=\"installPackage(pkg.package_id)\"\n\u003e\n  {{ installingPackage === pkg.package_id ? 'Installing...' : 'Install' }}\n\u003c/BaseButton\u003e\n\u003cspan v-else class=\"installed-badge\"\u003eInstalled\u003c/span\u003e\n```\n\n```typescript\n// Script lines 165-170: Only tracks installed and single installing\nconst installedPackages = ref\u003cSet\u003cstring\u003e\u003e(new Set())\nconst installingPackage = ref\u003cstring | null\u003e(null)  // Only one at a time\n```\n\n### Target Code\n\n```vue\n\u003c!-- Template: Show Queued/Installing/Installed/Failed states --\u003e\n\u003ctemplate v-if=\"!installedPackages.has(pkg.package_id)\"\u003e\n  \u003cBaseButton\n    v-if=\"!queuedPackages.has(pkg.package_id) \u0026\u0026 !failedPackages.has(pkg.package_id)\"\n    size=\"sm\"\n    variant=\"secondary\"\n    @click=\"queueInstallPackage(pkg.package_id)\"\n  \u003e\n    Install\n  \u003c/BaseButton\u003e\n  \u003cspan v-else-if=\"queuedPackages.has(pkg.package_id) \u0026\u0026 installingPackage !== pkg.package_id\" \n        class=\"queued-badge\"\u003eQueued\u003c/span\u003e\n  \u003cspan v-else-if=\"installingPackage === pkg.package_id\" \n        class=\"installing-badge\"\u003eInstalling...\u003c/span\u003e\n  \u003cspan v-else-if=\"failedPackages.has(pkg.package_id)\" \n        class=\"failed-badge\" :title=\"failedPackages.get(pkg.package_id)\"\u003e\n    Failed ‚ö†\n  \u003c/span\u003e\n\u003c/template\u003e\n\u003cspan v-else class=\"installed-badge\"\u003eInstalled\u003c/span\u003e\n```\n\n```typescript\n// Script: Add queued and failed tracking, WebSocket listener\nconst queuedPackages = ref\u003cSet\u003cstring\u003e\u003e(new Set())\nconst failedPackages = ref\u003cMap\u003cstring, string\u003e\u003e(new Map())  // package_id -\u003e error message\nconst installingPackage = ref\u003cstring | null\u003e(null)\nconst taskToPackageMap = ref\u003cMap\u003cstring, string\u003e\u003e(new Map())  // ui_id -\u003e package_id\n\n// WebSocket event handlers\nonMounted(() =\u003e {\n  // Listen for Manager task events via ComfyUI's WebSocket\n  const ws = (window as any).comfyAPI?.api?.socket  // or however ComfyUI exposes WS\n  if (ws) {\n    ws.addEventListener('message', handleWebSocketMessage)\n  }\n})\n\nfunction handleWebSocketMessage(event: MessageEvent) {\n  const data = JSON.parse(event.data)\n  \n  if (data.type === 'cm-task-started') {\n    const taskId = data.data?.ui_id\n    const packageId = taskToPackageMap.value.get(taskId)\n    if (packageId) {\n      installingPackage.value = packageId\n    }\n  }\n  \n  if (data.type === 'cm-task-completed') {\n    const taskId = data.data?.ui_id\n    const packageId = taskToPackageMap.value.get(taskId)\n    const status = data.data?.status?.status_str\n    \n    if (packageId) {\n      queuedPackages.value.delete(packageId)\n      installingPackage.value = null\n      \n      if (status === 'success') {\n        installedPackages.value.add(packageId)\n        installedCount.value++\n      } else {\n        failedPackages.value.set(packageId, data.data?.status?.messages?.[0] || 'Unknown error')\n        // Dispatch toast event\n        window.dispatchEvent(new CustomEvent('comfygit:toast', {\n          detail: { message: `Failed to install ${packageId}`, type: 'error' }\n        }))\n      }\n      \n      // Check if all done, trigger restart notification\n      if (queuedPackages.value.size === 0 \u0026\u0026 installedCount.value \u003e 0) {\n        window.dispatchEvent(new CustomEvent('comfygit:nodes-installed', {\n          detail: { count: installedCount.value }\n        }))\n      }\n    }\n  }\n}\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/MissingResourcesPopup.vue` (lines 39-48 template, 165-170 script) - Add UI states, WebSocket listener, error handling\n\n**Files MODIFIED (write):**\n- `frontend/src/main.ts` - Add listener for `comfygit:toast` custom event to show toasts from popup\n\n**Files READ (reference only):**\n- `frontend/src/components/ComfyGitPanel.vue` - Reference for toast format\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:** None\n\n**Cannot Run In Parallel With:** cgm-bmt - REASON: both modify MissingResourcesPopup.vue\n\n**Blocking Reason:** Depends on cgm-bmt being complete (needs queueNodeInstall function)\n\n---\n\n## Estimated Scope\n- **Size:** Medium (~80 lines changed)\n- **Risk:** Low (isolated UI changes)\n\n---\n\n## Acceptance Criteria\n- [ ] Clicking \"Install\" shows \"Queued\" badge immediately\n- [ ] \"Install All\" sets all packages to \"Queued\" state\n- [ ] Cannot double-click Install (button disappears after click)\n- [ ] When queue starts processing, \"Queued\" changes to \"Installing...\" for active package\n- [ ] When package completes successfully, shows \"Installed\" badge\n- [ ] When package fails, shows \"Failed ‚ö†\" badge with tooltip\n- [ ] On failure, toast appears with error message\n- [ ] After all queued packages complete, restart notification appears at bottom\n- [ ] CSS styles added for .queued-badge, .installing-badge, .failed-badge\n\n---\n\n## CSS to Add\n\n```css\n.queued-badge {\n  color: var(--cg-color-warning);\n  font-size: 0.85em;\n}\n\n.installing-badge {\n  color: var(--cg-color-accent);\n  font-size: 0.85em;\n}\n\n.failed-badge {\n  color: var(--cg-color-error);\n  font-size: 0.85em;\n  cursor: help;\n}\n```\n\n---\n\n## Testing Requirements\n- Manual test: Click individual Install button, verify it shows \"Queued\" then \"Installing...\" then \"Installed\"\n- Manual test: Click \"Install All\", verify all buttons show \"Queued\"\n- Manual test: Force an install failure (bad package name?), verify toast appears and \"Failed\" badge shows\n- Manual test: After successful installs, verify restart notification appears","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-24T03:06:51.978625561-05:00","created_by":"ubuntu","updated_at":"2026-01-24T03:14:01.646235766-05:00","closed_at":"2026-01-24T03:14:01.646235766-05:00","close_reason":"Implemented UI states (Queued/Installing/Failed/Installed), WebSocket event handling for cm-task-started and cm-task-completed, proper restart notification timing, and CSS for all badge states.","dependencies":[{"issue_id":"cgm-hie","depends_on_id":"cgm-bmt","type":"blocks","created_at":"2026-01-24T03:06:57.926845166-05:00","created_by":"ubuntu"}]}
{"id":"cgm-huc","title":"Add HuggingFace service methods to useComfyGitService","notes":"## Context \u0026 Goal\n\nAdd two service methods to the composable for calling the new backend endpoints:\n1. `getHuggingFaceRepoInfo(url)` - Fetches repo file listing\n2. `getModelsSubdirectories()` - Fetches available model directories\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit-manager/frontend/src/composables/useComfyGitService.ts`):\nNo HuggingFace-related service methods exist. File ends around line 800+ with return statement.\n\n**Target** - Add after existing model methods (around line 720, after setModelsDirectory), and update return statement:\n\n```typescript\n// Add import at top with other type imports\nimport type { HuggingFaceRepoInfoResponse, ModelsSubdirectoriesResponse } from '@/types/comfygit'\n\n// Add methods (around line 720, after setModelsDirectory)\nasync function getHuggingFaceRepoInfo(url: string): Promise\u003cHuggingFaceRepoInfoResponse\u003e {\n  if (USE_MOCK) {\n    // Return mock data for development\n    return {\n      repo_id: 'mock/repo',\n      revision: 'main',\n      files: [\n        { path: 'model.safetensors', size: 1024 * 1024 * 100, is_model_file: true, shard_group: null }\n      ]\n    }\n  }\n  const params = new URLSearchParams({ url })\n  return fetchApi(\\`/v2/workspace/huggingface/repo-info?\\${params}\\`)\n}\n\nasync function getModelsSubdirectories(): Promise\u003cModelsSubdirectoriesResponse\u003e {\n  if (USE_MOCK) {\n    return {\n      directories: ['checkpoints', 'loras', 'vae', 'controlnet'],\n      standard: ['checkpoints', 'loras', 'vae'],\n      existing: ['checkpoints', 'controlnet']\n    }\n  }\n  return fetchApi('/v2/workspace/models/subdirectories')\n}\n\n// Update return statement to include new methods\nreturn {\n  // ... existing exports ...\n  getHuggingFaceRepoInfo,\n  getModelsSubdirectories,\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/composables/useComfyGitService.ts (add ~30 lines)\n\n**Files READ:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/types/comfygit.ts (for type imports)\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend endpoint bead (different codebase)\n- Core library beads (different codebase)\n\n**Cannot Run In Parallel With:**\n- Any other bead modifying useComfyGitService.ts (none planned)\n\n**Blocking Reason:** HuggingFaceRepoModal.vue needs these methods\n\n## Estimated Scope\n- **Size:** Small (~30 lines)\n- **Risk:** Low (additive methods)\n\n## Acceptance Criteria\n- [ ] Both methods exported from composable\n- [ ] TypeScript compiles without errors\n- [ ] Methods use correct API paths matching backend endpoints\n- [ ] Mock data provided for USE_MOCK mode\n\n## Testing Requirements\n- TypeScript compilation check\n- Manual testing when modal is wired up","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:50:24.720336671-05:00","created_by":"ubuntu","updated_at":"2026-01-27T22:04:57.798021963-05:00","closed_at":"2026-01-27T22:04:57.798021963-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-huc","depends_on_id":"cgm-tuo","type":"blocks","created_at":"2026-01-27T03:52:08.300867382-05:00","created_by":"ubuntu"}]}
{"id":"cgm-i4i","title":"Create HuggingFace URL parser in comfygit-core","notes":"## Context \u0026 Goal\n\nCreate a URL parser module in comfygit-core that distinguishes:\n- Repo browser URLs (`/tree/main`) - need file browser modal\n- Direct file URLs (`/resolve/main/file.safetensors`) - can download directly\n- Invalid/non-HF URLs\n\nThis enables the downloader to reject repo URLs with a helpful error instead of crashing.\n\n## Current State vs Target State\n\n**Current**: No HuggingFace URL parsing exists in core\n\n**Target** - Create `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/services/huggingface_url.py`:\n\n```python\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Literal\nfrom urllib.parse import urlparse\n\nKind = Literal[\"repo\", \"file\", \"unknown\"]\n\n@dataclass(frozen=True)\nclass ParsedHuggingFaceUrl:\n    kind: Kind\n    repo_id: str | None = None\n    revision: str | None = None\n    path_in_repo: str | None = None\n\ndef parse_huggingface_url(url: str) -\u003e ParsedHuggingFaceUrl:\n    \"\"\"Parse a HuggingFace URL into its components.\n    \n    Returns:\n        ParsedHuggingFaceUrl with kind=\"repo\" for browser URLs,\n        kind=\"file\" for direct download URLs, or kind=\"unknown\"\n    \"\"\"\n    u = url.strip()\n    if not u:\n        return ParsedHuggingFaceUrl(kind=\"unknown\")\n\n    try:\n        p = urlparse(u)\n    except Exception:\n        return ParsedHuggingFaceUrl(kind=\"unknown\")\n\n    host = (p.hostname or \"\").lower()\n    if host not in (\"huggingface.co\", \"hf.co\") and not host.endswith(\".huggingface.co\"):\n        return ParsedHuggingFaceUrl(kind=\"unknown\")\n\n    parts = [s for s in p.path.split(\"/\") if s]\n\n    # Ignore datasets/spaces in MVP\n    if not parts or parts[0] in (\"datasets\", \"spaces\"):\n        return ParsedHuggingFaceUrl(kind=\"unknown\")\n\n    if len(parts) \u003c 2:\n        return ParsedHuggingFaceUrl(kind=\"unknown\")\n\n    repo_id = f\"{parts[0]}/{parts[1]}\"\n    revision = \"main\"\n\n    if len(parts) == 2:\n        return ParsedHuggingFaceUrl(kind=\"repo\", repo_id=repo_id, revision=revision)\n\n    marker = parts[2]\n\n    if marker == \"tree\":\n        revision = parts[3] if len(parts) \u003e= 4 else \"main\"\n        return ParsedHuggingFaceUrl(kind=\"repo\", repo_id=repo_id, revision=revision)\n\n    if marker in (\"resolve\", \"blob\"):\n        revision = parts[3] if len(parts) \u003e= 4 else \"main\"\n        path_in_repo = \"/\".join(parts[4:]) if len(parts) \u003e= 5 else \"\"\n        if not path_in_repo:\n            return ParsedHuggingFaceUrl(kind=\"repo\", repo_id=repo_id, revision=revision)\n        return ParsedHuggingFaceUrl(kind=\"file\", repo_id=repo_id, revision=revision, path_in_repo=path_in_repo)\n\n    # Fallback: treat unknown markers as repo\n    return ParsedHuggingFaceUrl(kind=\"repo\", repo_id=repo_id, revision=\"main\")\n```\n\n## Files Inventory\n\n**Files MODIFIED:** None\n\n**Files READ:** None  \n\n**Files CREATED:**\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/services/huggingface_url.py\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-4pl (dependency addition)\n- Frontend URL parser bead\n- Frontend types bead\n\n**Cannot Run In Parallel With:** None\n\n**Blocking Reason:** model_downloader.py update needs this module to import\n\n## Estimated Scope\n- **Size:** Small (~60 lines)\n- **Risk:** Low (new isolated module)\n\n## Acceptance Criteria\n- [ ] Module created at specified path\n- [ ] Handles all URL patterns:\n  - `huggingface.co/owner/repo` ‚Üí kind=\"repo\"\n  - `huggingface.co/owner/repo/tree/main` ‚Üí kind=\"repo\"\n  - `huggingface.co/owner/repo/resolve/main/file.safetensors` ‚Üí kind=\"file\"\n  - `huggingface.co/owner/repo/blob/main/file.safetensors` ‚Üí kind=\"file\"\n  - `civitai.com/...` ‚Üí kind=\"unknown\"\n- [ ] Extracts repo_id, revision, path_in_repo correctly\n\n## Testing Requirements\n- Add unit tests in `/data/projects/comfygit-ai/comfygit/packages/core/tests/unit/services/test_huggingface_url.py`\n- Test each URL pattern listed above","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:49:06.918470451-05:00","created_by":"ubuntu","updated_at":"2026-01-27T15:08:28.081939905-05:00","closed_at":"2026-01-27T15:08:28.081939905-05:00","close_reason":"Moved to comfygit repo as cg-4tw. This bead creates a new module in comfygit-core, not comfygit-manager."}
{"id":"cgm-ian","title":"Show orchestrator warning in panel when unsupervised","description":"## Context \u0026 Goal\n\nWhen a user manually starts a second ComfyUI server while an orchestrator is supervising\nanother environment, the panel UI gives no indication that switching is unsafe. The switch\nbutton is enabled, and clicking it produces a confusing failure (see companion bead for the\nbackend guard).\n\nEven with the backend guard returning HTTP 409, the user experience is poor -- they just see\na generic error toast. This bead adds proactive awareness: the environments list endpoint\nreports orchestrator status, and the frontend shows a clear warning banner explaining the\nsituation BEFORE the user tries to switch.\n\n## Current State vs Target State\n\n### Current: environments list response\n\n**File:** `server/api/v2/environments.py:143-181`\n\n```python\nreturn web.json_response({\n    \"environments\": environments,\n    \"current\": current_env.name if current_env else None,\n    \"is_managed\": True\n})\n```\n\nNo orchestrator awareness.\n\n### Target: add orchestrator fields\n\n```python\n# Detect orchestrator state\norch_info = _get_orchestrator_info(workspace)\n\nreturn web.json_response({\n    \"environments\": environments,\n    \"current\": current_env.name if current_env else None,\n    \"is_managed\": True,\n    \"orchestrator_active\": orch_info[\"active\"],\n    \"orchestrator_environment\": orch_info[\"environment\"],\n    \"is_supervised\": os.environ.get(\"COMFYGIT_SUPERVISED\") == \"1\",\n})\n```\n\nAdd a helper function:\n```python\ndef _get_orchestrator_info(workspace) -\u003e dict:\n    \"\"\"Check if an orchestrator is running for this workspace.\"\"\"\n    metadata_dir = workspace.path / \".metadata\"\n    pid = orchestrator.read_orchestrator_pid(metadata_dir)\n    if pid is not None and orchestrator._is_process_running(pid):\n        # Try to read which environment the orchestrator is managing\n        # This could come from the control port status or switch_status file\n        return {\"active\": True, \"environment\": None}  # env name if discoverable\n    return {\"active\": False, \"environment\": None}\n```\n\nNOTE: The orchestrator's current environment name may not be easily discoverable from\nfile-based state alone. The `.switch_status.json` only exists during switches. The agent\nshould check if there's a simpler way (e.g. the orchestrator control server /health endpoint\nreturns the current environment). If not discoverable, `orchestrator_environment: null` is\nfine -- the important signal is `orchestrator_active: true`.\n\n### Current: EnvironmentSwitcher.vue warning\n\n**File:** `frontend/src/components/EnvironmentSwitcher.vue:7-9`\n\n```html\n\u003cdiv v-if=\"!isManaged\" class=\"warning-banner\"\u003e\n  Not in ComfyGit workspace. Environment switching is disabled.\n\u003c/div\u003e\n```\n\n### Target: add orchestrator warning\n\n```html\n\u003cdiv v-if=\"!isManaged\" class=\"warning-banner\"\u003e\n  Not in ComfyGit workspace. Environment switching is disabled.\n\u003c/div\u003e\n\u003cdiv v-else-if=\"orchestratorActive \u0026\u0026 !isSupervised\" class=\"warning-banner\"\u003e\n  An orchestrator is managing this workspace from another ComfyUI instance.\n  Switch environments from that instance, or stop the orchestrator first.\n\u003c/div\u003e\n```\n\nAnd in the script setup, add refs populated from the list response:\n```typescript\nconst orchestratorActive = ref(false)\nconst isSupervised = ref(false)\n\n// In loadEnvironments():\norchestratorActive.value = response.orchestrator_active === true\nisSupervised.value = response.is_supervised === true\n```\n\nAnd update canSwitch:\n```typescript\nconst canSwitch = computed(() =\u003e {\n  return isManaged.value \u0026\u0026\n         !(orchestratorActive.value \u0026\u0026 !isSupervised.value) \u0026\u0026\n         selectedEnv.value !== currentEnv.value \u0026\u0026\n         !switching.value \u0026\u0026\n         environments.value.length \u003e 0\n})\n```\n\n### Frontend service type update\n\n**File:** `frontend/src/composables/useComfyGitService.ts:449-461`\n\nThe `listEnvironments` return type needs the new fields. Find where the response type is\ndefined and add `orchestrator_active?: boolean` and `is_supervised?: boolean`.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `server/api/v2/environments.py` (lines 143-181) -- add orchestrator fields to list_environments response\n- `frontend/src/components/EnvironmentSwitcher.vue` (lines 7-9, 88-96) -- add warning banner + canSwitch guard\n- `frontend/src/composables/useComfyGitService.ts` (around line 450) -- update response type\n\n**Files READ (reference only):**\n- `server/orchestrator.py` (lines 342-365) -- read_orchestrator_pid, _is_process_running\n- `server/api/v2/orchestrator_proxy.py` -- check if /health endpoint returns env name\n- `frontend/src/components/ComfyGitPanel.vue` -- verify EnvironmentSwitcher usage\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend guard bead (different function in environments.py: list_environments vs switch_environment)\n- Any bead not touching EnvironmentSwitcher.vue or list_environments\n\n**Cannot Run In Parallel With:**\n- Any bead modifying EnvironmentSwitcher.vue\n- Any bead modifying the list_environments function in environments.py\n\n**Blocking Reason:** N/A -- standalone, but logically should come after the backend guard\n\n## Estimated Scope\n- **Size:** Medium (approx 40-60 lines across 3 files + frontend rebuild)\n- **Risk:** Low -- additive changes to response shape and UI, no behavior changes to existing paths\n\n## Acceptance Criteria\n- [ ] GET /v2/comfygit/environments response includes orchestrator_active and is_supervised fields\n- [ ] Frontend shows warning banner when orchestrator_active=true and is_supervised=false\n- [ ] Switch button is disabled when warning is shown\n- [ ] Normal supervised flow (orchestrator_active=true, is_supervised=true) works as before\n- [ ] Unmanaged flow (no orchestrator) works as before\n- [ ] Frontend rebuilt (cd frontend \u0026\u0026 npm run build) and js/ assets committed\n\n## Testing Requirements\n\n**Existing tests:** `testing/integration/panel/test_environment_endpoints.py` tests list_environments.\n\n**New tests needed:**\n1. Test: list_environments with orchestrator PID alive -\u003e response includes orchestrator_active=true\n2. Test: list_environments with no orchestrator -\u003e response includes orchestrator_active=false\n3. Frontend: manual verification that warning banner appears (no automated frontend tests exist)\n\n**IMPORTANT:** After modifying frontend files, run `cd frontend \u0026\u0026 npm run build` to rebuild\nthe js/ assets. The pre-commit hook will block commits if this is forgotten.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-02-02T23:01:05.911166844-05:00","created_by":"ubuntu","updated_at":"2026-02-02T23:10:41.248750171-05:00","closed_at":"2026-02-02T23:10:41.248750171-05:00","close_reason":"Closed"}
{"id":"cgm-io5","title":"Frontend: Types, service layer, and AddModelModal component","notes":"## Context \u0026 Goal\n\nThe frontend needs TypeScript types for the new API, service functions to call the endpoints, and a new modal component where users can browse workspace models and add them to a specific workflow.\n\n## Current State vs Target State\n\n### Types (comfygit.ts)\n\n**Current** (line 337-348): ModelInfo has no is_manual field.\n\n**Target**: Add is_manual to ModelInfo and create request/response types:\n\n\\`\\`\\`typescript\n// Modify ModelInfo (line 337-348) - add is_manual\nexport interface ModelInfo {\n  filename: string\n  hash: string\n  sha256?: string\n  type: string\n  size: number\n  relative_path?: string\n  status: 'available' | 'missing' | 'downloadable' | 'path_mismatch'\n  source_url?: string\n  used_in_environments?: Array\u003c{ env_name: string; workflow_count: number }\u003e\n  used_in_workflows?: string[]\n  is_manual?: boolean  // NEW: true if manually added (no node references)\n}\n\n// NEW: Add after ModelDetails interface (~line 368)\nexport interface AddManualModelRequest {\n  workflow: string\n  model_hash: string\n  criticality: 'required' | 'flexible' | 'optional'\n}\n\nexport interface AddManualModelResult {\n  status: string\n  filename: string\n  category: string\n  criticality: string\n}\n\\`\\`\\`\n\n### Service Layer (useComfyGitService.ts)\n\n**Current** (line 628-704): Model functions exist for get/source/delete/download. No manual add/remove.\n\n**Target**: Add after removeModelSource (~line 691):\n\n\\`\\`\\`typescript\nasync function addManualModel(request: AddManualModelRequest): Promise\u003cAddManualModelResult\u003e {\n  if (USE_MOCK) {\n    return { status: 'success', filename: 'mock.safetensors', category: 'checkpoints', criticality: request.criticality }\n  }\n  return fetchApi\u003cAddManualModelResult\u003e('/v2/comfygit/models/environment/manual', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(request)\n  })\n}\n\nasync function removeManualModel(workflow: string, modelHash: string): Promise\u003c{ status: string }\u003e {\n  if (USE_MOCK) {\n    return { status: 'success' }\n  }\n  return fetchApi('/v2/comfygit/models/environment/manual', {\n    method: 'DELETE',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ workflow, model_hash: modelHash })\n  })\n}\n\\`\\`\\`\n\nAlso add to the return object (~line 1719-1724):\n\\`\\`\\`typescript\naddManualModel,\nremoveManualModel,\n\\`\\`\\`\n\n### AddModelModal Component\n\n**New file**: frontend/src/components/AddModelModal.vue\n\nThis modal allows users to:\n1. Select a target workflow from a dropdown (populated from getWorkflows())\n2. Browse workspace models in a searchable list (from getWorkspaceModels())\n3. Set criticality (required/flexible/optional) via radio buttons\n4. Submit to add the selected model to the chosen workflow\n\n**Component structure:**\n\\`\\`\\`vue\n\u003ctemplate\u003e\n  \u003cBaseModal :show=\"show\" title=\"Add Model to Workflow\" @close=\"$emit('close')\"\u003e\n    \u003c!-- Step 1: Select workflow --\u003e\n    \u003cBaseSelect v-model=\"selectedWorkflow\" label=\"Workflow\" :options=\"workflowOptions\" /\u003e\n    \n    \u003c!-- Step 2: Select criticality --\u003e\n    \u003cBaseRadio v-model=\"criticality\" label=\"Criticality\" :options=\"criticalityOptions\" /\u003e\n    \n    \u003c!-- Step 3: Browse and select workspace model --\u003e\n    \u003cSearchBar v-model=\"modelSearch\" placeholder=\"Search workspace models...\" /\u003e\n    \n    \u003cdiv class=\"model-list\"\u003e\n      \u003cItemCard\n        v-for=\"model in filteredModels\"\n        :key=\"model.hash\"\n        :class=\"{ selected: selectedModel?.hash === model.hash }\"\n        @click=\"selectedModel = model\"\n      \u003e\n        \u003ctemplate #icon\u003eüì¶\u003c/template\u003e\n        \u003ctemplate #title\u003e{{ model.filename }}\u003c/template\u003e\n        \u003ctemplate #subtitle\u003e{{ model.type }} ‚Ä¢ {{ formatSize(model.size) }}\u003c/template\u003e\n        \u003ctemplate #details\u003e\n          \u003cDetailRow label=\"Path:\" :value=\"model.relative_path\" :mono=\"true\" /\u003e\n        \u003c/template\u003e\n      \u003c/ItemCard\u003e\n    \u003c/div\u003e\n    \n    \u003c!-- Actions --\u003e\n    \u003ctemplate #footer\u003e\n      \u003cBaseButton variant=\"secondary\" @click=\"$emit('close')\"\u003eCancel\u003c/BaseButton\u003e\n      \u003cBaseButton \n        variant=\"primary\" \n        :disabled=\"!canSubmit\" \n        :loading=\"submitting\"\n        @click=\"submit\"\n      \u003e\n        Add Model\n      \u003c/BaseButton\u003e\n    \u003c/template\u003e\n  \u003c/BaseModal\u003e\n\u003c/template\u003e\n\\`\\`\\`\n\n**Key behaviors:**\n- Loads workflows on mount via getWorkflows()\n- Loads workspace models on mount via getWorkspaceModels()\n- Filters out models already in the selected workflow (compare hashes with env models)\n- Search filters by filename\n- Emits 'added' event on success so parent can refresh\n- Shows success/error feedback\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/types/comfygit.ts (line 337-348) - Add is_manual to ModelInfo, add AddManualModelRequest/Result types\n- frontend/src/composables/useComfyGitService.ts (~line 691) - Add addManualModel(), removeManualModel() functions + return them\n- frontend/src/services/mockApi.ts - Add mock implementations for addManualModel, removeManualModel\n\n**Files CREATED:**\n- frontend/src/components/AddModelModal.vue - New modal component\n\n**Files READ (reference only):**\n- frontend/src/components/ModelDownloadModal.vue - Reference for modal patterns used in this codebase\n- frontend/src/components/base/BaseModal.vue - Base modal component API\n- frontend/src/components/base/BaseSelect.vue - Select component API\n- frontend/src/components/base/BaseRadio.vue - Radio component API\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend API bead (cgm-94k) - codes against planned API shape, different files/repo\n\n**Cannot Run In Parallel With:**\n- Frontend integration bead - imports AddModelModal\n\n**Blocking Reason:** ModelsEnvSection needs AddModelModal and service functions\n\n## Estimated Scope\n- **Size:** Medium (~150 lines for modal, ~30 lines types, ~25 lines service)\n- **Risk:** Low (new component, additive type changes)\n\n## Acceptance Criteria\n- [ ] ModelInfo type includes optional is_manual field\n- [ ] AddManualModelRequest and AddManualModelResult types defined\n- [ ] addManualModel() and removeManualModel() service functions work\n- [ ] Mock implementations exist for dev mode\n- [ ] AddModelModal loads workflows and workspace models\n- [ ] AddModelModal filters models by search query\n- [ ] AddModelModal validates selection before submit\n- [ ] AddModelModal emits 'added' event on success\n- [ ] Criticality selector defaults to \"required\"\n\n## Testing Requirements\n- Manual testing in dev mode with mock API\n- Verify modal opens/closes cleanly\n- Verify search filtering works\n- Verify submit calls correct API","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-30T14:33:20.989938779-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:33:20.989938779-05:00"}
{"id":"cgm-isl","title":"Enhance MissingResourcesPopup with actionable install/download buttons","description":"## Context \u0026 Goal\n\n**Problem**: The MissingResourcesPopup currently shows raw node‚Üípackage mappings instead of actionable, deduplicated package lists. Users cannot install nodes or download models directly - they must open the full panel.\n\n**Why it matters**: This is the first thing users see when loading a workflow with missing dependencies. It should provide immediate, frictionless resolution options rather than redirecting to another UI.\n\n**Goal**: Transform the popup from a passive notification into an actionable resolution interface with:\n- Deduplicated package list (not node-type mappings)\n- Individual and bulk install/download buttons\n- \"Don't show again\" per-workflow memory\n- Clean UI without emojis\n\n---\n\n## Current State vs Target State\n\n### Current Node Display (WRONG)\n```vue\n\u003c!-- Shows every node type mapped to its package --\u003e\n\u003cdiv v-for=\"node in missingNodes\" class=\"item\"\u003e\n  \u003ccode class=\"node-type\"\u003e{{ node.node_type }}\u003c/code\u003e\n  \u003cspan class=\"package-info\"\u003e‚Üí {{ node.package_title }}\u003c/span\u003e\n\u003c/div\u003e\n```\n\nResult:\n```\nDepthflowMotionPresetCircle ‚Üí ComfyUI-Depthflow-Nodes\nDepthflow ‚Üí ComfyUI-Depthflow-Nodes\n```\n\n### Target Node Display (CORRECT)\n```vue\n\u003c!-- Shows deduplicated packages with install buttons --\u003e\n\u003cdiv v-for=\"pkg in missingPackages\" :key=\"pkg.package_id\" class=\"package-item\"\u003e\n  \u003cspan class=\"package-name\"\u003e{{ pkg.title }}\u003c/span\u003e\n  \u003cspan class=\"node-count\"\u003e({{ pkg.node_count }} nodes)\u003c/span\u003e\n  \u003cBaseButton\n    v-if=\"!queuedPackages.has(pkg.package_id)\"\n    size=\"sm\"\n    @click=\"installPackage(pkg.package_id)\"\n  \u003eInstall\u003c/BaseButton\u003e\n  \u003cspan v-else class=\"queued-badge\"\u003eQueued\u003c/span\u003e\n\u003c/div\u003e\n```\n\nResult:\n```\nComfyUI-Depthflow-Nodes (2 nodes)  [Install]\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/MissingResourcesPopup.vue` (entire file) - main implementation\n\n**Files READ (reference only):**\n- `frontend/src/composables/useModelDownloadQueue.ts` - understand addToQueue() signature\n- `frontend/src/composables/useComfyGitService.ts` - understand installNode() signature\n- `frontend/src/types/comfygit.ts` - type definitions\n\n**Files CREATED:**\n- None\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any backend changes\n- Any other frontend components not importing MissingResourcesPopup\n\n**Cannot Run In Parallel With:**\n- Nothing - this is the only bead for this feature\n\n**Blocking Reason:** N/A (self-contained)\n\n---\n\n## Estimated Scope\n\n- **Size:** Medium (~150-200 lines of changes)\n- **Risk:** Low (isolated popup component, no shared state mutations)\n\n---\n\n## Implementation Details\n\n### 1. New Imports\n```typescript\nimport { useModelDownloadQueue } from '@/composables/useModelDownloadQueue'\nimport { useComfyGitService } from '@/composables/useComfyGitService'\n```\n\n### 2. New Interfaces\n```typescript\ninterface MissingPackage {\n  package_id: string\n  title: string\n  node_count: number\n  node_types: string[]  // for tooltip/debug\n}\n\ninterface MissingModelItem {\n  filename: string\n  widget_value: string\n  url: string | null\n  targetPath: string | null\n  canDownload: boolean\n}\n```\n\n### 3. New State\n```typescript\nconst queuedPackages = ref\u003cSet\u003cstring\u003e\u003e(new Set())\nconst queuedModels = ref\u003cSet\u003cstring\u003e\u003e(new Set())\nconst dontShowAgain = ref(false)\nconst installingPackage = ref\u003cstring | null\u003e(null)  // for loading state\nconst currentWorkflowHash = ref\u003cstring | null\u003e(null)\n```\n\n### 4. New Computed: missingPackages (deduplicated)\n```typescript\nconst missingPackages = computed\u003cMissingPackage[]\u003e(() =\u003e {\n  if (!analysis.value?.nodes) return []\n\n  const packageMap = new Map\u003cstring, MissingPackage\u003e()\n\n  const uninstalledResolved = (analysis.value.nodes.resolved || [])\n    .filter((n: any) =\u003e !n.is_installed \u0026\u0026 n.package?.package_id)\n\n  for (const node of uninstalledResolved) {\n    const pkgId = node.package.package_id\n    if (!packageMap.has(pkgId)) {\n      packageMap.set(pkgId, {\n        package_id: pkgId,\n        title: node.package.title || pkgId,\n        node_count: 0,\n        node_types: []\n      })\n    }\n    const pkg = packageMap.get(pkgId)!\n    pkg.node_count++\n    pkg.node_types.push(node.reference?.node_type || node.node_type)\n  }\n\n  return Array.from(packageMap.values())\n})\n\nconst unresolvedNodes = computed(() =\u003e {\n  if (!analysis.value?.nodes) return []\n  return (analysis.value.nodes.unresolved || []).map((n: any) =\u003e ({\n    node_type: n.reference?.node_type || n.node_type\n  }))\n})\n```\n\n### 5. Updated missingModels computed\n```typescript\nconst missingModels = computed\u003cMissingModelItem[]\u003e(() =\u003e {\n  if (!analysis.value?.models) return []\n\n  const needsDownload = (analysis.value.models.resolved || [])\n    .filter((m: any) =\u003e\n      m.match_type === 'download_intent' ||\n      m.match_type === 'property_download_intent' ||\n      m.match_type === 'not_found'\n    )\n    .map((m: any) =\u003e ({\n      filename: m.reference?.widget_value?.split('/').pop() || m.reference?.widget_value,\n      widget_value: m.reference?.widget_value || m.widget_value,\n      url: m.download_source?.url || null,\n      targetPath: m.download_source?.target_path || null,\n      canDownload: !!(m.download_source?.url \u0026\u0026 m.download_source?.target_path)\n    }))\n\n  return needsDownload\n})\n```\n\n### 6. Action Methods\n```typescript\nconst { addToQueue } = useModelDownloadQueue()\nconst { installNode } = useComfyGitService()\n\nasync function installPackage(packageId: string) {\n  if (queuedPackages.value.has(packageId)) return\n\n  installingPackage.value = packageId\n  try {\n    await installNode(packageId)\n    queuedPackages.value.add(packageId)\n  } catch (e) {\n    console.error('[ComfyGit] Failed to install package:', e)\n  } finally {\n    installingPackage.value = null\n  }\n}\n\nfunction downloadModel(model: MissingModelItem) {\n  if (!model.url || !model.targetPath || queuedModels.value.has(model.url)) return\n\n  addToQueue([{\n    workflow: 'unsaved',\n    filename: model.filename,\n    url: model.url,\n    targetPath: model.targetPath\n  }])\n  queuedModels.value.add(model.url)\n}\n\nfunction installAllNodes() {\n  for (const pkg of missingPackages.value) {\n    if (!queuedPackages.value.has(pkg.package_id)) {\n      installPackage(pkg.package_id)\n    }\n  }\n}\n\nfunction downloadAllModels() {\n  const toDownload = missingModels.value.filter(\n    m =\u003e m.canDownload \u0026\u0026 !queuedModels.value.has(m.url!)\n  )\n  if (toDownload.length === 0) return\n\n  addToQueue(toDownload.map(m =\u003e ({\n    workflow: 'unsaved',\n    filename: m.filename,\n    url: m.url!,\n    targetPath: m.targetPath!\n  })))\n\n  for (const m of toDownload) {\n    queuedModels.value.add(m.url!)\n  }\n}\n\nfunction downloadAll() {\n  installAllNodes()\n  downloadAllModels()\n}\n```\n\n### 7. \"Don't Show Again\" Logic\n```typescript\nfunction getWorkflowHash(workflow: any): string {\n  const nodeTypes = (workflow?.nodes || [])\n    .map((n: any) =\u003e n.type)\n    .sort()\n    .join(',')\n  return btoa(nodeTypes).slice(0, 16)\n}\n\nfunction shouldShowPopup(workflow: any): boolean {\n  const hash = getWorkflowHash(workflow)\n  return localStorage.getItem('comfygit:popup-dismissed:' + hash) !== 'true'\n}\n\nfunction handleDontShowAgainChange() {\n  if (dontShowAgain.value \u0026\u0026 currentWorkflowHash.value) {\n    localStorage.setItem('comfygit:popup-dismissed:' + currentWorkflowHash.value, 'true')\n  }\n}\n```\n\n---\n\n## Acceptance Criteria\n\n- [ ] Missing nodes section shows deduplicated packages (by package_id), not node-type mappings\n- [ ] Each package shows node count (e.g., \"ComfyUI-Depthflow-Nodes (2 nodes)\")\n- [ ] Each package has individual \"Install\" button\n- [ ] Section has \"Install All\" button for bulk node installation\n- [ ] Each downloadable model has individual \"Download\" button\n- [ ] Section has \"Download All\" button for bulk model downloads\n- [ ] Footer has \"Download All\" primary button that queues everything\n- [ ] Buttons show \"Queued\" status after clicked (prevents duplicate queuing)\n- [ ] \"Don't show again\" checkbox persists choice per-workflow to localStorage\n- [ ] No emojis in section titles\n- [ ] Unresolved nodes (not in registry) shown in separate \"Unknown Nodes\" section\n- [ ] Integrates with existing useModelDownloadQueue for model downloads\n- [ ] Integrates with existing useComfyGitService.installNode() for node installation\n\n---\n\n## Testing Requirements\n\n**Manual Testing:**\n1. Load workflow with missing nodes from single package ‚Üí see deduplicated entry\n2. Load workflow with missing nodes from multiple packages ‚Üí see multiple entries\n3. Click individual Install ‚Üí package queued, button changes to \"Queued\"\n4. Click Install All ‚Üí all packages queued\n5. Click individual Download ‚Üí model added to download queue\n6. Click Download All (section) ‚Üí all models in section queued\n7. Click Download All (footer) ‚Üí everything queued\n8. Check \"Don't show again\" ‚Üí dismiss ‚Üí reload same workflow ‚Üí popup shouldn't appear\n9. Load different workflow ‚Üí popup should appear (different hash)\n\n---\n\n## Build \u0026 Verify\n\nAfter implementation:\n```bash\ncd frontend \u0026\u0026 bun run build\n```\n\nThen test in browser with workflow that has missing dependencies.\n","status":"closed","priority":1,"issue_type":"task","assignee":"ubuntu","created_at":"2026-01-23T03:13:37.131460186-05:00","created_by":"ubuntu","updated_at":"2026-01-23T03:20:06.796069031-05:00","closed_at":"2026-01-23T03:20:06.796069031-05:00","close_reason":"Implemented all acceptance criteria: deduplicated packages, Install/Download buttons, bulk actions, 'Don't show again' checkbox with localStorage, no emojis, separate Unknown Nodes section, integration with useModelDownloadQueue and useComfyGitService"}
{"id":"cgm-iuy","title":"Add huggingface_token to APICredentials dataclass","notes":"## Context \u0026 Goal\nAdd HuggingFace token storage to the core library's APICredentials dataclass, following the exact pattern used for civitai_token and runpod_api_key.\n\n**Why it matters:** Users need persistent token storage instead of relying solely on environment variables. This enables the UI to manage HF tokens.\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/models/workspace_config.py:4-34`):\n```python\n@dataclass(repr=False)\nclass APICredentials:\n    \"\"\"Secure storage for external API credentials.\"\"\"\n    civitai_token: str | None = None\n    runpod_api_key: str | None = None\n    # NO huggingface_token field\n```\n\n**Target:**\n```python\n@dataclass(repr=False)\nclass APICredentials:\n    \"\"\"Secure storage for external API credentials.\"\"\"\n    civitai_token: str | None = None\n    runpod_api_key: str | None = None\n    huggingface_token: str | None = None  # NEW\n\n    @classmethod\n    def from_dict(cls, data):\n        if not data:\n            return None\n        return cls(\n            civitai_token=data.get(\"civitai_token\"),\n            runpod_api_key=data.get(\"runpod_api_key\"),\n            huggingface_token=data.get(\"huggingface_token\"),  # NEW\n        )\n\n    def to_dict(self):\n        result = {}\n        if self.civitai_token:\n            result[\"civitai_token\"] = self.civitai_token\n        if self.runpod_api_key:\n            result[\"runpod_api_key\"] = self.runpod_api_key\n        if self.huggingface_token:  # NEW\n            result[\"huggingface_token\"] = self.huggingface_token\n        return result\n\n    def __repr__(self):\n        \"\"\"Obfuscate tokens in logs.\"\"\"\n        parts = []\n        if self.civitai_token:\n            parts.append(f\"civitai_token='***{self.civitai_token[-4:]}'\")\n        if self.runpod_api_key:\n            parts.append(f\"runpod_api_key='***{self.runpod_api_key[-4:]}'\")\n        if self.huggingface_token:  # NEW\n            parts.append(f\"huggingface_token='***{self.huggingface_token[-4:]}'\")\n        return f\"APICredentials({', '.join(parts) if parts else ''})\"\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/models/workspace_config.py` (lines 4-34) - Add huggingface_token field and update serialization\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing in Phase 1 (this is the foundation)\n\n**Cannot Run In Parallel With:**\n- Any bead that modifies workspace_config.py\n\n**Blocking Reason:**\n- Repository methods and model_downloader depend on this field existing\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines)\n- **Risk:** Low (isolated change to data model)\n\n## Acceptance Criteria\n- [ ] `huggingface_token` field exists on APICredentials\n- [ ] `from_dict()` deserializes huggingface_token from JSON\n- [ ] `to_dict()` serializes huggingface_token to JSON\n- [ ] `__repr__()` obfuscates token showing only last 4 chars\n- [ ] Existing tests still pass\n\n## Testing Requirements\n- Run existing core tests: `cd /data/projects/comfygit-ai/comfygit/packages/core \u0026\u0026 uv run pytest tests/ -v`\n- Manual: Create APICredentials with HF token, verify serialization roundtrip\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T15:26:12.417918381-05:00","created_by":"ubuntu","updated_at":"2026-01-29T16:06:07.323133457-05:00","closed_at":"2026-01-29T16:06:07.323133457-05:00","close_reason":"Closed"}
{"id":"cgm-kg0","title":"Add /v2/comfygit/workflow/is-saved endpoint with hash-based detection","notes":"## Context \u0026 Goal\n\n**Problem:** MissingResourcesPopup shows for saved workflows because frontend can't detect if current workflow is saved to disk. The `beforeConfigureGraph` hook only receives raw JSON - no file path/metadata.\n\n**Solution:** Add backend endpoint that compares incoming workflow JSON hash against hashes of all saved workflows in `ComfyUI/user/default/workflows/`.\n\n**Why it matters:** Prevents popup spam for workflows already tracked in ComfyGit panel.\n\n---\n\n## Current State vs Target State\n\n### Current: No endpoint exists\n\n### Target: New endpoint in `server/api/v2/workflows.py`\n\n```python\nimport xxhash\n\n# Cache for disk workflow hashes (invalidated by file watcher)\n_workflow_hash_cache: dict[str, str] = {}  # filename -\u003e hash\n_cache_valid: bool = False\n\ndef invalidate_workflow_hash_cache():\n    \"\"\"Called by file watcher when workflows change.\"\"\"\n    global _cache_valid\n    _cache_valid = False\n\ndef _normalize_workflow(wf: dict) -\u003e dict:\n    \"\"\"Strip volatile fields that don't affect workflow identity.\"\"\"\n    wf = wf.copy()\n    if 'extra' in wf and isinstance(wf['extra'], dict):\n        wf['extra'] = {k: v for k, v in wf['extra'].items() if k != 'ds'}\n    return wf\n\ndef _get_workflow_hash(wf: dict) -\u003e str:\n    \"\"\"Compute xxhash of normalized workflow JSON.\"\"\"\n    normalized = _normalize_workflow(wf)\n    json_str = json.dumps(normalized, sort_keys=True, separators=(',', ':'))\n    return xxhash.xxh64(json_str.encode()).hexdigest()\n\ndef _get_disk_workflow_hashes(workflows_path: Path) -\u003e dict[str, str]:\n    \"\"\"Get hashes of all saved workflows, using cache if valid.\"\"\"\n    global _workflow_hash_cache, _cache_valid\n    \n    if _cache_valid:\n        return _workflow_hash_cache\n    \n    _workflow_hash_cache = {}\n    if workflows_path.exists():\n        for wf_file in workflows_path.glob(\"**/*.json\"):\n            try:\n                with open(wf_file) as f:\n                    data = json.load(f)\n                _workflow_hash_cache[wf_file.name] = _get_workflow_hash(data)\n            except (json.JSONDecodeError, IOError):\n                pass  # Skip invalid files\n    \n    _cache_valid = True\n    return _workflow_hash_cache\n\n@routes.post(\"/v2/comfygit/workflow/is-saved\")\n@requires_environment\nasync def check_workflow_saved(request: web.Request, env) -\u003e web.Response:\n    \"\"\"Check if workflow JSON matches a saved workflow on disk.\"\"\"\n    try:\n        body = await request.json()\n    except Exception:\n        return web.json_response({\"error\": \"Invalid JSON\"}, status=400)\n    \n    workflow_data = body.get(\"workflow\")\n    if not workflow_data or not isinstance(workflow_data, dict):\n        return web.json_response({\"error\": \"Missing workflow\"}, status=400)\n    \n    incoming_hash = _get_workflow_hash(workflow_data)\n    workflows_path = env.comfyui_path / \"user\" / \"default\" / \"workflows\"\n    disk_hashes = _get_disk_workflow_hashes(workflows_path)\n    \n    for filename, disk_hash in disk_hashes.items():\n        if disk_hash == incoming_hash:\n            return web.json_response({\"is_saved\": True, \"filename\": filename})\n    \n    return web.json_response({\"is_saved\": False, \"filename\": None})\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `server/api/v2/workflows.py` - Add endpoint + helper functions (~60 lines)\n- `server/workflow_file_watcher.py` - Add cache invalidation call\n\n**Files READ (reference only):**\n- `server/comfygit_panel.py` - Verify workflows_path pattern\n\n---\n\n## Cache Invalidation Hook\n\nIn `server/workflow_file_watcher.py`, add call to `invalidate_workflow_hash_cache()` in each of the event handlers:\n- `on_modified()` \n- `on_created()`\n- `on_deleted()`\n\nImport from workflows module:\n```python\nfrom server.api.v2.workflows import invalidate_workflow_hash_cache\n```\n\nCall at the start of each handler before the broadcast.\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Frontend bead (cgm-38y) - no file overlap, frontend only reads endpoint\n\n**Cannot Run In Parallel With:**\n- None\n\n---\n\n## Estimated Scope\n- **Size:** Medium (~70 lines)\n- **Risk:** Low (new isolated endpoint, no changes to existing logic)\n\n---\n\n## Acceptance Criteria\n- [ ] `POST /v2/comfygit/workflow/is-saved` returns `{\"is_saved\": true, \"filename\": \"...\"}` for saved workflow\n- [ ] Returns `{\"is_saved\": false, \"filename\": null}` for unsaved/modified workflow\n- [ ] Hash ignores `extra.ds` (viewport state)\n- [ ] Hash cache invalidates when file watcher detects changes\n- [ ] Works with workflows in subfolders (recursive glob)\n\n---\n\n## Testing Requirements\n- Manual test: Load saved workflow, call endpoint, verify `is_saved: true`\n- Manual test: Modify widget value, call endpoint, verify `is_saved: false`\n- Manual test: Save workflow, call endpoint again, verify cache updates","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T22:17:12.669756058-05:00","created_by":"ubuntu","updated_at":"2026-01-26T23:00:19.298442226-05:00","closed_at":"2026-01-26T23:00:19.298442226-05:00","close_reason":"Implemented in sprint run-1769484386145645150. Backend endpoint + frontend integration complete with 7 tests."}
{"id":"cgm-mo7","title":"Block env switch from unsupervised instance when orchestrator active","description":"## Context \u0026 Goal\n\nWhen a user manually starts a second ComfyUI server (e.g. on port 8190) while an orchestrator\nis already supervising another environment (e.g. test1 on port 8189), and they try to \"switch\"\nenvironments from that second server, the switch endpoint calls `os._exit(43)` which kills the\nserver -- but nobody picks up the switch request because the existing orchestrator is waiting\nfor its OWN child process to exit with code 43, not this unrelated process.\n\nResult: the manually-started server dies, the switch request file is orphaned, the lock file\npersists for up to 300 seconds, and the user is left in a broken state with no feedback.\n\n**Goal:** Add a guard in the `switch_environment` API endpoint that detects when the current\nComfyUI process is NOT supervised by an orchestrator but one IS running in the workspace.\nReturn a clear HTTP 409 error instead of proceeding with the doomed switch.\n\n## Current State vs Target State\n\n### Current Code\n\n**File:** `server/api/v2/environments.py:249-339`\n\nThe switch endpoint currently checks:\n1. Target env exists (line 298-303)\n2. Switch lock not held (line 305-310)\n3. Should spawn orchestrator (line 314)\n\nBut it does NOT check: \"Am I supervised by the running orchestrator?\"\n\nLines 312-328 proceed unconditionally:\n```python\n    try:\n        # Spawn orchestrator - always needed when switching from unmanaged\n        if orchestrator.should_spawn_orchestrator_for_switch():\n            spawn_orchestrator(target_env_obj, target_env)\n\n        # Write switch request (source_env may be None for first-time setup)\n        source_env_name = environment.name if environment else None\n        orchestrator.write_switch_request(metadata_dir, target_env, source_env=source_env_name)\n\n        # Schedule exit with code 43 (after response sent)\n        import asyncio\n\n        async def delayed_exit():\n            await asyncio.sleep(2)  # Give response time to send\n            os._exit(SWITCH_ENV_EXIT_CODE)\n\n        asyncio.create_task(delayed_exit())\n```\n\n### Target Code\n\n**File:** `server/api/v2/environments.py` -- add guard after lock acquisition (after line 310), before the try block at line 312:\n\n```python\n    # Check for orphan scenario: orchestrator running but we're not supervised by it\n    if os.environ.get(\"COMFYGIT_SUPERVISED\") != \"1\":\n        orch_pid = orchestrator.read_orchestrator_pid(metadata_dir)\n        if orch_pid is not None and orchestrator._is_process_running(orch_pid):\n            # Release the lock we just acquired since we're aborting\n            lock_file = metadata_dir / \".switch.lock\"\n            lock_file.unlink(missing_ok=True)\n            return web.json_response({\n                \"error\": \"orchestrator_active\",\n                \"message\": (\n                    \"An orchestrator is already managing this workspace. \"\n                    \"Switch environments from the managed ComfyUI instance, \"\n                    \"or stop the orchestrator first.\"\n                )\n            }, status=409)\n```\n\nNOTE: `read_orchestrator_pid` and `_is_process_running` already exist in `server/orchestrator.py`\n(lines 342-365 and used throughout). Check if `_is_process_running` is exported or needs to be\naccessed differently -- it may be a module-level function. The agent should read orchestrator.py\nto confirm the exact function names and signatures.\n\nAlso NOTE: The `workspace_path` code path (line 282-289) is used for first-time setup from an\nunmanaged instance where the user explicitly provides a workspace path. In this case we DO want\nto allow the switch because it spawns a fresh orchestrator. The guard should only apply when\n`COMFYGIT_SUPERVISED != \"1\"` AND an orchestrator is already running. The\n`should_spawn_orchestrator_for_switch()` function already handles this distinction -- if it\nreturns False, an orchestrator exists. So an alternative placement is: if\n`should_spawn_orchestrator_for_switch()` returns False AND `COMFYGIT_SUPERVISED != \"1\"`,\nblock the switch. This is actually cleaner:\n\n```python\n    try:\n        if orchestrator.should_spawn_orchestrator_for_switch():\n            spawn_orchestrator(target_env_obj, target_env)\n        elif os.environ.get(\"COMFYGIT_SUPERVISED\") != \"1\":\n            # Orchestrator exists but we're not its child -- block the switch\n            lock_file = metadata_dir / \".switch.lock\"\n            lock_file.unlink(missing_ok=True)\n            return web.json_response({\n                \"error\": \"orchestrator_active\",\n                \"message\": (\n                    \"An orchestrator is already managing this workspace. \"\n                    \"Switch environments from the managed ComfyUI instance, \"\n                    \"or stop the orchestrator first.\"\n                )\n            }, status=409)\n```\n\nThe implementing agent should choose whichever approach is cleaner after reading the full context.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `server/api/v2/environments.py` (lines 312-316) -- add orchestrator guard to switch_environment\n\n**Files READ (reference only):**\n- `server/orchestrator.py` (lines 158-186) -- should_spawn_orchestrator_for_switch logic\n- `server/orchestrator.py` (lines 342-365) -- read_orchestrator_pid, _is_process_running\n- `server/orchestrator.py` (lines 367-398) -- acquire/release switch lock\n- `testing/integration/panel/test_environment_endpoints.py` -- existing switch tests\n\n**Files CREATED:**\n- None (add test to existing test file)\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any bead not touching server/api/v2/environments.py switch_environment function\n- Frontend-only beads\n\n**Cannot Run In Parallel With:**\n- Any bead modifying switch_environment function in environments.py\n- cgm-74m (switch lock fix) -- both modify switch_environment flow, risk merge conflict\n\n**Blocking Reason:** N/A -- standalone\n\n## Estimated Scope\n- **Size:** Small (approx 15 lines of guard logic + test)\n- **Risk:** Medium -- touches the switch endpoint which is critical path, but the change is additive (early return guard) not a refactor\n\n## Acceptance Criteria\n- [ ] Unsupervised ComfyUI trying to switch while orchestrator active returns HTTP 409\n- [ ] Error message clearly tells user to switch from the managed instance\n- [ ] Supervised ComfyUI (COMFYGIT_SUPERVISED=1) can still switch normally\n- [ ] First-time setup flow (workspace_path provided, no orchestrator) still works\n- [ ] Lock is released if guard triggers (no lock leak)\n- [ ] Existing switch tests still pass\n\n## Testing Requirements\n\n**Existing tests:** `testing/integration/panel/test_environment_endpoints.py` has switch tests.\n\n**New tests needed:**\n1. Test: unsupervised process + orchestrator PID alive -\u003e switch returns 409 with \"orchestrator_active\"\n2. Test: supervised process (COMFYGIT_SUPERVISED=1) + orchestrator PID alive -\u003e switch proceeds normally\n3. Test: unsupervised process + no orchestrator PID -\u003e switch proceeds (spawns orchestrator)\n4. Test: unsupervised process + stale orchestrator PID (dead process) -\u003e switch proceeds\n\nMock `os.environ`, `orchestrator.read_orchestrator_pid`, and `orchestrator._is_process_running`\n(or `should_spawn_orchestrator_for_switch`) as needed. Follow patterns in existing test file.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-02T23:00:58.828675291-05:00","created_by":"ubuntu","updated_at":"2026-02-02T23:10:36.135515314-05:00","closed_at":"2026-02-02T23:10:36.135515314-05:00","close_reason":"Closed"}
{"id":"cgm-n2o","title":"Add 'Models to Download' section in Review step showing download intent details","notes":"# Context \u0026 Goal\n\n## Problem\nThe Review step shows download intents as individual model rows with \"Pending Download\" badge, but doesn't provide a clear summary section showing WHAT will be downloaded. Users should see:\n- Model filename\n- Download URL (truncated)\n- Target path\n- Optionally file size if available\n\n## Why It Matters\nBefore clicking \"Apply Resolution\", users need to understand exactly what will happen. Showing a dedicated \"Models to Download\" section with details gives confidence and transparency.\n\n## How It Serves Project Goals\nClear visibility into pending actions. Users can verify URLs and paths before downloads start.\n\n---\n\n# Current State vs Target State\n\n## Current Code\n\n**File:** `frontend/src/components/WorkflowResolveModal.vue` (lines 248-287)\n\nCurrently shows a generic \"Models\" section that lists all editable models with badges. Download intents show \"Pending Download\" but no URL/path details.\n\n## Target Code (ADD NEW SECTION)\n\nAfter the existing Models section (or replace it for download intents), add:\n\n```vue\n\u003c!-- Download Intent Details Section --\u003e\n\u003cdiv v-if=\"pendingDownloadsForReview.length \u003e 0\" class=\"review-section\"\u003e\n  \u003ch4 class=\"section-title\"\u003eModels to Download ({{ pendingDownloadsForReview.length }})\u003c/h4\u003e\n  \u003cdiv class=\"review-items download-details\"\u003e\n    \u003cdiv\n      v-for=\"download in pendingDownloadsForReview\"\n      :key=\"download.filename\"\n      class=\"review-item download-item\"\n    \u003e\n      \u003cdiv class=\"download-info\"\u003e\n        \u003ccode class=\"item-name\"\u003e{{ download.filename }}\u003c/code\u003e\n        \u003cdiv class=\"download-meta\"\u003e\n          \u003cspan class=\"download-path\"\u003e‚Üí {{ download.target_path }}\u003c/span\u003e\n          \u003cspan v-if=\"download.url\" class=\"download-url\" :title=\"download.url\"\u003e\n            {{ truncateUrl(download.url) }}\n          \u003c/span\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003cspan class=\"choice-badge download\"\u003eWill Download\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\nAdd computed property:\n\n```typescript\nconst pendingDownloadsForReview = computed(() =\u003e {\n  return downloadIntentModels.value.filter(model =\u003e {\n    const choice = modelChoices.value.get(model.filename)\n    // Include if no choice (default = download) or explicit download\n    // Exclude if cancelled/skipped/optional\n    return !choice || choice.action === 'download'\n  }).map(model =\u003e ({\n    filename: model.filename,\n    url: model.download_source,\n    target_path: model.target_path\n  }))\n})\n```\n\nAdd helper:\n\n```typescript\nfunction truncateUrl(url: string, maxLen = 50): string {\n  if (url.length \u003c= maxLen) return url\n  return url.slice(0, maxLen - 3) + '...'\n}\n```\n\n---\n\n# Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/WorkflowResolveModal.vue`\n  - Template: Add new section after line 287\n  - Script: Add pendingDownloadsForReview computed (~line 610)\n  - Script: Add truncateUrl helper function\n  - Styles: Add .download-details, .download-item, .download-meta, .download-url classes\n\n**Files READ (reference only):**\n- `frontend/src/components/WorkflowResolveModal.vue` - downloadIntentModels computed (lines 531-543)\n\n**Files CREATED:**\n- None\n\n---\n\n# Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-447 (different computed properties)\n- comfygit-manager-yah (different section of file)\n\n**Cannot Run In Parallel With:**\n- Any task modifying Review step template (lines 170-292)\n\n**Blocking Reason:**\n- None - this is a leaf task\n\n---\n\n# Estimated Scope\n\n- **Size:** Medium (50-100 lines) - new section + computed + styles\n- **Risk:** Low (additive, doesn't modify existing behavior)\n\n---\n\n# Acceptance Criteria\n\n- [ ] Review step shows \"Models to Download (N)\" section when download intents exist\n- [ ] Each download item shows: filename, target path, truncated URL\n- [ ] Items cancelled/skipped by user don't appear in this section\n- [ ] URL tooltip shows full URL on hover\n- [ ] Section doesn't appear if no downloads pending\n\n---\n\n# Testing Requirements\n\n**Manual Verification:**\n1. Open workflow with download intents\n2. Navigate to Review step\n3. Verify \"Models to Download\" section appears with correct count\n4. Verify each item shows filename, path, and URL\n5. Go back, cancel one download, verify it disappears from section","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-22T14:28:49.75943478-05:00","created_by":"ubuntu","updated_at":"2026-01-22T14:51:36.416082729-05:00","closed_at":"2026-01-22T14:51:36.416082729-05:00","close_reason":"Implemented Models to Download section in Review step with filename, target path, and truncated URL display","dependencies":[{"issue_id":"cgm-n2o","depends_on_id":"cgm-1cj","type":"parent-child","created_at":"2026-01-22T14:30:08.798364804-05:00","created_by":"ubuntu"}]}
{"id":"cgm-n8k","title":"Fix missing status/ui_id in Manager queue WebSocket events","notes":"## Context \u0026 Goal\n\nThe Manager queue system sends WebSocket events (`cm-task-started`, `cm-task-completed`) when custom nodes are installed, but these events are missing critical data that the frontend needs to:\n1. Track which package is being installed\n2. Know when installation succeeded vs failed\n3. Trigger the \"Apply Changes\" restart notification\n\n**Why it matters:** Users install custom nodes but never see the \"Installed\" badge or the restart prompt, leaving them confused about whether installation worked.\n\n---\n\n## Current State vs Target State\n\n### Current Code (`server/comfygit_server.py`)\n\n**Lines 241-244 (cm-task-started):**\n```python\n# Broadcast task started\nPromptServer.instance.send_sync(\"cm-task-started\", {\n    \"state\": get_current_state()\n})\n```\n\n**Lines 266-270 (cm-task-completed):**\n```python\n# Broadcast task completed\nPromptServer.instance.send_sync(\"cm-task-completed\", {\n    \"ui_id\": task_id,\n    \"state\": get_current_state()\n})\n```\n\n### Target Code\n\n**Lines 241-245 (cm-task-started):**\n```python\n# Broadcast task started\nPromptServer.instance.send_sync(\"cm-task-started\", {\n    \"ui_id\": running_task.get(\"ui_id\"),\n    \"state\": get_current_state()\n})\n```\n\n**Lines 266-271 (cm-task-completed):**\n```python\n# Broadcast task completed\nPromptServer.instance.send_sync(\"cm-task-completed\", {\n    \"ui_id\": task_id,\n    \"status\": result,\n    \"state\": get_current_state()\n})\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `server/comfygit_server.py` (lines 241-244 and 266-270) - Add missing fields to WebSocket events\n\n**Files READ (reference only):**\n- `frontend/src/components/MissingResourcesPopup.vue` (lines 582-623) - Understanding what frontend expects\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any frontend-only beads (no file overlap)\n\n**Cannot Run In Parallel With:**\n- Any other beads modifying server/comfygit_server.py\n\n---\n\n## Estimated Scope\n- **Size:** Small (2 lines added)\n- **Risk:** Low (additive change, doesn't modify existing behavior)\n\n---\n\n## Acceptance Criteria\n- [ ] `cm-task-started` event includes `ui_id` field from `running_task`\n- [ ] `cm-task-completed` event includes `status` field with result object containing `status_str`\n- [ ] Frontend shows \"Installed\" badge (not stuck on \"Queued\") after node installs\n- [ ] \"Apply Changes\" restart notification appears after successful install\n- [ ] Console shows `[ComfyGit] Package installed successfully: \u003cpackage_id\u003e` log\n\n---\n\n## Testing Requirements\n\n**Manual testing:**\n1. Load workflow with missing custom nodes\n2. Click \"Install\" on a package in Missing Dependencies popup\n3. Verify badge changes: Install ‚Üí Queued ‚Üí Installed\n4. Verify \"Apply Changes\" toast notification appears at bottom\n5. Click \"Apply Changes\" and verify ComfyUI restarts\n\n**Console verification:**\n- Should see: `[ComfyGit] Installing package: \u003cid\u003e`\n- Should see: `[ComfyGit] Package installed successfully: \u003cid\u003e`","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-28T16:34:49.906120567-05:00","created_by":"ubuntu","updated_at":"2026-01-28T16:38:07.122103824-05:00","closed_at":"2026-01-28T16:38:07.122103824-05:00","close_reason":"Added ui_id to cm-task-started and status to cm-task-completed events"}
{"id":"cgm-nbi","title":"Add incoming commits list to pull preview modal","notes":"## Context \u0026 Goal\nThe pull modal shows \"2 commits from origin/main\" but doesn't list the actual commits. The push modal already shows an \"OUTGOING COMMITS\" list (just implemented). Users need to see what commits they're pulling before they pull, matching the push modal experience.\n\nThe core library already supports `get_version_history(limit, rev_range)` (added in the previous sprint). This bead mirrors the push fix for the pull side.\n\n## Current State vs Target State\n\n### A) Backend: Populate incoming commits (server/api/v2/remotes.py:263-283)\n\n**Current:**\n```python\n# Line 263-283\ncan_pull = not has_uncommitted\nblock_reason = \"uncommitted_changes\" if has_uncommitted else None\n\nchanges = {\n    \"workflows\": {\"added\": [], \"modified\": [], \"deleted\": []},\n    \"nodes\": {\"to_install\": [], \"to_remove\": []},\n    \"models\": {\"referenced\": [], \"count\": 0}\n}\n\nreturn web.json_response({\n    \"remote\": name,\n    \"branch\": branch,\n    \"commits_behind\": sync_status[\"behind\"],\n    \"commits\": [],  # Commit details require git plumbing commands\n    \"changes\": changes,\n    \"has_uncommitted_changes\": has_uncommitted,\n    \"can_pull\": can_pull,\n    \"block_reason\": block_reason\n})\n```\n\n**Target:** Add incoming commits fetch before the response (mirror of push-preview pattern at lines 403-421):\n```python\ncan_pull = not has_uncommitted\nblock_reason = \"uncommitted_changes\" if has_uncommitted else None\n\n# Fetch incoming commits\ncommits_behind = sync_status[\"behind\"]\nif commits_behind \u003e 0:\n    try:\n        incoming = await run_sync(\n            env.git_manager.get_version_history,\n            commits_behind,\n            f\"HEAD..{name}/{branch}\",\n        )\n    except Exception:\n        incoming = []\nelse:\n    incoming = []\n\nchanges = { ... }\n\nreturn web.json_response({\n    \"remote\": name,\n    \"branch\": branch,\n    \"commits_behind\": commits_behind,\n    \"commits\": incoming,\n    ...\n})\n```\n\n**Key difference from push:** The rev range is reversed:\n- Push: `{remote}/{branch}..HEAD` (our commits they don't have)\n- Pull: `HEAD..{remote}/{branch}` (their commits we don't have)\n\nNo first-push fallback needed ‚Äî if we're pulling, the remote branch always exists.\n\n### B) Frontend: Add incoming commits section (PullModal.vue:58-59)\n\n**Current (lines 55-59):**\n```vue\n\u003cdiv class=\"commit-summary\"\u003e\n  \u003cspan class=\"icon\"\u003eüì•\u003c/span\u003e\n  {{ preview.commits_behind }} commit{{ preview.commits_behind !== 1 ? 's' : '' }} from {{ preview.remote }}/{{ preview.branch }}\n\u003c/div\u003e\n```\n\n**Target:** Add INCOMING COMMITS section after the commit-summary div (between lines 58 and 60):\n```vue\n\u003cdiv class=\"commit-summary\"\u003e\n  \u003cspan class=\"icon\"\u003eüì•\u003c/span\u003e\n  {{ preview.commits_behind }} commit{{ preview.commits_behind !== 1 ? 's' : '' }} from {{ preview.remote }}/{{ preview.branch }}\n\u003c/div\u003e\n\n\u003c!-- Incoming commits --\u003e\n\u003cdiv v-if=\"preview.commits \u0026\u0026 preview.commits.length \u003e 0\" class=\"commits-section\"\u003e\n  \u003ch4 class=\"section-title\"\u003eINCOMING COMMITS\u003c/h4\u003e\n  \u003cdiv class=\"commit-list\"\u003e\n    \u003cdiv v-for=\"commit in preview.commits\" :key=\"commit.hash\" class=\"commit-item\"\u003e\n      \u003cspan class=\"commit-hash\"\u003e{{ commit.short_hash || commit.hash.slice(0, 7) }}\u003c/span\u003e\n      \u003cspan class=\"commit-message\"\u003e{{ commit.message }}\u003c/span\u003e\n      \u003cspan class=\"commit-date\"\u003e{{ commit.date_relative || commit.relative_date }}\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\nThis is the exact same template pattern used in PushModal.vue:80-89.\n\n### C) Frontend: Add commit-list CSS (PullModal.vue \u003cstyle scoped\u003e)\n\nPullModal does NOT have these CSS classes yet. Add them to the `\u003cstyle scoped\u003e` section (copy from PushModal.vue:292-343):\n\n```css\n.commits-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--cg-space-2);\n}\n\n.commit-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--cg-space-1);\n  padding: var(--cg-space-3);\n  background: var(--cg-color-bg-secondary);\n  border-radius: var(--cg-radius-sm);\n  max-height: 200px;\n  overflow-y: auto;\n}\n\n.commit-item {\n  display: flex;\n  align-items: center;\n  gap: var(--cg-space-2);\n  font-size: var(--cg-font-size-sm);\n}\n\n.commit-hash {\n  font-family: var(--cg-font-mono);\n  color: var(--cg-color-info);\n  flex-shrink: 0;\n}\n\n.commit-message {\n  color: var(--cg-color-text-primary);\n  flex: 1;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.commit-date {\n  color: var(--cg-color-text-muted);\n  font-size: var(--cg-font-size-xs);\n  flex-shrink: 0;\n}\n```\n\nNOTE: PullModal already has a `.section-title` class (used by \"INCOMING CHANGES\"):\n```css\n/* Already exists in PullModal - check if styles match before duplicating */\n```\nVerify and skip if already present. The `.section-title` IS already used in the changes section (line 62), so it already has styling. Only add the commits-specific classes.\n\n### D) Update tests (test_remotes_endpoints.py + conftest.py)\n\n**test_success_with_incoming_commits (lines 511-532):** Update to mock `get_version_history` and assert commits returned:\n```python\nasync def test_success_with_incoming_commits(self, client, mock_environment):\n    \"\"\"Should return incoming commits and changes preview.\"\"\"\n    mock_environment.git_manager.get_sync_status = Mock(return_value={\n        \"ahead\": 0,\n        \"behind\": 2\n    })\n    mock_environment.git_manager.get_version_history = Mock(return_value=[\n        {\"hash\": \"abc1234\", \"refs\": \"\", \"message\": \"Add new features\", \"date\": \"2025-01-15 11:00:00\", \"date_relative\": \"1 hour ago\"},\n        {\"hash\": \"def5678\", \"refs\": \"\", \"message\": \"Fix bug\", \"date\": \"2025-01-15 10:00:00\", \"date_relative\": \"2 hours ago\"}\n    ])\n    mock_environment.get_current_branch.return_value = \"main\"\n    mock_environment.status.return_value = Mock(git=Mock(has_changes=False))\n\n    resp = await client.get(\"/v2/comfygit/remotes/origin/pull-preview\")\n\n    assert resp.status == 200\n    data = await resp.json()\n    assert data[\"commits_behind\"] == 2\n    assert len(data[\"commits\"]) == 2\n    assert data[\"commits\"][0][\"hash\"] == \"abc1234\"\n    assert data[\"commits\"][0][\"message\"] == \"Add new features\"\n    mock_environment.git_manager.get_version_history.assert_called_once_with(2, \"HEAD..origin/main\")\n```\n\n**conftest.py** already has `get_version_history = Mock(return_value=[])` from the push sprint ‚Äî no change needed.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/api/v2/remotes.py (lines 263-283) - Add incoming commits fetch to pull-preview endpoint\n- frontend/src/components/base/molecules/PullModal.vue (lines 58-59 template, style section) - Add INCOMING COMMITS section + CSS\n- testing/integration/panel/test_remotes_endpoints.py (lines 511-532) - Update test to assert commits\n\n**Files READ (reference only):**\n- frontend/src/components/base/molecules/PushModal.vue (lines 80-89, 292-343) - Reference pattern for template + CSS\n- frontend/src/types/comfygit.ts (PullPreview at 455-478, CommitInfo at 66-74) - Type already includes commits: CommitInfo[]\n- frontend/src/services/mockApi.ts (lines 1189-1249) - Mock already returns sample commits\n\n## Parallelization Info\n\n**Can Run In Parallel With:** Nothing else is queued.\n**Cannot Run In Parallel With:** N/A ‚Äî single bead.\n\n## Estimated Scope\n- **Size:** Medium (~70 lines: ~15 backend, ~25 template, ~25 CSS, ~10 test)\n- **Risk:** Low (mirrors existing push pattern exactly, core library already supports rev_range)\n\n## Acceptance Criteria\n- [ ] Pull preview endpoint returns actual commit objects in the commits array\n- [ ] Each commit has: hash, refs, message, date, date_relative (from get_version_history)\n- [ ] PullModal renders \"INCOMING COMMITS\" section with hash, message, and relative date\n- [ ] Commit list is scrollable with max-height 200px\n- [ ] Zero commits behind = no commits section shown\n- [ ] All existing tests pass: uv run pytest testing/integration/panel/test_remotes_endpoints.py -v\n- [ ] Updated test verifies commits array populated with correct data\n- [ ] Updated test verifies get_version_history called with correct rev_range (HEAD..{remote}/{branch})\n- [ ] Frontend rebuilds: cd frontend \u0026\u0026 npm run build\n\n## Testing Requirements\n- **Existing tests:** testing/integration/panel/test_remotes_endpoints.py::TestPullPreviewEndpoint (5 tests)\n- **Update:** test_success_with_incoming_commits ‚Äî mock get_version_history, assert commits returned and rev_range correct\n- **Manual:** Open pull modal in ComfyUI with a remote that has new commits, verify list renders","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-30T14:23:34.210389361-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:38:13.437259478-05:00","closed_at":"2026-01-30T14:38:13.437259478-05:00","close_reason":"Implemented by sprint run-1769801433734990224"}
{"id":"cgm-nc6","title":"Fix missing dependencies popup showing stale activeWorkflow","notes":"## Context \u0026 Goal\n\n**Problem:** The missing dependencies popup incorrectly skips showing for newly dragged-in workflows because it checks the PREVIOUS workflow's `isPersisted` status instead of the current one.\n\n**Why it matters:** Users who drag in workflows with missing nodes/models don't see the helpful popup that would allow them to install dependencies.\n\n**Root cause:** Timing issue with ComfyUI's workflow loading lifecycle:\n1. User drags in new workflow (e.g., depthflow with 36 missing nodes)\n2. `afterConfigureGraph` fires ‚Üí dispatches `comfygit:workflow-loaded` event\n3. Event handler polls `activeWorkflow` from ComfyUI's store\n4. **BUG:** `activeWorkflow` is still the PREVIOUS workflow (e.g., 6_custom_nodes_7_models)\n5. Previous workflow has `isPersisted=true` ‚Üí popup is skipped\n6. Only AFTER our handler returns does `afterLoadNewGraph()` update `activeWorkflow`\n\n## Current State vs Target State\n\n### Current Code (MissingResourcesPopup.vue, lines ~526-551)\n\n```typescript\nfor (let attempt = 0; attempt \u003c MAX_RETRIES; attempt++) {\n  const activeWorkflow = workflowStore.activeWorkflow\n\n  if (activeWorkflow) {\n    console.log(`[ComfyGit DEBUG] activeWorkflow found on attempt ${attempt + 1}:`, {\n      path: activeWorkflow.path,\n      // ...\n    })\n\n    // BUG: This checks the PREVIOUS workflow, not the one being loaded!\n    if (activeWorkflow.isPersisted === true) {\n      console.log(`[ComfyGit] Active workflow \"${activeWorkflow.filename}\" is saved to disk, skipping popup`)\n      if (workflowId) {\n        shownWorkflowIds.value.add(workflowId)\n      }\n      return\n    }\n    // ...\n  }\n}\n```\n\n### Target Code\n\n```typescript\nfor (let attempt = 0; attempt \u003c MAX_RETRIES; attempt++) {\n  const activeWorkflow = workflowStore.activeWorkflow\n\n  if (activeWorkflow) {\n    // CRITICAL: Verify this is the workflow we're analyzing, not a stale one\n    // ComfyUI's activeWorkflow isn't updated until afterLoadNewGraph() runs,\n    // which happens AFTER our event handler is called\n    const isCorrectWorkflow = activeWorkflow.activeState?.id === workflowId\n    \n    console.log(`[ComfyGit DEBUG] activeWorkflow found on attempt ${attempt + 1}:`, {\n      path: activeWorkflow.path,\n      isPersisted: activeWorkflow.isPersisted,\n      activeWorkflowId: activeWorkflow.activeState?.id,\n      incomingWorkflowId: workflowId,\n      isCorrectWorkflow,\n    })\n\n    if (!isCorrectWorkflow) {\n      // Stale activeWorkflow - keep polling until it updates\n      console.log('[ComfyGit DEBUG] activeWorkflow is stale (ID mismatch), continuing to poll...')\n      if (attempt \u003c MAX_RETRIES - 1) {\n        await new Promise(resolve =\u003e setTimeout(resolve, RETRY_DELAY_MS))\n      }\n      continue\n    }\n\n    // Now we know we're checking the correct workflow\n    if (activeWorkflow.isPersisted === true) {\n      console.log(`[ComfyGit] Active workflow \"${activeWorkflow.filename}\" is saved to disk, skipping popup`)\n      if (workflowId) {\n        shownWorkflowIds.value.add(workflowId)\n      }\n      return\n    } else {\n      console.log('[ComfyGit DEBUG] Workflow is NOT persisted, will show popup')\n      break\n    }\n  }\n\n  // Wait before next attempt\n  if (attempt \u003c MAX_RETRIES - 1) {\n    console.log(`[ComfyGit DEBUG] activeWorkflow not ready, retry ${attempt + 1}/${MAX_RETRIES}...`)\n    await new Promise(resolve =\u003e setTimeout(resolve, RETRY_DELAY_MS))\n  }\n}\n\n// If we exhausted retries without finding correct workflow, show popup (safe default)\nconst finalWorkflow = workflowStore?.activeWorkflow\nif (!finalWorkflow || finalWorkflow.activeState?.id !== workflowId) {\n  console.log('[ComfyGit DEBUG] Could not verify workflow state after retries, proceeding with popup')\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/components/MissingResourcesPopup.vue (lines ~520-570) - Fix ID comparison logic\n\n**Files READ (reference only):**\n- legacy/ComfyUI_frontend/src/platform/workflow/management/stores/workflowStore.ts - Reference for activeState.id\n- legacy/ComfyUI_frontend/src/stores/userFileStore.ts - Reference for isPersisted behavior\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any backend-only changes\n- Any unrelated frontend components\n\n**Cannot Run In Parallel With:**\n- None (isolated change)\n\n**Blocking Reason:** N/A - this is a leaf task\n\n## Estimated Scope\n\n- **Size:** Small (\u003c50 lines changed)\n- **Risk:** Low (isolated to popup logic, has fallback behavior)\n\n## Acceptance Criteria\n\n- [ ] Refreshing browser on a saved workflow does NOT show popup\n- [ ] Dragging in a new workflow WITH missing nodes DOES show popup\n- [ ] Dragging in a new workflow WITHOUT missing nodes does NOT show popup\n- [ ] Console logs show ID comparison: \"activeWorkflowId\" vs \"incomingWorkflowId\"\n- [ ] Console shows \"activeWorkflow is stale (ID mismatch)\" when detecting previous workflow\n\n## Testing Requirements\n\n**Manual Testing:**\n1. Open a saved workflow (e.g., ltx2-audio_to_video_extension_5x.json)\n2. Refresh browser ‚Üí popup should NOT appear\n3. Drag in a workflow with missing nodes (e.g., depthflow_showcase_v2_1.json)\n4. Popup SHOULD appear with missing nodes listed\n5. Check console logs show correct ID comparison behavior\n\n**What to verify in logs:**\n- On refresh: IDs should match, isPersisted=true, popup skipped\n- On drag-in: IDs should initially mismatch, then either match (not persisted) or timeout and show popup\n\n## Experiment Context (from this session)\n\nWe tried 3 approaches:\n\n1. **Hash-based comparison** - Failed because ComfyUI adds runtime fields (`flags`, `bgcolor`, `extra.groupNodes`, etc.) during loading, causing hash mismatches even for identical workflows.\n\n2. **Simple isPersisted check** - Worked for saved workflows but had timing issue: `activeWorkflow` wasn't updated yet when we checked it.\n\n3. **Polling with retries** - Found `activeWorkflow` but it was the PREVIOUS workflow, not the one being loaded.\n\nThe fix is to compare workflow IDs to ensure we're checking the correct workflow, not a stale one.\n\n## Key Discovery\n\nComfyUI workflow lifecycle:\n```\nloadGraphData()\n  ‚îú‚îÄ‚îÄ beforeConfigureGraph hook\n  ‚îú‚îÄ‚îÄ graph.configure()\n  ‚îú‚îÄ‚îÄ afterConfigureGraph hook  ‚Üê We dispatch event here\n  ‚îî‚îÄ‚îÄ afterLoadNewGraph()       ‚Üê activeWorkflow updated here (AFTER our event!)\n```\n\nThis means when our event handler runs, `activeWorkflow` is still pointing to the previous workflow.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-29T02:04:29.984221095-05:00","created_by":"ubuntu","updated_at":"2026-01-29T23:57:55.363718717-05:00","closed_at":"2026-01-29T23:57:55.363718717-05:00","close_reason":"Already implemented - MissingResourcesPopup.vue lines 519-553 have the ID comparison and stale workflow polling logic"}
{"id":"cgm-ncr","title":"Frontend: Add HF search types and service method","notes":"## Context \u0026 Goal\n\nAdd TypeScript types and service method for the HuggingFace search endpoint. Required before frontend components can use search.\n\n## Current State\n\nTypes exist for repo info (lines 1144-1165 in comfygit.ts):\n```typescript\nexport interface HuggingFaceRepoFile { ... }\nexport interface HuggingFaceRepoInfoResponse { ... }\n```\n\nService has `getHuggingFaceRepoInfo()` at line 725.\n\n## Target State\n\n**Add to `frontend/src/types/comfygit.ts` (after line 1165):**\n\n```typescript\nexport interface HuggingFaceSearchResult {\n  repo_id: string\n  description: string | null\n  downloads: number\n  likes: number\n  tags: string[]\n}\n\nexport interface HuggingFaceSearchResponse {\n  results: HuggingFaceSearchResult[]\n  query: string\n}\n```\n\n**Add to `frontend/src/composables/useComfyGitService.ts` (after line 748):**\n\n```typescript\nasync function searchHuggingFaceRepos(query: string, limit = 10): Promise\u003cHuggingFaceSearchResponse\u003e {\n  if (USE_MOCK) {\n    return {\n      query,\n      results: [\n        { repo_id: 'black-forest-labs/FLUX.1-dev', description: 'FLUX.1 development model', downloads: 1200000, likes: 4500, tags: ['text-to-image', 'diffusers'] },\n        { repo_id: 'stabilityai/stable-diffusion-xl-base-1.0', description: 'SDXL base model', downloads: 890000, likes: 3200, tags: ['text-to-image'] }\n      ]\n    }\n  }\n  const params = new URLSearchParams({ query, limit: String(limit) })\n  return fetchApi(`/v2/workspace/huggingface/search?${params}`)\n}\n```\n\n**Add to return object (around line 850):**\n```typescript\nsearchHuggingFaceRepos,\n```\n\n**Add import in types (top of useComfyGitService.ts):**\n```typescript\nimport type { ..., HuggingFaceSearchResponse } from '@/types/comfygit'\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/types/comfygit.ts (after line 1165) - Add search types\n- frontend/src/composables/useComfyGitService.ts (after line 748, line ~850) - Add method + export\n\n**Files READ (reference only):**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-fc1 (backend endpoint) - different codebases\n- All Phase 1 tasks\n\n**Cannot Run In Parallel With:**\n- None in Phase 1\n\n## Estimated Scope\n- **Size:** Small (~30 lines)\n- **Risk:** Low (additive changes)\n\n## Acceptance Criteria\n- [ ] HuggingFaceSearchResult type exported\n- [ ] HuggingFaceSearchResponse type exported\n- [ ] searchHuggingFaceRepos() function available from useComfyGitService()\n- [ ] Mock implementation returns sample data\n- [ ] TypeScript compiles without errors\n\n## Testing Requirements\n- TypeScript compilation: `cd frontend \u0026\u0026 bun run build`\n- Mock mode test in browser dev tools","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-28T02:32:13.551706081-05:00","created_by":"ubuntu","updated_at":"2026-01-28T02:43:53.902212517-05:00","closed_at":"2026-01-28T02:43:53.902212517-05:00","close_reason":"Closed"}
{"id":"cgm-nie","title":"Auto-detect download destination from HF file path","notes":"## Context \u0026 Goal\n\n**Problem:** When downloading models from HuggingFace, users must manually select the download destination (checkpoints, loras, text_encoders, etc.). Many HF repos organize files into subfolders that match ComfyUI model directories (e.g., `split_files/text_encoders/model.safetensors`). Users may accidentally download to the wrong location.\n\n**Solution:** Auto-detect the appropriate destination by parsing the parent directory of selected files and matching against available destination options. This is a **heuristic helper** - if the user explicitly chooses a destination, we respect their choice and stop auto-detecting.\n\n**Behavior:**\n- When user selects file(s), extract parent directory from path\n- If all selected files share the same parent AND it matches a dropdown option ‚Üí auto-switch\n- If user manually clicks dropdown and selects a destination ‚Üí set \"user override\" flag, stop auto-detecting\n- Reset override flag when user clicks \"Back\" to return to search (new repo = fresh context)\n- Clear selection should NOT reset the destination or override flag\n\n---\n\n## Current State vs Target State\n\n### Current Code (HfFileBrowser.vue)\n\n**State declarations (~lines 174-178):**\n```typescript\nconst destBase = ref\u003cstring\u003e('')\nconst destSubfolder = ref\u003cstring\u003e('')\nconst destCustom = ref\u003cstring\u003e('')\n\nconst directories = ref\u003cstring[]\u003e([])\n```\n\n**loadDirectories function (~lines 403-418):**\n```typescript\nasync function loadDirectories() {\n  try {\n    const response = await getModelsSubdirectories()\n    directories.value = response.directories\n    // Default to first directory if available\n    if (response.directories.length \u003e 0 \u0026\u0026 !destBase.value) {\n      destBase.value = response.directories[0]\n    }\n  } catch {\n    // Fallback to common directories\n    directories.value = ['checkpoints', 'loras', 'vae', 'controlnet', 'unet']\n    if (!destBase.value) {\n      destBase.value = 'checkpoints'\n    }\n  }\n}\n```\n\n### Target Code\n\n**New state declarations (add after line 178):**\n```typescript\nconst destBase = ref\u003cstring\u003e('')\nconst destSubfolder = ref\u003cstring\u003e('')\nconst destCustom = ref\u003cstring\u003e('')\nconst directories = ref\u003cstring[]\u003e([])\n\n// Auto-detection state\nconst userOverrodeDestination = ref(false)\nlet autoDetectInProgress = false\n```\n\n**New helper function (add near other helper functions ~line 265):**\n```typescript\n/**\n * Extract the immediate parent directory from a file path.\n * e.g., \"split_files/text_encoders/model.safetensors\" ‚Üí \"text_encoders\"\n */\nfunction getParentDirectory(filePath: string): string | null {\n  const parts = filePath.split('/')\n  if (parts.length \u003e= 2) {\n    return parts[parts.length - 2]\n  }\n  return null\n}\n\n/**\n * Auto-detect destination based on selected files' parent directories.\n * Only runs if user hasn't manually selected a destination.\n */\nfunction autoDetectDestination() {\n  if (userOverrodeDestination.value) return\n  if (selected.value.size === 0) return\n\n  // Extract parent directories from all selected files\n  const parentDirs = new Set\u003cstring\u003e()\n  for (const path of selected.value) {\n    const parent = getParentDirectory(path)\n    if (parent) {\n      parentDirs.add(parent.toLowerCase())\n    }\n  }\n\n  // Only auto-detect if ALL selected files share the same parent\n  if (parentDirs.size !== 1) return\n\n  const detectedDir = [...parentDirs][0]\n  \n  // Find case-insensitive match in available directories\n  const match = directories.value.find(\n    d =\u003e d.toLowerCase() === detectedDir\n  )\n\n  if (match) {\n    autoDetectInProgress = true\n    destBase.value = match\n    nextTick(() =\u003e { autoDetectInProgress = false })\n  }\n}\n```\n\n**Add watcher for selection changes (add after existing watchers ~line 425):**\n```typescript\n// Watch selection changes to auto-detect destination\nwatch(selected, () =\u003e {\n  autoDetectDestination()\n}, { deep: true })\n\n// Watch destBase for user-initiated changes\nwatch(destBase, (newVal, oldVal) =\u003e {\n  // Skip if:\n  // - Our auto-detect is setting the value\n  // - It's the initial load (oldVal is empty)\n  if (autoDetectInProgress || oldVal === '') return\n  \n  userOverrodeDestination.value = true\n})\n```\n\n**Modify handleBack function (~line 181 in parent HuggingFaceTab.vue):**\nThe reset happens in parent - but actually we emit 'back' and parent handles it.\nBetter approach: reset in HfFileBrowser when it's re-mounted with new props.\n\n**Add reset in onMounted or create a reset function:**\n```typescript\n// In HfFileBrowser - reset state when props change (new repo)\nwatch(() =\u003e props.repoId, () =\u003e {\n  userOverrodeDestination.value = false\n  // Note: destBase will be set by loadDirectories or auto-detect\n})\n```\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/download/HfFileBrowser.vue` (lines 131-431)\n  - Add state variables for user override tracking\n  - Add helper functions for parent directory extraction and auto-detection\n  - Add watchers for selection changes and user override detection\n  - Add watcher for repoId changes to reset override flag\n\n**Files READ (reference only):**\n- `frontend/src/components/download/HuggingFaceTab.vue` - understand how back navigation works\n- `frontend/src/components/base/BaseDropdown.vue` - understand v-model emit pattern\n\n**Files CREATED:**\n- None\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any bead not touching HfFileBrowser.vue\n\n**Cannot Run In Parallel With:**\n- Any bead modifying HfFileBrowser.vue\n\n**Blocking Reason:** N/A (no dependents)\n\n---\n\n## Estimated Scope\n\n- **Size:** Small (~40 lines of new code)\n- **Risk:** Low (isolated feature, additive change, no breaking changes)\n\n---\n\n## Acceptance Criteria\n\n- [ ] Selecting a file with parent dir matching dropdown option auto-switches destination\n- [ ] Selecting multiple files with SAME parent dir auto-switches destination\n- [ ] Selecting multiple files with DIFFERENT parent dirs does NOT change destination\n- [ ] Selecting file with parent dir NOT in dropdown does NOT change destination\n- [ ] User clicking dropdown and selecting option sets override flag\n- [ ] After user override, auto-detection stops working\n- [ ] Navigating back and selecting new repo resets override flag\n- [ ] Clear selection does NOT reset destination or override flag\n- [ ] Case-insensitive matching works (e.g., \"Text_Encoders\" matches \"text_encoders\")\n\n---\n\n## Testing Requirements\n\n**Manual testing scenarios:**\n1. Open download modal ‚Üí search for `Comfy-Org/ltx-2` ‚Üí select file under `text_encoders/` ‚Üí verify destination auto-switches\n2. Same as above, but manually select \"checkpoints\" first ‚Üí then select different file ‚Üí verify NO auto-switch\n3. Select multiple files from different parent dirs ‚Üí verify NO auto-switch\n4. Click Back ‚Üí select different repo ‚Üí verify auto-detection works again\n\n**No automated tests needed** - this is UI behavior that's best verified manually. The existing panel API tests don't cover this component's internal logic.\n\n---\n\n## Implementation Notes\n\nThe key insight is using a flag + timing to distinguish programmatic vs user changes:\n- `autoDetectInProgress` flag wraps our programmatic changes\n- Any change to `destBase` outside that flag is a user action\n- `nextTick` ensures the flag clears after Vue processes the change","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-29T01:22:08.069095536-05:00","created_by":"ubuntu","updated_at":"2026-01-29T01:27:44.712909909-05:00","closed_at":"2026-01-29T01:27:44.712909909-05:00","close_reason":"Implemented auto-detect destination from HF file paths with user override tracking"}
{"id":"cgm-obf","title":"Add session-based popup suppression by workflow ID","notes":"## Context \u0026 Goal\n\n**Problem:** After loading a workflow and seeing the popup, if user makes a small change (move a node) without saving, then switches tabs and comes back, the popup appears again. This is because the hash no longer matches the saved version.\n\n**Solution:** Track workflow IDs that have already triggered a popup this browser session. Skip showing popup again for the same workflow ID.\n\n**Behavior:**\n- Browser refresh clears the suppression set (fresh session)\n- Each workflow ID only triggers popup once per session\n- Global \"Don't show popup\" setting remains separate\n\n---\n\n## Implementation\n\n### File: `frontend/src/components/MissingResourcesPopup.vue`\n\n**Add ref** (after line 184):\n```typescript\n// Session-based suppression - workflow IDs that have shown popup this session\nconst shownWorkflowIds = ref\u003cSet\u003cstring\u003e\u003e(new Set())\n```\n\n**Add early return in analyzeWorkflow** (after line 403, before is-saved check):\n```typescript\n// Session suppression: skip if already shown for this workflow ID\nconst workflowId = workflow?.id\nif (workflowId \u0026\u0026 shownWorkflowIds.value.has(workflowId)) {\n  console.log(`[ComfyGit] Already shown popup for workflow ${workflowId} this session`)\n  return\n}\n```\n\n**Add to set when popup shown** (line 454, when `visible.value = true`):\n```typescript\nif (hasIssues.value) {\n  visible.value = true\n  // Remember this workflow ID for session suppression\n  if (workflow?.id) {\n    shownWorkflowIds.value.add(workflow.id)\n  }\n}\n```\n\nNote: Need to pass `workflow` to the inner scope or store it in a ref to access `.id` at that point.\n\n---\n\n## Files Inventory\n\n**Files MODIFIED:**\n- `frontend/src/components/MissingResourcesPopup.vue` (~10 lines)\n\n---\n\n## Acceptance Criteria\n- [ ] Load workflow with missing deps ‚Üí popup shows\n- [ ] Move a node (don't save) ‚Üí switch tabs ‚Üí come back ‚Üí NO popup\n- [ ] Refresh browser ‚Üí load same workflow ‚Üí popup shows again\n- [ ] Load different workflow ‚Üí popup shows if it has issues\n- [ ] Workflow without ID field ‚Üí falls through to existing behavior","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T23:13:02.387361336-05:00","created_by":"ubuntu","updated_at":"2026-01-26T23:14:45.227074116-05:00","closed_at":"2026-01-26T23:14:45.227074116-05:00","close_reason":"Implemented session-based workflow ID suppression"}
{"id":"cgm-onq","title":"Local UV Config Override System","notes":"# Epic: Local UV Config Override System\n\n## Problem\nWhen developers collaborate on ComfyGit environments and have local editable Python package\ndependencies (e.g., comfygit-core = { path = \"/data/projects/.../core\", editable = true }),\nthese machine-specific paths leak into pyproject.toml, get committed, pushed, and then break\nother developers' environments on pull (paths don't exist on their machines).\n\n## Solution\nFollow the existing .pytorch-backend pattern: create a .local-uv-config file in .cec/\nthat is gitignored, stores machine-local UV configuration (sources, indexes), and gets\ninjected temporarily during uv sync via the existing injection context manager pattern.\nAdditionally, strip local path sources at commit time as a safety net.\n\n## Architecture: DRY with PyTorch Injection\n\nThe key insight is that _inject_pytorch_config() (pyproject_manager.py:549-647) already\ndoes generic UV config injection (add indexes, sources, constraints) ‚Äî it just also has\nPyTorch-specific stripping logic interleaved.\n\n### Refactoring Strategy:\n1. EXTRACT: Pull the injection half (lines 590-647) into _inject_uv_overrides(config, overrides)\n2. REFACTOR: _inject_pytorch_config() strips PyTorch entries, then calls _inject_uv_overrides()\n3. REUSE: Local UV config injection also calls _inject_uv_overrides() with the same dict format\n4. UNIFY: Single sync_injection_context() handles both in one snapshot/restore cycle\n\n### Shared Dict Format (both systems produce this):\n```python\n{\n    \"indexes\": [{\"name\": str, \"url\": str, \"explicit\": bool}],\n    \"sources\": {\"package_name\": source_config_dict},\n    \"constraints\": [\"constraint_string\"]\n}\n```\n\n## Design Decisions\n- File format: TOML with [sources] and [[index]] sections\n- Gitignored like .pytorch-backend\n- Injected at sync time using shared _inject_uv_overrides() method\n- Stripped at commit time (safety net, refactored _strip_local_path_sources)\n- Focused on [tool.uv] layer only (not a generic pyproject override)\n- DRY: One injection codepath for both PyTorch and local UV config\n\n## Implementation lives in comfygit-core\nAll changes are in: /data/projects/comfygit-ai/comfygit/packages/core/\n\n## Child Beads\n- cgm-amo: Create LocalUVConfigManager (new manager + gitignore)\n- cgm-51s: Strip local path sources at commit time (safety net)\n- cgm-5kf: Integrate local UV config injection into sync flow (DRY refactor)\n- cgm-asa: Tests for the full feature\n\n## Phase Diagram\n```\nPhase 1 (parallel):\n  cgm-amo: LocalUVConfigManager (NEW file + gitignore)\n  cgm-51s: Commit stripping (environment.py refactor)\n\nPhase 2 (depends on cgm-amo):\n  cgm-5kf: Sync injection DRY refactor (pyproject_manager + uv_project_manager + environment)\n\nPhase 3 (depends on all):\n  cgm-asa: Tests\n```","status":"tombstone","priority":2,"issue_type":"feature","created_at":"2026-01-30T16:45:02.843527404-05:00","created_by":"ubuntu","updated_at":"2026-01-30T17:02:36.898085309-05:00","deleted_at":"2026-01-30T17:02:36.898085309-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"feature"}
{"id":"cgm-oux","title":"Manager: Show override resolution source in UI","description":"When a node is resolved via the global overrides file (node_overrides.json), show '(community override)' or similar indicator in the resolution UI instead of 'Not found in registry'. Optionally allow users to suggest new overrides from the manual resolution modal.","notes":"Cross-repo dependency: requires cg-k1u (GlobalNodeResolver override support) in comfygit core to be completed first.","status":"open","priority":4,"issue_type":"task","created_at":"2026-02-10T15:24:19.340243419-05:00","created_by":"ubuntu","updated_at":"2026-02-10T15:24:30.373051173-05:00"}
{"id":"cgm-q9i","title":"Frontend: Integrate AddModelModal + manual model display in ModelsEnvSection","notes":"## Context \u0026 Goal\n\nModelsEnvSection.vue needs to integrate the new AddModelModal and display manual models with a distinguishing badge, plus allow removal of manually-added models. This is the final user-facing integration piece.\n\n## Current State vs Target State\n\n**Current** (ModelsEnvSection.vue):\n- Line 10-16: Only has \\\"DOWNLOAD +\\\" button in header actions\n- Line 50-67: ItemCard shows models with \\\"View Details\\\" action only\n- Line 169: Destructures only getEnvironmentModels, getStatus from service\n\n**Target changes:**\n\n### 1. Add \\\"ADD MODEL\\\" button next to \\\"DOWNLOAD +\\\" (line 10-16)\n\n\\`\\`\\`vue\n\u003ctemplate #actions\u003e\n  \u003cActionButton variant=\"secondary\" size=\"sm\" @click=\"showAddModelModal = true\"\u003e\n    + ADD MODEL\n  \u003c/ActionButton\u003e\n  \u003cActionButton variant=\"primary\" size=\"sm\" @click=\"showDownloadModal = true\"\u003e\n    \u003c!-- existing download button --\u003e\n  \u003c/ActionButton\u003e\n\u003c/template\u003e\n\\`\\`\\`\n\n### 2. Show \\\"Manual\\\" badge on manually-added models (line 50-67)\n\nIn the ItemCard for each model, add a visual indicator when model.is_manual is true:\n\n\\`\\`\\`vue\n\u003cItemCard\n  v-for=\"model in group.models\"\n  :key=\"model.hash || model.filename\"\n  status=\"synced\"\n\u003e\n  \u003ctemplate #icon\u003eüì¶\u003c/template\u003e\n  \u003ctemplate #title\u003e\n    {{ model.filename }}\n    \u003cspan v-if=\"model.is_manual\" class=\"manual-badge\"\u003eMANUAL\u003c/span\u003e\n  \u003c/template\u003e\n  \u003ctemplate #subtitle\u003e{{ formatSize(model.size) }}\u003c/template\u003e\n  \u003ctemplate #details\u003e\n    \u003cDetailRow label=\"Used by:\" :value=\"(model.used_in_workflows || []).join(', ') || 'Not used'\" /\u003e\n    \u003cDetailRow label=\"Path:\" :value=\"model.relative_path || 'Unknown'\" :mono=\"true\" /\u003e\n  \u003c/template\u003e\n  \u003ctemplate #actions\u003e\n    \u003cActionButton v-if=\"model.is_manual\" variant=\"danger\" size=\"xs\" @click=\"confirmRemoveManual(model)\"\u003e\n      Remove\n    \u003c/ActionButton\u003e\n    \u003cActionButton variant=\"secondary\" size=\"xs\" @click=\"viewDetails(model)\"\u003e\n      View Details\n    \u003c/ActionButton\u003e\n  \u003c/template\u003e\n\u003c/ItemCard\u003e\n\\`\\`\\`\n\n### 3. Add removal confirmation and handler\n\n\\`\\`\\`typescript\nconst showAddModelModal = ref(false)\n\nasync function confirmRemoveManual(model: ModelInfo) {\n  if (!confirm(\\`Remove manually-added model \"${model.filename}\" from this environment?\\`)) return\n  \n  try {\n    // Need to determine which workflow(s) this model was manually added to\n    const workflows = model.used_in_workflows || []\n    for (const wf of workflows) {\n      await removeManualModel(wf, model.hash)\n    }\n    await loadModels()  // Refresh\n  } catch (err) {\n    error.value = err instanceof Error ? err.message : 'Failed to remove model'\n  }\n}\n\\`\\`\\`\n\n### 4. Wire up AddModelModal\n\n\\`\\`\\`vue\n\u003c!-- After ModelDownloadModal --\u003e\n\u003cAddModelModal\n  :show=\"showAddModelModal\"\n  @close=\"showAddModelModal = false\"\n  @added=\"onModelAdded\"\n/\u003e\n\\`\\`\\`\n\n\\`\\`\\`typescript\nfunction onModelAdded() {\n  showAddModelModal.value = false\n  loadModels()  // Refresh the models list\n}\n\\`\\`\\`\n\n### 5. Update service destructuring (line 169)\n\n\\`\\`\\`typescript\nconst { getEnvironmentModels, getStatus, removeManualModel } = useComfyGitService()\n\\`\\`\\`\n\n### 6. Add scoped styles for manual badge\n\n\\`\\`\\`css\n.manual-badge {\n  display: inline-block;\n  font-size: 0.65em;\n  padding: 1px 5px;\n  border-radius: 3px;\n  background: var(--cg-color-info, #3b82f6);\n  color: white;\n  vertical-align: middle;\n  margin-left: 6px;\n  font-weight: 600;\n  letter-spacing: 0.5px;\n}\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/components/ModelsEnvSection.vue - Add button, badge, remove action, modal integration\n\n**Files READ (reference only):**\n- frontend/src/components/AddModelModal.vue - Import and use\n- frontend/src/composables/useComfyGitService.ts - removeManualModel function\n- frontend/src/types/comfygit.ts - ModelInfo.is_manual\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing (depends on all prior beads)\n\n**Cannot Run In Parallel With:**\n- cgm-io5 (Frontend types/modal) - imports AddModelModal from that bead\n- cgm-94k (Backend API) - needs endpoints for remove functionality\n\n**Blocking Reason:** This is the leaf task, nothing depends on it\n\n## Estimated Scope\n- **Size:** Small-Medium (~60 lines of template/script changes + ~15 lines CSS)\n- **Risk:** Medium (modifies existing component, but changes are additive)\n\n## Acceptance Criteria\n- [ ] \\\"ADD MODEL\\\" button visible in ModelsEnvSection header\n- [ ] Clicking \\\"ADD MODEL\\\" opens AddModelModal\n- [ ] Models with is_manual=true show \\\"MANUAL\\\" badge\n- [ ] Manual models have a \\\"Remove\\\" action button\n- [ ] Remove button prompts confirmation before removing\n- [ ] After adding a model via modal, the list refreshes\n- [ ] After removing a model, the list refreshes\n- [ ] Non-manual models do NOT show the badge or remove button\n\n## Testing Requirements\n- Manual testing: Open Models section, verify ADD MODEL button works\n- Manual testing: Add a model via modal, verify it appears with badge\n- Manual testing: Remove a manual model, verify it disappears\n- Frontend build succeeds (cd frontend \u0026\u0026 npm run build)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-30T14:33:49.421584571-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:33:49.421584571-05:00","dependencies":[{"issue_id":"cgm-q9i","depends_on_id":"cgm-io5","type":"blocks","created_at":"2026-01-30T14:33:57.664007812-05:00","created_by":"ubuntu"},{"issue_id":"cgm-q9i","depends_on_id":"cgm-94k","type":"blocks","created_at":"2026-01-30T14:33:57.684806689-05:00","created_by":"ubuntu"}]}
{"id":"cgm-rlc","title":"Manager Update Notice System","description":"## Goal\nShow a subtle update notice inside the ComfyGit Manager panel when a newer **comfygit-manager** version is available, with a link to release notes and clear update instructions. (Optional) provide a one-click self-update.\n\n## Context (Repo Reality Check)\n- Backend routes are aiohttp `web.RouteTableDef()` modules under `server/api/v2/` and are registered in `server/comfygit_panel.py`.\n- Frontend is Vue 3 (Vite) and the panel shell is `frontend/src/components/ComfyGitPanel.vue`.\n- Restart mechanisms already exist:\n  - `GET /v2/manager/reboot` exits with code `42` to trigger orchestrator restart (`server/comfygit_server.py`).\n  - Orchestrator control server exists and is proxied via `POST /v2/comfygit/orchestrator/restart` (`server/api/v2/orchestrator_proxy.py`, `server/orchestrator.py`).\n- comfygit-core provides a `GitHubClient`, but its `GitHubRelease` model does **not** include release body text, so ‚Äúrelease highlights‚Äù requires an extra GitHub API call (or a client change).\n\n## Intended UX\n- On panel open (managed state only), check for updates and, if available, show a dismissable banner.\n- Banner includes:\n  - ‚ÄúComfyGit Manager vX.Y.Z available‚Äù\n  - Short release highlights (optional if available)\n  - Actions: `Update` (if supported) and `Dismiss`, plus a `Release notes` link.\n- Dismiss persists in `localStorage` and only suppresses a specific version (new versions show again).\n\n## Data Source / Truth\nKeep the ‚Äúupdate available‚Äù decision aligned with whatever update mechanism we implement.\n- Preferred: use the same source the updater uses (likely ComfyUI Registry via comfygit-core node resolution).\n- If using GitHub Releases as the source of truth, ensure the updater can actually install that tagged release.\n\n## Non-Goals\n- No background polling while the panel is open (panel-load check is sufficient).\n- No forced updates.\n- No auto-updating unrelated components unless explicitly designed (e.g., comfygit-core, orchestrator).\n\n## Risks / Edge Cases\n- Offline / GitHub rate limiting: must fail silently and never block UI.\n- Version normalization: GitHub tags are typically `vX.Y.Z` while internal versions may be `X.Y.Z`.\n- ‚ÄúDev‚Äù installs: should not spam update banner.\n\n## Acceptance\n- Managed users see a banner when a newer version exists.\n- Dismiss is remembered per-version.\n- When network is unavailable, there is no visible error and no UI slowdown.\n","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-10T14:58:02.418117918-05:00","created_by":"ubuntu","updated_at":"2026-02-10T14:41:28.970879015-08:00"}
{"id":"cgm-rlc.1","title":"Backend: Add version check endpoint","description":"## Summary\nAdd an API endpoint that the panel can call on load to determine whether a newer **comfygit-manager** version is available.\n\n## Endpoint\n- `GET /v2/comfygit/update-check`\n\n## Where This Must Live (Repo Reality)\n- Create a new aiohttp route module under `server/api/v2/` (suggested: `server/api/v2/update_check.py`).\n- Register it in `server/comfygit_panel.py` by importing the module and including its `routes` in the registration loop.\n\n## Response Shape (Stable Contract)\nReturn HTTP 200 with JSON (even on network failure):\n```json\n{\n  \"current_version\": \"0.0.20\",\n  \"latest_version\": \"0.0.21\",\n  \"update_available\": true,\n  \"release_url\": \"https://github.com/comfygit-ai/comfygit-manager/releases/tag/v0.0.21\",\n  \"changelog_summary\": \"...\",\n  \"checked_at\": \"2026-02-10T00:00:00Z\"\n}\n```\nNotes:\n- `latest_version`, `release_url`, `changelog_summary` may be `null` if the check could not be performed.\n- `checked_at` should reflect when the *latest* data was fetched (cached values included).\n\n## How To Determine `current_version`\nPrefer environment-tracked version (works with the actual install mechanism):\n- Use `env.get_manager_status()` (sync method from comfygit-core) and read `current_version`.\nFallbacks if `current_version` is missing/unknown:\n- Parse `pyproject.toml` for this custom node (repo root `pyproject.toml` in deployed copy).\n\n## How To Determine `latest_version` + `release_url`\nThere are two competing ‚Äútruths‚Äù; pick one and be consistent with the updater:\n1. Registry truth (recommended for coherence with update mechanism):\n   - Use `env.get_manager_status()` and read `latest_version` from comfygit-core node lookup.\n2. GitHub Releases truth (matches epic text):\n   - Use `comfygit_core.clients.github_client.GitHubClient` against `https://github.com/comfygit-ai/comfygit-manager`.\n   - Normalize tags like `v0.0.21` ‚Üí `0.0.21` for comparison.\n\nRelease highlights:\n- comfygit-core‚Äôs `GitHubRelease` does **not** include the release body, so `changelog_summary` requires either:\n  - an additional raw GitHub API call to `/releases/latest` to read `body`, or\n  - extending `GitHubClient` to expose `body` (out of scope unless explicitly accepted).\n\n## Caching / Non-Blocking\n- Cache only the ‚Äúlatest release‚Äù lookup server-side with TTL = 24h.\n- Keep `current_version` uncached (it can differ per-environment).\n- Use `cgm_utils.async_helpers.run_sync(...)` for any synchronous GitHub/registry calls so the aiohttp event loop is not blocked.\n- On failures/timeouts/rate-limit errors: return JSON with `update_available=false` and `latest_version=null` (no raised errors to the frontend).\n\n## Acceptance\n- Endpoint is reachable and registered via `server/comfygit_panel.py`.\n- Never 500s due to network problems; always returns JSON.\n- Correctly compares versions (handles `v` prefix, invalid versions, and `dev` cases).\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-02-10T14:58:09.316486583-05:00","created_by":"ubuntu","updated_at":"2026-02-10T14:41:47.424799694-08:00","dependencies":[{"issue_id":"cgm-rlc.1","depends_on_id":"cgm-rlc","type":"parent-child","created_at":"2026-02-10T14:58:09.317950372-05:00","created_by":"ubuntu"}]}
{"id":"cgm-rlc.2","title":"Frontend: Update available banner component","description":"## Summary\nAdd a subtle, dismissable update banner to the ComfyGit panel shell.\n\n## Where In Frontend (Repo Reality)\n- Panel shell: `frontend/src/components/ComfyGitPanel.vue`\n- API service layer: `frontend/src/composables/useComfyGitService.ts`\n- Types live in `frontend/src/types/comfygit.ts`\n\n## Behavior\n- Only runs for managed state (the panel already gates on `getSetupStatus()` in `onMounted`).\n- On panel load (after managed gating), call `GET /v2/comfygit/update-check` once.\n- Show banner when:\n  - `update_available === true`\n  - `latest_version` is present\n  - user has not dismissed this `latest_version`\n\n## Dismiss State\n- Persist in `localStorage` (with try/catch for environments where storage is unavailable).\n- Suggested key: `ComfyGit.UpdateNotice.DismissedVersion` (store the dismissed `latest_version`).\n- Only suppress that exact version; any newer version should re-show.\n\n## UI Content\n- Text: `ComfyGit Manager v{latest_version} available`\n- Optional: `changelog_summary` (truncate to a small number of lines/characters).\n- Actions:\n  - `Update`: behavior depends on whether cgm-rlc.3 exists.\n    - If cgm-rlc.3 is implemented: call it, then prompt/trigger restart via existing `/v2/manager/reboot`.\n    - If not implemented yet: change button to `How to update` and show manual instructions (from endpoint or static copy).\n  - `Release notes`: open `release_url` in a new tab/window.\n  - `Dismiss`: hides banner and saves dismissed version.\n\n## Acceptance\n- Banner appears at the top of the panel (suggested placement: directly under `.panel-header` in `frontend/src/components/ComfyGitPanel.vue`).\n- Banner is non-intrusive and does not change layout significantly.\n- Dismiss persists across panel opens and only applies to the dismissed version.\n- Network/API failures do not show an error banner or break panel load.\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-02-10T14:58:11.562728951-05:00","created_by":"ubuntu","updated_at":"2026-02-10T14:41:58.579023345-08:00","dependencies":[{"issue_id":"cgm-rlc.2","depends_on_id":"cgm-rlc","type":"parent-child","created_at":"2026-02-10T14:58:11.563739093-05:00","created_by":"ubuntu"},{"issue_id":"cgm-rlc.2","depends_on_id":"cgm-rlc.1","type":"blocks","created_at":"2026-02-10T14:58:20.196084188-05:00","created_by":"ubuntu"}]}
{"id":"cgm-rlc.3","title":"Backend: Add self-update endpoint","description":"## Summary\nOptional: add a backend endpoint to self-update **comfygit-manager** and coordinate a restart.\n\n## Critical Assumption Fix\n`pip install --upgrade comfygit-manager` is likely **not** the correct mechanism here:\n- In this repo, manager is installed/loaded as a ComfyUI custom node (often via registry/GitHub checkout under `custom_nodes/`), not as a pip-installed package.\n- The backend already supports updating custom nodes via comfygit-core (`env.update_node(...)`) and has a dedicated manager migration/update flow (`env.update_manager(...)`).\n\n## Proposed Endpoint\n- `POST /v2/comfygit/update`\n\n## Implementation Notes (Repo Reality)\n- Implement as an aiohttp route module under `server/api/v2/` and register in `server/comfygit_panel.py`.\n- Decorators:\n  - Use `@requires_environment` or `@logged_operation(\"update manager\")` (preferred, since this mutates state and should be logged).\n- Use `run_sync(...)` to call sync comfygit-core methods.\n\n## Update Mechanism\n- Prefer calling `env.update_manager(version=\"latest\")` (comfygit-core) to get migration support for legacy installs.\n- If that is not available in the runtime for some reason, fallback to `env.update_node(\"comfygit-manager\")`.\n\n## Restart Coordination\nDo not kill the process mid-response.\n- Return a JSON response including `changed`, `old_version`, `new_version`, and `restart_required=true`.\n- Frontend then triggers restart using existing `GET /v2/manager/reboot` (exit code 42) or `POST /v2/comfygit/orchestrator/restart`.\n\n## Response Shape\n```json\n{\n  \"status\": \"success\",\n  \"changed\": true,\n  \"old_version\": \"0.0.20\",\n  \"new_version\": \"0.0.21\",\n  \"message\": \"Updated from 0.0.20 ‚Üí 0.0.21\",\n  \"restart_required\": true,\n  \"manual_instructions\": null\n}\n```\nOn failure, still return JSON with actionable guidance:\n- `manual_instructions`: e.g. update via the Nodes section, or `cg` CLI steps, or remove/reinstall the custom node.\n\n## Out Of Scope / De-risking\n- Auto-updating `comfygit-core` as part of manager update is high-risk and not currently grounded in existing endpoints.\n  - If a newer manager requires a newer core, return a clear error + manual instructions (and create a follow-up bead to handle coordinated core upgrade).\n\n## Acceptance\n- Endpoint updates manager via comfygit-core mechanisms (not pip).\n- Endpoint returns a result that the frontend can use to show a toast and then restart.\n- Failure does not brick the environment; provides manual instructions.\n","status":"open","priority":4,"issue_type":"task","created_at":"2026-02-10T14:58:14.004238903-05:00","created_by":"ubuntu","updated_at":"2026-02-10T14:42:13.988307046-08:00","dependencies":[{"issue_id":"cgm-rlc.3","depends_on_id":"cgm-rlc","type":"parent-child","created_at":"2026-02-10T14:58:14.005179385-05:00","created_by":"ubuntu"},{"issue_id":"cgm-rlc.3","depends_on_id":"cgm-rlc.1","type":"blocks","created_at":"2026-02-10T14:58:20.299399036-05:00","created_by":"ubuntu"}]}
{"id":"cgm-ru0","title":"Make \"uninstallable\" nodes installable via registry or git","description":"## Epic Goal\n\nTransform \"uninstallable\" (manager-only mapped) nodes from a dead-end blocking state into an actionable state where users can install via the CNR registry (latest version) or via git repository URL.\n\n## Background\n\nCurrently, nodes matched only via ComfyUI Manager mapping data (source: \"manager\") with no known installable versions are categorized as \"uninstallable\" ‚Äî shown as read-only items with no actions. However:\n\n1. The latest CNR registry version of the matched package often *does* contain the node ‚Äî the mapping metadata just hasn't caught up.\n2. The mapping data includes a git repository URL that could be used for direct installation.\n3. The frontend UninstallableNode type already defines package.repository and package.latest_version fields, and the analyze/analyze-json endpoints already serialize them.\n4. queueNodeInstall() sends a repository parameter, but backend process_install() ignores it.\n5. Core's add_node() already accepts both registry IDs and GitHub URLs as identifiers ‚Äî the plumbing gap is only in the manager server layer.\n\n## Scope\n\n### In scope\n- Backend serialization: Enrich workflow-details and nodes-API uninstallable entries with install metadata\n- Backend install plumbing: Wire install_source through process_install, add nodes_uninstallable to apply-resolution, update readiness semantics, semver-safe version extraction\n- Frontend: Add install buttons across all UI surfaces, move uninstallable from \"blocked\" to \"actionable,\" consistent terminology\n- Consistency across MissingResourcesPopup, WorkflowResolveModal, WorkflowDetailsModal, NodesSection, StatusSection, WorkflowsSection\n\n### Out of scope\n- Changes to comfygit-core resolution logic\n- Changes to the node mappings registry data pipeline\n- Trust/security warnings for git installs (future enhancement)\n- Automatic fallback detection (checking if latest registry version actually has the node)\n\n## Child Beads\n\n1. cgm-ru0.1 ‚Äî Backend: Enrich uninstallable node serialization with install metadata (serializers.py + nodes.py)\n2. cgm-ru0.3 ‚Äî Backend: Wire install plumbing (process_install install_source, apply-resolution, readiness semantics, semver helper)\n3. cgm-ru0.2 ‚Äî Frontend: Make uninstallable nodes installable across all UI surfaces\n\n## Design Notes\n\n### Install Source Protocol\n- Backend process_install now requires explicit install_source: \"registry\" | \"git\" to determine behavior\n- Default is \"registry\" ‚Äî no regression from existing repository field presence in payloads\n- Frontend sends install_source: \"git\" ONLY for explicit user-requested git installs\n- This prevents the blocker where MissingResourcesPopup already sends repository in normal install requests\n\n### Install Strategy\n- Default action: \"Install from Registry\" ‚Äî installs latest CNR version via add_node(package_id)\n- Secondary action: \"Install via Git\" ‚Äî installs via add_node(repository_url) with install_source: \"git\"\n- Messaging shift: \"No installable version\" to \"Community-mapped (not verified on registry)\"\n\n### Resolution Flow for Git Installs\n- apply-resolution handles registry installs for uninstallable nodes (package_id strings)\n- Git installs are queued individually via manager queue endpoint (not through apply-resolution)\n- This avoids extending the apply/install contract to carry structured install specs\n\n### Readiness Semantics\n- has_blocked_nodes only considers version_gated nodes (not uninstallable)\n- is_fully_resolved still false when uninstallable nodes present (actionable, not blocked)\n\n## Phase Diagram\n\n- Phase 1 (parallel): cgm-ru0.1, cgm-ru0.3\n- Phase 2 (after Phase 1): cgm-ru0.2\n\n## File Conflict Matrix\n\n- server/cgm_core/serializers.py: owned by cgm-ru0.1\n- server/api/v2/nodes.py: owned by cgm-ru0.1\n- server/api/v2/workflows.py: cgm-ru0.3 (apply-resolution, readiness, semver helper)\n- server/comfygit_server.py: owned by cgm-ru0.3\n- frontend/*: owned by cgm-ru0.2\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-15T16:04:12.303652436-08:00","created_by":"ubuntu","updated_at":"2026-02-15T16:54:36.0877174-08:00","comments":[{"id":3,"issue_id":"cgm-ru0","author":"ubuntu","text":"Audit:\n\nVerdict: NEEDS REVISION\n\nIssues found:\n1. blocker: The epic assumes git installs are already wired through `queueNodeInstall({ repository })`, but the backend ignores `repository` today. `frontend/src/composables/useComfyGitService.ts` sends it, but `server/comfygit_server.py` `process_install()` installs only from `params.id`.\n2. blocker: The current resolution apply flow cannot execute uninstallable-node choices end-to-end. `server/api/v2/workflows.py` `apply_resolution` computes `nodes_to_install` from `result.nodes_resolved` only; `nodes_uninstallable` are not included in install planning.\n3. concern: Backend still treats uninstallable nodes as blocking readiness (`is_fully_resolved` false when uninstallable exists) in both analyze endpoints. That conflicts with the epic‚Äôs ‚Äúactionable with caveats‚Äù rule.\n4. concern: ‚ÄúLatest version‚Äù behavior is underspecified. Without semver-safe extraction, UI could show/install wrong ‚Äúlatest‚Äù version.\n\nSuggestions:\n- Add an explicit backend prerequisite for install-source handling (registry vs git) in manager queue processing (or define that git installs pass repository URL as `id`).\n- Add backend support for uninstallable install actions in the apply-resolution pipeline.\n- Define canonical semantics for stats/readiness (`blocked`, `is_fully_resolved`, summary text) when uninstallable nodes are present.\n","created_at":"2026-02-16T00:10:45Z"},{"id":6,"issue_id":"cgm-ru0","author":"ubuntu","text":"Re-audit:\n\nVerdict: NEEDS REVISION\n\nIssues found:\n1. blocker: The new `process_install` plan in `server/comfygit_server.py` prefers `repository` whenever present. Current frontend calls (`frontend/src/components/MissingResourcesPopup.vue:481`) already send `repository` for normal package installs, so this would silently flip default registry installs to git installs.\n2. blocker: The workflow-resolution install path still cannot execute \"Install via Git\" end-to-end. `apply_resolution`/`apply_resolution_stream` currently return `nodes_to_install: string[]`, and `/v2/comfygit/workflow/{name}/install` installs via `env.add_node(node_id)` only (`server/api/v2/workflows.py:706-746`), with no repository identifier transport.\n3. concern: \"latest_version\" remains order-dependent in analyze/analyze-json helpers (`server/api/v2/workflows.py:126-130`), so semver safety is still not guaranteed where frontend install choices are sourced.\n4. nit: File conflict note still references \".1b\" instead of \".3\" in the epic text.\n\nSuggestions:\n- Add explicit install source semantics (`source: registry|git`) and only use `repository` when source is git.\n- Extend workflow apply/install contracts to carry install specs (`id`, `repository`, `version`) instead of plain package-ID strings.\n- Use one semver-safe latest-version helper shared by `workflows.py` and serializer endpoints.\n","created_at":"2026-02-16T00:35:22Z"}]}
{"id":"cgm-ru0.1","title":"Backend: Enrich uninstallable node serialization with install metadata","description":"## Goal\n\nEnrich uninstallable node serialization in workflow-details and nodes APIs with install metadata (package_id, repository, latest_version) so the frontend can offer install actions.\n\n## Current State\n\nThe analyze/analyze-json endpoints already serialize uninstallable nodes with full metadata via _serialize_uninstallable_node() ‚Äî this helper already returns package.package_id, package.repository, and package.latest_version.\n\nHowever, two other API surfaces do NOT include this metadata:\n\n1. serialize_workflow_details() in serializers.py ‚Äî returns only {name, version, status, guidance} for uninstallable nodes\n2. /v2/comfygit/nodes API in nodes.py ‚Äî blocked_map includes registry_id but not repository\n\n## Changes Required\n\n### server/cgm_core/serializers.py\n\nIn serialize_workflow_details(), enrich uninstallable node entries to include install metadata. The node data comes from ResolvedNodePackage which has package_id, package_data.repository, and package_data.versions.\n\nAdd fields:\n- package_id: from node.package_id\n- repository: from node.package_data.repository\n- latest_version: extracted from node.package_data.versions using semver-safe comparison\n\n### server/api/v2/nodes.py\n\nAdd repository to the blocked node response for uninstallable nodes. The package_data object is available on the ResolvedNodePackage ‚Äî extract repository from it.\n\n### Semver-safe version extraction\n\nCreate a shared helper (e.g., in a utils module or inline) that uses packaging.version.Version for safe latest-version extraction with fallback:\n\n    from packaging.version import Version, InvalidVersion\n    \n    def _get_latest_version_safe(versions_dict):\n        if not versions_dict:\n            return None\n        try:\n            return str(max(versions_dict.keys(), key=lambda v: Version(v)))\n        except (InvalidVersion, ValueError):\n            return sorted(versions_dict.keys(), reverse=True)[0] if versions_dict else None\n\nNote: packaging is already a dependency of comfygit-core.\n\n### Coordination note\n\nThe existing _get_latest_package_version() helper in server/api/v2/workflows.py (line ~126-130) also extracts latest versions but is NOT semver-safe. cgm-ru0.3 should update that helper to use the same semver-safe approach for consistency. Reference this in the cgm-ru0.3 implementation.\n\n### server/api/v2/workflows.py (verification only)\n\nVerify that the analyze and analyze-json endpoints already serialize full uninstallable metadata via _serialize_uninstallable_node(). No changes expected ‚Äî just confirm.\n\n## Acceptance Criteria\n\n- [ ] Workflow details API (serializers.py) returns package_id, repository, and latest_version for uninstallable nodes\n- [ ] Nodes API returns repository for uninstallable blocked nodes\n- [ ] Version extraction uses semver-safe comparison with fallback\n- [ ] All new fields are additive (null when unavailable) ‚Äî no breaking changes\n- [ ] Existing tests updated, new unit tests for enriched serialization in test_serializers.py and test_node_endpoints.py\n- [ ] No changes to core library ‚Äî only manager backend\n\n## File Ownership\n\n- server/cgm_core/serializers.py ‚Äî owned (uninstallable serialization enrichment)\n- server/api/v2/nodes.py ‚Äî owned (blocked node repository field)\n- server/api/v2/workflows.py ‚Äî read-only verification only\n- testing/ ‚Äî test updates\n","status":"in_progress","priority":2,"issue_type":"task","created_at":"2026-02-15T16:04:29.046586276-08:00","created_by":"ubuntu","updated_at":"2026-02-15T16:59:51.941239671-08:00","dependencies":[{"issue_id":"cgm-ru0.1","depends_on_id":"cgm-ru0","type":"parent-child","created_at":"2026-02-15T16:04:29.047532371-08:00","created_by":"ubuntu"}],"comments":[{"id":4,"issue_id":"cgm-ru0.1","author":"ubuntu","text":"Audit:\n\nVerdict: PASS WITH NOTES\n\nIssues found:\n1. concern: `server/api/v2/workflows.py` already serializes uninstallable package metadata (`package_id`, `repository`, `latest_version`) for `/workflow/{name}/analyze` and `/workflow/analyze-json`. The bead currently overstates missing work there.\n2. concern: Proposed latest-version helper (`sorted(..., reverse=True)[0]`) is not semver-safe and can misorder versions (for example, lexical ordering pitfalls).\n3. concern: Real backend gaps are in `server/cgm_core/serializers.py` (workflow details uninstallable entries missing install metadata) and `server/api/v2/nodes.py` (blocked uninstallable nodes do not include repository).\n4. nit: Test path assumptions should reference existing files (`testing/unit/test_serializers.py`, `testing/integration/panel/test_node_endpoints.py`, `testing/integration/panel/test_workflow_endpoints.py`).\n\nSuggestions:\n- Narrow this task to serializer + nodes blocked-map enrichment and associated tests.\n- Use semver-aware latest extraction (`packaging.version.Version`) with safe fallback for non-semver tags.\n- Keep response changes additive (`null` when unavailable) to avoid frontend breakage before cgm-ru0.2 lands.\n","created_at":"2026-02-16T00:10:51Z"},{"id":7,"issue_id":"cgm-ru0.1","author":"ubuntu","text":"Re-audit:\n\nVerdict: PASS WITH NOTES\n\nIssues found:\n1. concern: Scope narrowing to `server/cgm_core/serializers.py` + `server/api/v2/nodes.py` correctly addresses missing metadata on those surfaces, but semver-safe `latest_version` still matters in analyze/analyze-json output used by frontend flows. Current helper in `server/api/v2/workflows.py:126-130` still uses first-key ordering.\n2. nit: If semver-safe extraction is implemented only in serializers, backend surfaces may diverge on `latest_version` behavior.\n\nSuggestions:\n- Keep this bead focused on serializers/nodes as planned, but add a follow-up (or explicit coordination note with `cgm-ru0.3`) to apply the same semver-safe helper in `server/api/v2/workflows.py`.\n- Ensure tests cover additive null-safe fields in both `testing/unit/test_serializers.py` and `testing/integration/panel/test_node_endpoints.py`.\n","created_at":"2026-02-16T00:35:29Z"}]}
{"id":"cgm-ru0.2","title":"Frontend: Make uninstallable nodes installable across all UI surfaces","description":"## Goal\n\nUpdate all frontend surfaces to treat uninstallable nodes as actionable (installable via registry or git) rather than blocked. Provide consistent install UX across MissingResourcesPopup, WorkflowResolveModal, WorkflowDetailsModal, NodesSection, and summary sections.\n\n## Dependencies\n\n- cgm-ru0.1: Backend serialization enrichment (provides package_id, repository, latest_version in API responses)\n- cgm-ru0.3: Backend install plumbing (process_install respects install_source, apply-resolution includes uninstallable nodes, readiness semantics updated)\n\n## Install Source Protocol\n\nThe backend now expects an explicit `install_source` field to distinguish registry vs git installs:\n- `install_source: \"registry\"` (default) ‚Äî installs via package_id from CNR\n- `install_source: \"git\"` ‚Äî installs via repository URL using core's add_node(github_url)\n\nFrontend MUST send `install_source: \"git\"` only when the user explicitly requests a git install. Default installs should NOT include install_source (or send \"registry\"). This prevents the regression where the existing `repository` field in install payloads could accidentally trigger git installs.\n\n## Changes Required\n\n### 1. MissingResourcesPopup.vue\n\nSection title: Change \"No Installable Package Version (X)\" to \"Community-Mapped Packages (X)\"\n\nPer-package display: Group by package_id (like missing custom nodes section), show:\n- Package title/id\n- Node count\n- Guidance text: \"Found via community mapping ‚Äî registry metadata may be incomplete\"\n- Install button (default): \"Install\" calls queueNodeInstall({ id: package_id, version: latest_version })\n- Git install option: If repository URL available, show secondary \"Install via Git\" link/button calling queueNodeInstall({ id: package_id, repository: repository, install_source: \"git\" })\n- Same state tracking as existing packages: queued/installing/installed/failed badges\n\nBulk action: \"Install All\" should include these packages (defaulting to registry installs, no install_source field).\n\n### 2. WorkflowResolveModal.vue ‚Äî Analysis Step\n\nRemove from \"Blocked Issues\": Uninstallable nodes should no longer appear in the blocked section alongside version-gated nodes.\n\nUpdate hasBlockedNodeIssues: Should only check versionGatedNodes.length \u003e 0.\n\nUpdate stats: The \"uninstallable\" stat should change icon/color to indicate actionable (warning instead of blocked).\n\nAdd to resolution flow: Uninstallable nodes should appear in the Node Resolution step as pre-resolved items (similar to auto-resolved packages) with options:\n- Install latest from registry (default, pre-selected) ‚Äî goes through apply-resolution normally\n- Install via git (if repository URL available) ‚Äî queued individually via manager queue with install_source: \"git\" AFTER apply-resolution completes\n- Skip\n- Optional\n\nWhen applying resolution, include uninstallable node choices in the node_choices payload. For git choices, queue them separately via queueNodeInstall after apply-resolution returns.\n\n### 3. WorkflowDetailsModal.vue\n\nStatus icon: Change from red X (uninstallable) to yellow warning (community-mapped)\nStatus badge: \"Community-Mapped\" instead of \"Uninstallable\"\nOptional action: Small \"Install\" link if package_id is available.\n\n### 4. NodesSection.vue\n\nCurrently treats uninstallable nodes as \"blocked\" with blocking messaging. Update to show them as \"actionable\" with install option and \"community-mapped\" terminology consistent with other surfaces.\n\n### 5. StatusSection.vue / WorkflowsSection.vue\n\nCounts: Uninstallable nodes should count as \"actionable\" rather than \"blocked\" in issue summaries.\nMessaging: \"X nodes need community packages\" rather than \"X nodes have no installable versions\"\nBackend readiness semantics already updated by cgm-ru0.3 ‚Äî frontend just needs to reflect the new categorization.\n\n### 6. Types (comfygit.ts)\n\nVerify the existing UninstallableNode interface fields (package.package_id, package.repository, package.latest_version) align with the enriched backend response from cgm-ru0.1. Update if needed.\n\nUpdate UninstallableNodeItem type used by MissingResourcesPopup to include new fields (package_id, repository, latest_version).\n\nAdd install_source to the queueNodeInstall params type.\n\n### 7. MissingResourcesDetailModal.vue\n\nThe detail view (for 5+ items) needs install action support for uninstallable nodes. The component currently has a single-action item contract (ResourceItem + one action event). Update the item/action model to support dual registry/git actions matching MissingResourcesPopup behavior.\n\n### 8. useComfyGitService.ts\n\nUpdate queueNodeInstall to include install_source in the payload sent to the backend:\n\n    async function queueNodeInstall(params: {\n        id: string\n        version?: string\n        selected_version?: string\n        repository?: string\n        mode?: string\n        channel?: string\n        install_source?: 'registry' | 'git'  // NEW\n    })\n\n## Acceptance Criteria\n\n- [ ] MissingResourcesPopup shows install buttons for uninstallable nodes (registry default, git secondary)\n- [ ] Bulk \"Install All\" includes uninstallable packages (registry installs only)\n- [ ] WorkflowResolveModal no longer shows uninstallable nodes as \"blocked\" ‚Äî they flow through resolution\n- [ ] WorkflowResolveModal sends uninstallable node choices in apply-resolution payload; git choices queued separately\n- [ ] WorkflowDetailsModal shows yellow warning instead of red X for uninstallable\n- [ ] NodesSection shows uninstallable as actionable with install option, not blocked\n- [ ] Status/workflow summaries count uninstallable as actionable, not blocked\n- [ ] Install actions correctly call queueNodeInstall with install_source: \"git\" ONLY for explicit git installs\n- [ ] Frontend types align with enriched backend response\n- [ ] Consistent terminology across all surfaces (\"Community-Mapped\" not \"Uninstallable\")\n- [ ] Tests for payload shape, blocked-vs-actionable counts, queue params for both install modes\n\n## File Ownership\n\n- frontend/src/components/MissingResourcesPopup.vue ‚Äî owned\n- frontend/src/components/MissingResourcesDetailModal.vue ‚Äî owned\n- frontend/src/components/WorkflowResolveModal.vue ‚Äî owned\n- frontend/src/components/WorkflowDetailsModal.vue ‚Äî owned\n- frontend/src/components/NodesSection.vue ‚Äî owned\n- frontend/src/components/StatusSection.vue ‚Äî owned\n- frontend/src/components/WorkflowsSection.vue ‚Äî owned\n- frontend/src/types/comfygit.ts ‚Äî owned\n- frontend/src/composables/useComfyGitService.ts ‚Äî owned (install_source param addition)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-15T16:04:55.65867014-08:00","created_by":"ubuntu","updated_at":"2026-02-15T16:54:10.675873234-08:00","dependencies":[{"issue_id":"cgm-ru0.2","depends_on_id":"cgm-ru0","type":"parent-child","created_at":"2026-02-15T16:04:55.659657167-08:00","created_by":"ubuntu"},{"issue_id":"cgm-ru0.2","depends_on_id":"cgm-ru0.1","type":"blocks","created_at":"2026-02-15T16:04:55.661215032-08:00","created_by":"ubuntu"},{"issue_id":"cgm-ru0.2","depends_on_id":"cgm-ru0.3","type":"blocks","created_at":"2026-02-15T16:28:11.112139858-08:00","created_by":"ubuntu"}],"comments":[{"id":5,"issue_id":"cgm-ru0.2","author":"ubuntu","text":"Audit:\n\nVerdict: NEEDS REVISION\n\nIssues found:\n1. blocker: \"Install via Git\" cannot work as written (`queueNodeInstall({ id: package_id, repository })`) because backend install processing ignores `repository` and uses only `params.id`.\n2. blocker: WorkflowResolveModal requirement to make uninstallable nodes pre-resolved/installable is not executable end-to-end with current API contracts. `apply-resolution` only installs from `nodes_resolved` and unresolved/ambiguous user choices; uninstallable nodes are not part of that flow.\n3. concern: `MissingResourcesDetailModal.vue` currently supports a single action path and simple `itemType` contract, so dual install actions (registry + git) need component/API shape updates before implementation.\n4. concern: Scope says \"across all UI surfaces\" but the file list omits `frontend/src/components/NodesSection.vue`, which currently treats uninstallable nodes as blocked and uses blocked messaging.\n5. concern: Some messaging comes from backend `issue_summary`; frontend-only text changes may not fully achieve terminology consistency.\n\nSuggestions:\n- Add a backend dependency task (or expand cgm-ru0.1) for queue/install source selection and uninstallable handling in apply-resolution.\n- Define a single frontend data model for community-mapped uninstallable packages and reuse it across popup/detail/resolve views.\n- Add explicit acceptance tests for queue payload behavior, status badges, and updated blocked-vs-actionable counts/messages across all targeted surfaces.\n","created_at":"2026-02-16T00:11:01Z"},{"id":9,"issue_id":"cgm-ru0.2","author":"ubuntu","text":"Re-audit:\n\nVerdict: NEEDS REVISION\n\nIssues found:\n1. blocker: The new requirement to offer \"Install via Git\" inside WorkflowResolveModal is not executable with current backend contracts. `apply-resolution` currently returns only package-ID strings and `/workflow/{name}/install` consumes only package IDs (`server/api/v2/workflows.py:706-746`), so git repository choices cannot be carried end-to-end.\n2. concern: This bead depends on `cgm-ru0.3`, but if backend logic uses `repository` whenever provided, default installs can unintentionally become git installs. Frontend must only send repository for explicit git actions.\n3. concern: `MissingResourcesDetailModal.vue` currently has a single-action item contract (`ResourceItem` + one `action` event). Dual registry/git actions require an explicit item/action model update across popup + detail modal interfaces.\n\nSuggestions:\n- For resolution flow, either (a) send structured install specs through apply/install endpoints, or (b) queue per-node installs directly via manager queue with `{ id, repository?, version? }`.\n- Add explicit install-source typing in frontend choice state/payloads so registry vs git intent is unambiguous.\n- Add tests for payload shape and behavior: uninstallable choices included in `node_choices`, blocked-vs-actionable counts, and queue params for both registry and git actions.\n","created_at":"2026-02-16T00:35:46Z"}]}
{"id":"cgm-ru0.3","title":"Backend: Wire install plumbing for uninstallable nodes (process_install + apply-resolution)","description":"## Goal\n\nWire the backend install infrastructure to support installing \"uninstallable\" (community-mapped) nodes via both registry and git. Three gaps need closing:\n\n1. process_install() ignores the repository parameter ‚Äî git installs don't work\n2. apply-resolution only installs from nodes_resolved ‚Äî uninstallable nodes are excluded from the install pipeline\n3. Readiness semantics treat uninstallable as \"blocked\" ‚Äî should be \"actionable\"\n\nAlso update the semver-unsafe _get_latest_package_version() helper in workflows.py for consistency with cgm-ru0.1.\n\n## Background\n\nCore's add_node(identifier) already accepts both registry IDs and GitHub URLs ‚Äî the install capability exists. The gap is only in the manager server layer that bridges frontend requests to core.\n\n## Changes Required\n\n### 1. server/comfygit_server.py ‚Äî process_install()\n\nCurrent code (line 492-547):\n- Extracts pack_id from params[\"id\"] and version from params[\"selected_version\"]\n- Calls env.node_manager.add_node(identifier) where identifier is pack_id or pack_id@version\n- Never reads params[\"repository\"] or any install source signal\n\n**CRITICAL**: The frontend MissingResourcesPopup (line 481) already sends `repository` in normal package install requests. Blindly preferring `repository` when present would silently convert registry installs to git installs.\n\nChange: Add explicit install_source signaling:\n\n    async def process_install(env, params: dict) -\u003e dict:\n        pack_id = params.get(\"id\")\n        version = params.get(\"selected_version\") or params.get(\"version\")\n        repository = params.get(\"repository\")\n        install_source = params.get(\"install_source\", \"registry\")  # \"registry\" | \"git\"\n        \n        # ... existing installed/disabled checks using pack_id ...\n        \n        # Build identifier based on explicit install source\n        if install_source == \"git\" and repository:\n            identifier = repository  # Core's add_node accepts GitHub URLs directly\n        elif version and version != \"latest\":\n            identifier = f\"{pack_id}@{version}\"\n        else:\n            identifier = pack_id\n        \n        await loop.run_in_executor(\n            None,\n            lambda: env.node_manager.add_node(identifier, force=is_installed)\n        )\n\nThe frontend must send `install_source: \"git\"` explicitly for git installs. Default behavior (\"registry\") is unchanged ‚Äî no regression.\n\n### 2. server/api/v2/workflows.py ‚Äî apply_resolution() and apply_resolution_stream()\n\nCurrent code (lines 1196-1201 and 1447-1452):\n- Collects nodes_to_install only from result.nodes_resolved\n- nodes_uninstallable are completely excluded\n\nChange: Include uninstallable nodes in install planning. For the initial implementation, use package_id for registry installs (the default and most common case). Git-based installs for uninstallable nodes in the resolve wizard are deferred ‚Äî frontend will queue those individually via the manager queue endpoint instead of through apply-resolution.\n\nIn both apply_resolution and apply_resolution_stream:\n\n    # Existing: collect from resolved nodes\n    nodes_to_install = []\n    installed = env.pyproject.nodes.get_existing()\n    for node in result.nodes_resolved:\n        if node.package_id and node.match_type != \"optional\":\n            if node.package_id not in installed and node.package_id not in skipped_packages:\n                nodes_to_install.append(node.package_id)\n    \n    # NEW: collect from uninstallable nodes (community-mapped, user chose to install)\n    uninstallable_nodes = getattr(result, \"nodes_uninstallable\", []) or []\n    for node in uninstallable_nodes:\n        if node.package_id and node.package_id not in installed and node.package_id not in skipped_packages:\n            node_choice = node_choices.get(node.node_type, {})\n            action = node_choice.get(\"action\", \"install\")  # default to install\n            if action == \"install\":\n                nodes_to_install.append(node.package_id)\n\nEnsure apply_resolution_stream has the same logic for parity.\n\n### 3. server/api/v2/workflows.py ‚Äî Readiness semantics\n\nCurrent code (lines 831-838 and equivalent in analyze_json_workflow):\n    has_blocked_nodes = bool(version_gated_nodes or uninstallable_nodes)\n\nChange: Only version_gated nodes count as \"blocked\":\n\n    has_blocked_nodes = bool(version_gated_nodes)  # uninstallable no longer blocking\n    has_uninstallable = bool(uninstallable_nodes)\n    is_fully_resolved = (\n        not needs_user_input\n        and nodes_needing_installation == 0\n        and download_intents_count == 0\n        and not has_blocked_nodes\n        and not has_uninstallable  # still not \"fully resolved\" but actionable\n    )\n\nApply in BOTH analyze_workflow and analyze_json_workflow functions.\n\n### 4. server/api/v2/workflows.py ‚Äî Semver-safe _get_latest_package_version()\n\nCurrent helper (line ~126-130) uses first-key or naive ordering. Update to use packaging.version.Version with fallback, matching the approach from cgm-ru0.1:\n\n    def _get_latest_package_version(package_data):\n        if not package_data or not package_data.versions:\n            return None\n        try:\n            from packaging.version import Version, InvalidVersion\n            return str(max(package_data.versions.keys(), key=lambda v: Version(v)))\n        except (InvalidVersion, ValueError):\n            return sorted(package_data.versions.keys(), reverse=True)[0]\n\n## Acceptance Criteria\n\n- [ ] process_install() respects install_source param ‚Äî only uses repository when install_source == \"git\"\n- [ ] Default install behavior unchanged (no regression from repository field presence)\n- [ ] apply-resolution includes uninstallable nodes in install planning when user chooses \"install\"\n- [ ] apply_resolution_stream has same uninstallable handling for parity\n- [ ] has_blocked_nodes only considers version_gated nodes, not uninstallable\n- [ ] is_fully_resolved treats uninstallable as \"needs action\" but not \"blocked\"\n- [ ] _get_latest_package_version() is semver-safe\n- [ ] Existing integration tests updated for new readiness semantics\n- [ ] New tests: process_install with install_source param, apply-resolution with uninstallable node choices\n\n## File Ownership\n\n- server/comfygit_server.py ‚Äî owned (process_install changes)\n- server/api/v2/workflows.py ‚Äî owned (apply-resolution, readiness semantics, semver helper)\n- testing/ ‚Äî test updates\n\n## Coordination Note\n\nworkflows.py is shared with cgm-ru0.1 (which handles serialization helpers in serializers.py and nodes.py). This task handles: apply-resolution (lines 1157+), readiness semantics (lines 831-838), and the _get_latest_package_version helper (line ~126). Non-overlapping code regions with cgm-ru0.1.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-15T16:27:11.414308049-08:00","created_by":"ubuntu","updated_at":"2026-02-15T16:53:31.424499177-08:00","dependencies":[{"issue_id":"cgm-ru0.3","depends_on_id":"cgm-ru0","type":"parent-child","created_at":"2026-02-15T16:27:11.41539705-08:00","created_by":"ubuntu"}],"comments":[{"id":8,"issue_id":"cgm-ru0.3","author":"ubuntu","text":"Re-audit:\n\nVerdict: NEEDS REVISION\n\nIssues found:\n1. blocker: `process_install` cannot blindly prefer `repository` when present. Current frontend already sends repository in default install requests (`frontend/src/components/MissingResourcesPopup.vue:481`), so the proposed precedence would unintentionally convert registry installs to git installs.\n2. blocker: `apply_resolution` inclusion of `nodes_uninstallable` solves package-ID install planning, but does not provide a path for git-based choices from WorkflowResolveModal. Current contract returns `nodes_to_install: string[]`, and install execution endpoint only accepts package IDs (`server/api/v2/workflows.py:706-746`).\n3. concern: Installed/disabled checks in `process_install` are keyed by `pack_id` only (`server/comfygit_server.py:499-507`). For git installs where stored identifier differs from `pack_id`, re-enable/update behavior can miss existing installs.\n4. concern: `apply_resolution_stream` parity should be explicit (including skip semantics and uninstallable handling) to avoid divergent behavior from `apply_resolution`.\n\nSuggestions:\n- Add explicit install-source signaling (for example `install_source: \"registry\" | \"git\"`) and gate repository usage on that field.\n- Change apply/install payloads to carry structured install specs (`id`, `repository`, `version`) rather than plain strings.\n- Expand installed-node detection in `process_install` to match by identifier variants (registry_id/repository/name), not only `pack_id`.\n","created_at":"2026-02-16T00:35:35Z"}]}
{"id":"cgm-ryx","title":"Component: DirectUrlTab","notes":"## Context \u0026 Goal\n\nCreate the Direct URL tab for the unified modal. This handles non-HuggingFace/Civitai downloads where users provide a direct URL and target path.\n\n## Current State\n\nLogic currently inline in ModelIndexSection.vue lines 197-229:\n```vue\n\u003ctemplate v-else\u003e\n  \u003cdiv class=\"input-group\"\u003e\n    \u003clabel\u003eTarget Path (relative to models directory)\u003c/label\u003e\n    \u003cBaseInput v-model=\"downloadTargetPath\" placeholder=\"e.g. checkpoints/model.safetensors\" /\u003e\n    \u003cp v-if=\"targetPathError\" class=\"modal-error\"\u003e{{ targetPathError }}\u003c/p\u003e\n  \u003c/div\u003e\n  \u003cp class=\"modal-note\"\u003eModel will be queued for background download.\u003c/p\u003e\n\u003c/template\u003e\n```\n\n## Target State\n\n**Create `frontend/src/components/download/DirectUrlTab.vue`:**\n\n```vue\n\u003ctemplate\u003e\n  \u003cdiv class=\"direct-url-tab\"\u003e\n    \u003cdiv class=\"input-group\"\u003e\n      \u003clabel\u003eDownload URL\u003c/label\u003e\n      \u003cBaseInput\n        v-model=\"url\"\n        placeholder=\"https://example.com/model.safetensors\"\n      /\u003e\n    \u003c/div\u003e\n    \n    \u003cdiv class=\"input-group\"\u003e\n      \u003clabel\u003eTarget Path (relative to models directory)\u003c/label\u003e\n      \u003cBaseInput\n        v-model=\"targetPath\"\n        placeholder=\"e.g. checkpoints/model.safetensors\"\n      /\u003e\n      \u003cp v-if=\"targetPathError\" class=\"error\"\u003e{{ targetPathError }}\u003c/p\u003e\n    \u003c/div\u003e\n    \n    \u003cp class=\"note\"\u003eModel will be queued for background download.\u003c/p\u003e\n    \n    \u003cdiv class=\"actions\"\u003e\n      \u003cBaseButton\n        variant=\"primary\"\n        :disabled=\"!isValid\"\n        @click=\"handleQueue\"\n      \u003e\n        Queue Download\n      \u003c/BaseButton\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\nProps: none (self-contained state)\n\nEmits:\n```typescript\ninterface Emits {\n  (e: 'queue', items: Array\u003c{ url: string; targetPath: string; filename: string }\u003e): void\n}\n```\n\nInternal state:\n- url: string\n- targetPath: string\n\nComputed:\n- targetPathError: validate path has filename with extension\n- isValid: url and targetPath filled, no errors\n\n## Files Inventory\n\n**Files CREATED:**\n- frontend/src/components/download/DirectUrlTab.vue\n\n**Files READ (reference only):**\n- frontend/src/components/ModelIndexSection.vue lines 197-229 - Current implementation\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-ddp (HfFileBrowser) - different file\n- cgm-xxx (CivitaiTab) - different file\n\n**Cannot Run In Parallel With:**\n- None in Phase 2\n\n**Depends On:**\n- None (but logically part of Phase 2)\n\n## Estimated Scope\n- **Size:** Small (~80 lines)\n- **Risk:** Low (simple form)\n\n## Acceptance Criteria\n- [ ] URL input field\n- [ ] Target path input with validation\n- [ ] Error shown when path missing extension\n- [ ] Queue Download button disabled until valid\n- [ ] Emits queue event with url, targetPath, filename\n\n## Testing Requirements\n- Visual testing in browser\n- Enter invalid path ‚Üí see error\n- Enter valid URL + path ‚Üí button enabled","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T02:32:49.186600826-05:00","created_by":"ubuntu","updated_at":"2026-01-28T02:41:53.572039467-05:00","closed_at":"2026-01-28T02:41:53.572039467-05:00","close_reason":"Closed"}
{"id":"cgm-ssk","title":"EnvironmentSwitcher.vue calls undefined service methods (getSwitchStatus, listEnvironments)","notes":"# Bug: EnvironmentSwitcher.vue Calls Undefined Service Methods\n\n## Summary\n\n`EnvironmentSwitcher.vue` calls two methods on the `useComfyGitService` composable that don't exist under those names. The composable exports the correct functionality under *different* names, so the component silently gets `undefined` and crashes at runtime.\n\n## Bug 1: `getSwitchStatus()` ‚Üí should be `getSwitchProgress()`\n\n**Component** (`EnvironmentSwitcher.vue:138`):\n```typescript\nconst status = await service.getSwitchStatus()  // ‚Üê undefined at runtime\n```\n\n**Composable** (`useComfyGitService.ts:495, exported at 1707`):\n```typescript\nasync function getSwitchProgress(): Promise\u003cSwitchEnvironmentProgress | null\u003e { ... }\n// Exported as: getSwitchProgress\n```\n\n**Impact**: The 1-second polling loop in `startStatusPolling()` (lines 133-169) calls `service.getSwitchStatus()` which returns `undefined`. Line 140 assigns `undefined` to `switchStatus.value`, then line 143 crashes accessing `.state` on `undefined`. The catch block on line 164 swallows the error and continues polling, so the UI hangs forever at whatever progress state it last rendered ‚Äî never reaching a terminal state (`complete`, `rolled_back`, `critical_failure`).\n\nThis is the direct cause of the UI getting stuck at 60% \"Starting new environment...\" ‚Äî the polling loop runs but never detects completion.\n\n## Bug 2: `listEnvironments()` ‚Üí should be `getEnvironments()`\n\n**Component** (`EnvironmentSwitcher.vue:104`):\n```typescript\nconst response = await service.listEnvironments()  // ‚Üê undefined at runtime\nenvironments.value = response.environments || []   // ‚Üê crash\ncurrentEnv.value = response.current || ''\nisManaged.value = response.is_managed !== false\n```\n\n**Composable** (`useComfyGitService.ts:447, exported at 1704`):\n```typescript\nasync function getEnvironments(): Promise\u003cEnvironmentInfo[]\u003e { ... }\n// Exported as: getEnvironments\n```\n\n**Additional issue**: Even after renaming, `getEnvironments()` returns `EnvironmentInfo[]` (just the array), but the component expects a full response object with `.environments`, `.current`, and `.is_managed` fields. The composable extracts the array from the backend response and discards the rest.\n\n**Impact**: `loadEnvironments()` crashes on mount. The component cannot display the environment list at all.\n\n## Why the switch still appeared to work (sometimes)\n\nThe switch *initiation* works fine ‚Äî `service.switchEnvironment()` (line 121) exists and is correctly named. It tells the orchestrator to begin switching. The problem is only with *tracking progress afterward*. The orchestrator completes the switch, but the frontend never detects it.\n\nWhen the user manually refreshed the page after the switch completed, the new environment loaded correctly because the orchestrator had already finished its work.\n\n## Comparison with working component\n\n`ComfyGitPanel.vue` (lines 477-479) uses the correct method names:\n```typescript\ngetEnvironments,      // ‚úì correct\ngetSwitchProgress,    // ‚úì correct\n```\n\nThis confirms `EnvironmentSwitcher.vue` is the only component with the wrong names.\n\n## Fix\n\nTwo changes in `EnvironmentSwitcher.vue`:\n\n1. **Line 138**: `service.getSwitchStatus()` ‚Üí `service.getSwitchProgress()`\n2. **Line 104**: `service.listEnvironments()` ‚Üí `service.getEnvironments()`\n\nFor fix #2, also need to update the response handling since `getEnvironments()` returns `EnvironmentInfo[]` not the full API response object. Either:\n- (a) Update the component to work with the array return type and fetch `current`/`is_managed` separately, or\n- (b) Add a `listEnvironments()` method to the composable that returns the full response object\n\n## Files\n\n- `frontend/src/components/EnvironmentSwitcher.vue` ‚Äî the broken component\n- `frontend/src/composables/useComfyGitService.ts` ‚Äî the correctly-named exports\n- `frontend/src/components/ComfyGitPanel.vue` ‚Äî reference for correct usage\n- `server/api/v2/environments.py` ‚Äî backend endpoint returning full response object","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-02T20:14:04.178417151-05:00","created_by":"ubuntu","updated_at":"2026-02-02T21:15:30.567580419-05:00","closed_at":"2026-02-02T21:15:30.567580419-05:00","close_reason":"Fixed both undefined method calls. getSwitchStatus‚ÜígetSwitchProgress with null guard, added listEnvironments() returning full response object. getEnvironments() delegates to it for backward compat. Build passes, no new type errors.\n\nFuture improvements to consider:\n- Move EnvironmentListResponse type to src/types/comfygit.ts so it's importable by other components\n- Fix pre-existing vue-tsc @types/node error in tsconfig (unrelated but noisy)\n- EnvironmentSwitcher polling silently swallows errors in catch block (line 168-171) ‚Äî consider adding a max retry count or surfacing persistent failures to the user instead of polling indefinitely"}
{"id":"cgm-t80","title":"Integrate TokenConfigModal into HuggingFaceTab","notes":"## Context \u0026 Goal\nAdd a \"Configure Token\" button to HuggingFaceTab that opens the TokenConfigModal. Also show auth status indicator and improve error handling for auth failures.\n\n**Why it matters:** Users need quick access to token configuration when downloading from HuggingFace, especially when encountering auth errors on gated models.\n\n## Design Requirements (from user)\n- Button inline in the HuggingFace download modal\n- Opens TokenConfigModal for adding/clearing HF token\n- Error state should show \"Configure Token\" button when auth fails\n\n## Current State\n\n**File:** `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/download/HuggingFaceTab.vue`\n\nCurrently has search/browse UI but no auth management. Uses `v-if` for conditional rendering (NOT `:show` props).\n\n## Target State\n\n**IMPORTANT:** Modal visibility uses `v-if` on the component itself, not a `:show` prop.\n\nAdd to template (in search section, before search-results):\n```vue\n\u003cdiv class=\"search-section\"\u003e\n  \u003cdiv class=\"search-header\"\u003e\n    \u003cdiv class=\"search-bar\"\u003e\n      \u003cBaseInput ... /\u003e\n      \u003cBaseButton ...\u003eSearch\u003c/BaseButton\u003e\n    \u003c/div\u003e\n    \u003cBaseButton \n      variant=\"secondary\" \n      size=\"sm\"\n      @click=\"showTokenModal = true\"\n    \u003e\n      {{ tokenMask ? `Token: ${tokenMask}` : 'Configure Token' }}\n    \u003c/BaseButton\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\nUpdate error state to add auth button:\n```vue\n\u003cdiv v-else-if=\"searchError\" class=\"error-state\"\u003e\n  \u003cp\u003e{{ searchError }}\u003c/p\u003e\n  \u003cBaseButton \n    v-if=\"isAuthError\"\n    variant=\"primary\"\n    size=\"sm\"\n    @click=\"showTokenModal = true\"\n  \u003e\n    Configure HuggingFace Token\n  \u003c/BaseButton\u003e\n\u003c/div\u003e\n```\n\nAdd modal at end of template (using v-if pattern):\n```vue\n\u003cTokenConfigModal\n  v-if=\"showTokenModal\"\n  provider=\"huggingface\"\n  :current-token-mask=\"tokenMask\"\n  @close=\"showTokenModal = false\"\n  @saved=\"handleTokenSaved\"\n  @cleared=\"handleTokenCleared\"\n/\u003e\n```\n\nAdd to script:\n```typescript\nimport { ref, computed, onMounted } from 'vue'\nimport TokenConfigModal from './TokenConfigModal.vue'\n\nconst { searchHuggingFaceRepos, getConfig } = useComfyGitService()\n\nconst showTokenModal = ref(false)\nconst tokenMask = ref\u003cstring | null\u003e(null)\n\n// Detect auth errors in search results\nconst isAuthError = computed(() =\u003e \n  searchError.value?.includes('401') || \n  searchError.value?.includes('403') ||\n  searchError.value?.toLowerCase().includes('authentication') ||\n  searchError.value?.toLowerCase().includes('unauthorized')\n)\n\nasync function loadTokenStatus() {\n  try {\n    const config = await getConfig()\n    tokenMask.value = config.huggingface_token || null  // Already masked from API\n  } catch (e) {\n    console.error('Failed to load config:', e)\n  }\n}\n\nfunction handleTokenSaved() {\n  loadTokenStatus()\n  // Optionally retry failed search if there was an auth error\n  if (isAuthError.value \u0026\u0026 searchInput.value) {\n    handleSearch()\n  }\n}\n\nfunction handleTokenCleared() {\n  tokenMask.value = null\n}\n\nonMounted(loadTokenStatus)\n```\n\nAdd CSS for search-header layout:\n```css\n.search-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: var(--cg-space-2);\n}\n\n.search-bar {\n  display: flex;\n  gap: var(--cg-space-2);\n  flex: 1;\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/download/HuggingFaceTab.vue` - Add token button, modal integration, auth error handling\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/download/TokenConfigModal.vue` - Import modal component\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing (depends on TokenConfigModal)\n\n**Cannot Run In Parallel With:**\n- cgm-xha (TokenConfigModal) - MUST complete first\n\n**Blocking Reason:**\n- None (leaf node)\n\n## Estimated Scope\n- **Size:** Medium (~60 lines added)\n- **Risk:** Low (additive changes to existing component)\n\n## Acceptance Criteria\n- [ ] \"Configure Token\" button visible in search header (top right area)\n- [ ] Button shows \"Token: ***xxxx\" if token configured\n- [ ] Clicking button opens TokenConfigModal with provider=\"huggingface\"\n- [ ] Auth error state shows \"Configure HuggingFace Token\" button\n- [ ] After saving token, button updates to show masked token\n- [ ] After saving token, if there was auth error, retry search automatically\n- [ ] After clearing token, button shows \"Configure Token\"\n\n## Testing Requirements\n- Manual: Open HF tab, verify button appears\n- Manual: Click button, verify modal opens with HF provider\n- Manual: Save token, verify button updates\n- Manual: Trigger auth error (search private repo), verify error button appears\n- Manual: Save token after auth error, verify search retries\n- Build frontend: `cd frontend \u0026\u0026 bun run build`\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T15:28:09.780820987-05:00","created_by":"ubuntu","updated_at":"2026-01-29T22:44:37.769581321-05:00","closed_at":"2026-01-29T22:44:37.769581321-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-t80","depends_on_id":"cgm-xha","type":"blocks","created_at":"2026-01-29T15:28:25.475696744-05:00","created_by":"ubuntu"}]}
{"id":"cgm-t9g","title":"Add auto-advance after model resolution selection","notes":"## Context \u0026 Goal\n\n**Problem:** Same as the node resolution auto-advance issue - after selecting a model option, users must manually click the arrow to advance. This should be consistent with node resolution behavior.\n\n**Why it matters:** Consistency across the resolution modal. If nodes auto-advance, models should too.\n\n**Design decision:** Mirror the exact same pattern as NodeResolutionStep for consistency.\n\n## Current State vs Target State\n\n**Current code** (`frontend/src/components/base/organisms/ModelResolutionStep.vue` line 301):\n```typescript\n// Handlers - no auto-advance, user navigates manually\n```\n\n**Target code:** Same pattern as NodeResolutionStep - add `advanceToNextUnresolved()` helper and call it after all choice handlers:\n- `handleModelSelected()`\n- `handleMarkOptional()`\n- `handleSkip()`\n- `handleDownload()`\n- `handleSelectLocal()` (if applicable)\n\nThe implementation should mirror NodeResolutionStep exactly, but check `modelChoices` instead of `nodeChoices`.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/base/organisms/ModelResolutionStep.vue` (~line 301+) - Add auto-advance logic\n\n**Files READ (reference only):**\n- `frontend/src/components/base/organisms/NodeResolutionStep.vue` - Reference implementation pattern\n- `frontend/src/components/base/molecules/ModelResolutionItem.vue` - Understand emitted events\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend-only beads (workflows.py changes)\n- NodeResolutionStep changes (separate file)\n- Any bead not touching ModelResolutionStep.vue\n\n**Cannot Run In Parallel With:**\n- Any other bead modifying ModelResolutionStep.vue\n\n**Blocking Reason:** None - this is a leaf task. However, implementing NodeResolutionStep first is recommended so this bead can copy the pattern.\n\n## Estimated Scope\n- **Size:** Small (~30 lines added)\n- **Risk:** Low (UI behavior change, mirrors node resolution pattern)\n\n## Acceptance Criteria\n- [ ] After selecting a model option, view auto-advances to next unresolved model\n- [ ] After marking a model as optional, view auto-advances to next unresolved model\n- [ ] After skipping a model, view auto-advances to next unresolved model\n- [ ] After initiating download, view auto-advances to next unresolved model\n- [ ] Arrow buttons remain visible and functional for manual navigation\n- [ ] If all models are resolved, view stays on current model\n- [ ] Counter still shows correct \"X/Y resolved\" status\n- [ ] Behavior is consistent with NodeResolutionStep\n\n## Testing Requirements\n\n**Manual Testing:**\n1. Open resolution modal for a workflow with 2+ missing/ambiguous models\n2. Make a selection for the first model\n3. Verify view auto-advances to second model\n4. Verify back/forward arrows still work\n\n**Existing tests:**\n- `frontend/src/components/base/organisms/__tests__/ModelResolutionStep.test.ts`\n\n**New tests needed:**\n- Consider adding test for auto-advance behavior (optional for MVP)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-23T18:12:34.639207095-05:00","created_by":"ubuntu","updated_at":"2026-01-23T21:34:38.392641131-05:00","closed_at":"2026-01-23T21:34:38.392641131-05:00","close_reason":"Completed via sprint run-1769220521034348168"}
{"id":"cgm-thb","title":"Fix info icon rendering in PushModal (upside-down bang)","notes":"## Context \u0026 Goal\nThe PushModal's blue info notice box displays a Unicode character (‚Ñπ U+2139) that renders as an upside-down exclamation mark in some browser/font configurations. This should be replaced with an inline SVG matching the existing InfoButton.vue pattern for consistent rendering.\n\n## Current State vs Target State\n\n**Current (PushModal.vue:74-77):**\n```vue\n\u003cdiv v-if=\"preview.is_first_push\" class=\"info-box\"\u003e\n  \u003cspan class=\"info-icon\"\u003e‚Ñπ\u003c/span\u003e\n  \u003cspan\u003eThis will create the remote branch for the first time.\u003c/span\u003e\n\u003c/div\u003e\n```\n\n**Target:** Replace the `\u003cspan\u003e` containing the Unicode character with an inline SVG (same pattern used in InfoButton.vue:3-6):\n```vue\n\u003cdiv v-if=\"preview.is_first_push\" class=\"info-box\"\u003e\n  \u003csvg class=\"info-icon\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"currentColor\"\u003e\n    \u003ccircle cx=\"8\" cy=\"8\" r=\"7\" stroke=\"currentColor\" stroke-width=\"1.5\" fill=\"none\"/\u003e\n    \u003ctext x=\"8\" y=\"11\" text-anchor=\"middle\" font-size=\"10\" font-weight=\"bold\" fill=\"currentColor\"\u003ei\u003c/text\u003e\n  \u003c/svg\u003e\n  \u003cspan\u003eThis will create the remote branch for the first time.\u003c/span\u003e\n\u003c/div\u003e\n```\n\n**CSS (PushModal.vue:288-290) ‚Äî NO CHANGE NEEDED:**\n```css\n.info-icon {\n  flex-shrink: 0;\n}\n```\nThe existing `.info-icon` class applies to both `\u003cspan\u003e` and `\u003csvg\u003e` elements. `flex-shrink: 0` works correctly for SVG. The `currentColor` in the SVG inherits from `.info-box`'s `color: var(--cg-color-info)`.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/components/base/molecules/PushModal.vue (line 75 only) - Replace `\u003cspan class=\"info-icon\"\u003e‚Ñπ\u003c/span\u003e` with SVG element\n\n**Files READ (reference only):**\n- frontend/src/components/base/atoms/InfoButton.vue (lines 3-6) - SVG icon pattern to match\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-y8o (outgoing commits) ‚Äî no file overlap\n\n**Cannot Run In Parallel With:**\n- Nothing\n\n## Estimated Scope\n- **Size:** Small (1 line changed)\n- **Risk:** Low (isolated UI template change, no logic changes)\n\n## Acceptance Criteria\n- [ ] Info box displays a properly-rendered circle-i icon (not an upside-down bang)\n- [ ] Icon color matches the info-box text color (inherits via currentColor from --cg-color-info)\n- [ ] Frontend rebuilds without errors: cd frontend \u0026\u0026 npm run build\n\n## Testing Requirements\n- Visual verification in the ComfyUI panel push modal (trigger by pushing to a new remote for the first time)\n- No automated tests needed (pure visual fix)\n- Verify: rebuild frontend with `cd frontend \u0026\u0026 npm run build`","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-30T14:01:48.893782198-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:15:55.182191728-05:00","closed_at":"2026-01-30T14:15:55.182191728-05:00","close_reason":"Implemented by sprint run-1769800134274552135"}
{"id":"cgm-tuo","title":"Add HuggingFace types to frontend comfygit.ts","notes":"## Context \u0026 Goal\n\nAdd TypeScript interfaces for HuggingFace repo info API responses and model subdirectories. These types enable type-safe API calls in the service layer.\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit-manager/frontend/src/types/comfygit.ts`):\nNo HuggingFace-related types exist.\n\n**Target** - Add near other interfaces (around line 705):\n\n```typescript\n// =============================================================================\n// HuggingFace Integration Types\n// =============================================================================\n\nexport interface HuggingFaceRepoFile {\n  path: string\n  size: number\n  is_model_file: boolean\n  shard_group?: string | null\n}\n\nexport interface HuggingFaceRepoInfoResponse {\n  repo_id: string\n  revision: string\n  files: HuggingFaceRepoFile[]\n}\n\nexport interface ModelsSubdirectoriesResponse {\n  directories: string[]\n  standard: string[]\n  existing: string[]\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/types/comfygit.ts (add ~20 lines at end)\n\n**Files READ:** None\n\n**Files CREATED:** None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All other Phase 1 beads (different files)\n\n**Cannot Run In Parallel With:** None\n\n**Blocking Reason:** Service methods and modal component need these types\n\n## Estimated Scope\n- **Size:** Small (~20 lines)\n- **Risk:** Low (additive types only)\n\n## Acceptance Criteria\n- [ ] Three interfaces added: HuggingFaceRepoFile, HuggingFaceRepoInfoResponse, ModelsSubdirectoriesResponse\n- [ ] TypeScript compiles without errors\n- [ ] Types are exported\n\n## Testing Requirements\n- TypeScript compilation check via `npm run build` in frontend directory","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:49:39.823809989-05:00","created_by":"ubuntu","updated_at":"2026-01-27T21:49:24.117984803-05:00","closed_at":"2026-01-27T21:49:24.117984803-05:00","close_reason":"Closed"}
{"id":"cgm-uiq","title":"Create MissingResourcesDetailModal component","notes":"## Context \u0026 Goal\n\nThe MissingResourcesPopup modal currently truncates lists to 5 items with \"...and X more\" text. Users want to see all items in a scrollable list. This task creates a reusable sub-modal component that displays the full list of missing resources (models OR custom node packages) with a sticky header containing the bulk action button.\n\n**Why it matters:** Users with 6+ missing models can't see or interact with all of them. This blocks their ability to selectively download/install specific items.\n\n---\n\n## Current State vs Target State\n\n**Current:** No detail modal exists. MissingResourcesPopup.vue shows max 5 items per section.\n\n**Target:** A new component \\`MissingResourcesDetailModal.vue\\` that:\n- Takes a list of items (models or packages) as props\n- Displays them in a scrollable list within a BaseModal\n- Has a sticky header with title + count + bulk action button (\"Download All\" / \"Install All\")\n- Each item row shows: name + status badge OR action button\n- Emits events for: close, individual action, bulk action\n\n---\n\n## Files Inventory\n\n**Files CREATED:**\n- \\`frontend/src/components/MissingResourcesDetailModal.vue\\` - The new sub-modal component\n\n**Files READ (reference only):**\n- \\`frontend/src/components/MissingResourcesPopup.vue\\` - For understanding item structure, action handlers, styling patterns (especially badge classes lines 692-721)\n- \\`frontend/src/components/base/BaseModal.vue\\` - For modal structure and slots\n- \\`frontend/src/components/base/BaseButton.vue\\` - For button variants (primary, secondary, ghost)\n\n---\n\n## Implementation Details\n\n### Props Interface\n\\`\\`\\`typescript\ninterface ResourceItem {\n  id: string                       // Unique key: url for models, package_id for packages\n  name: string                     // Display name: filename for models, title for packages  \n  subtitle?: string                // e.g., \"(3 nodes)\" for packages\n  canAction: boolean               // Whether action button should show\n  actionDisabledReason?: string    // Text to show when canAction=false (e.g., \"Manual download required\")\n}\n\ninterface Props {\n  title: string                    // Modal title, e.g., \"Missing Models (6)\"\n  items: ResourceItem[]            // The full list of items\n  itemType: 'model' | 'package'    // Determines action button labels\n  queuedItems: Set\u003cstring\u003e         // Items already queued (by id)\n  installedItems?: Set\u003cstring\u003e     // Packages successfully installed (by id)\n  failedItems?: Map\u003cstring, string\u003e // id -\u003e error message\n  installingItem?: string | null   // id of currently installing item\n}\n\\`\\`\\`\n\n### Events\n\\`\\`\\`typescript\ndefineEmits\u003c{\n  close: []\n  action: [item: ResourceItem]      // Individual download/install clicked\n  'bulk-action': []                 // Download All / Install All clicked\n}\u003e()\n\\`\\`\\`\n\n### Computed Properties\n\\`\\`\\`typescript\nconst actionLabel = computed(() =\u003e props.itemType === 'model' ? 'Download' : 'Install')\nconst bulkActionLabel = computed(() =\u003e {\n  if (allDone.value) return props.itemType === 'model' ? 'All Queued' : 'All Queued'\n  return props.itemType === 'model' ? 'Download All' : 'Install All'\n})\n\nconst actionableItems = computed(() =\u003e props.items.filter(i =\u003e i.canAction))\nconst allDone = computed(() =\u003e {\n  return actionableItems.value.length \u003e 0 \u0026\u0026 \n    actionableItems.value.every(i =\u003e \n      props.queuedItems.has(i.id) || \n      props.installedItems?.has(i.id) ||\n      props.failedItems?.has(i.id)\n    )\n})\n\\`\\`\\`\n\n### Helper Functions\n\\`\\`\\`typescript\nfunction isQueued(item: ResourceItem): boolean {\n  return props.queuedItems.has(item.id)\n}\n\nfunction isInstalling(item: ResourceItem): boolean {\n  return props.installingItem === item.id\n}\n\nfunction isInstalled(item: ResourceItem): boolean {\n  return props.installedItems?.has(item.id) ?? false\n}\n\nfunction isFailed(item: ResourceItem): boolean {\n  return props.failedItems?.has(item.id) ?? false\n}\n\nfunction getFailureReason(item: ResourceItem): string {\n  return props.failedItems?.get(item.id) || 'Unknown error'\n}\n\\`\\`\\`\n\n### Template Structure\n\\`\\`\\`vue\n\u003ctemplate\u003e\n  \u003cBaseModal :title=\"title\" size=\"md\" @close=\"emit('close')\"\u003e\n    \u003ctemplate #body\u003e\n      \u003c!-- Sticky header with bulk action --\u003e\n      \u003cdiv class=\"detail-header\"\u003e\n        \u003cspan class=\"item-count\"\u003e{{ items.length }} {{ items.length === 1 ? 'item' : 'items' }}\u003c/span\u003e\n        \u003cBaseButton \n          v-if=\"actionableItems.length \u003e 1\"\n          size=\"sm\" \n          variant=\"secondary\"\n          :disabled=\"allDone\"\n          @click=\"emit('bulk-action')\"\n        \u003e\n          {{ bulkActionLabel }}\n        \u003c/BaseButton\u003e\n      \u003c/div\u003e\n      \n      \u003c!-- Scrollable list (BaseModal body already scrolls) --\u003e\n      \u003cdiv class=\"resource-list\"\u003e\n        \u003cdiv v-for=\"item in items\" :key=\"item.id\" class=\"resource-item\"\u003e\n          \u003cdiv class=\"item-info\"\u003e\n            \u003cspan class=\"item-name\"\u003e{{ item.name }}\u003c/span\u003e\n            \u003cspan v-if=\"item.subtitle\" class=\"item-subtitle\"\u003e{{ item.subtitle }}\u003c/span\u003e\n          \u003c/div\u003e\n          \n          \u003c!-- Actionable items: show button or state badge --\u003e\n          \u003ctemplate v-if=\"item.canAction\"\u003e\n            \u003cspan v-if=\"isInstalling(item)\" class=\"installing-badge\"\u003eInstalling...\u003c/span\u003e\n            \u003cspan v-else-if=\"isFailed(item)\" class=\"failed-badge\" :title=\"getFailureReason(item)\"\u003eFailed ‚ö†\u003c/span\u003e\n            \u003cspan v-else-if=\"isInstalled(item)\" class=\"installed-badge\"\u003eInstalled\u003c/span\u003e\n            \u003cspan v-else-if=\"isQueued(item)\" class=\"queued-badge\"\u003eQueued\u003c/span\u003e\n            \u003cBaseButton v-else size=\"sm\" variant=\"secondary\" @click=\"emit('action', item)\"\u003e\n              {{ actionLabel }}\n            \u003c/BaseButton\u003e\n          \u003c/template\u003e\n          \n          \u003c!-- Non-actionable items: show reason --\u003e\n          \u003cspan v-else class=\"no-action\"\u003e{{ item.actionDisabledReason || 'Not available' }}\u003c/span\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/template\u003e\n\n    \u003ctemplate #footer\u003e\n      \u003cBaseButton variant=\"secondary\" @click=\"emit('close')\"\u003eClose\u003c/BaseButton\u003e\n    \u003c/template\u003e\n  \u003c/BaseModal\u003e\n\u003c/template\u003e\n\\`\\`\\`\n\n### Styling\n\\`\\`\\`css\n\u003cstyle scoped\u003e\n.detail-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding-bottom: var(--cg-space-3);\n  margin-bottom: var(--cg-space-3);\n  border-bottom: 1px solid var(--cg-color-border-subtle);\n  /* Note: NOT sticky - BaseModal body handles scroll, header stays at top naturally */\n}\n\n.item-count {\n  color: var(--cg-color-text-muted);\n  font-size: var(--cg-font-size-sm);\n}\n\n.resource-list {\n  display: flex;\n  flex-direction: column;\n  background: var(--cg-color-bg-tertiary);\n  border-radius: var(--cg-radius-md);\n  padding: var(--cg-space-2);\n}\n\n.resource-item {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--cg-space-2);\n  padding: var(--cg-space-2);\n}\n\n.resource-item:not(:last-child) {\n  border-bottom: 1px solid var(--cg-color-border);\n}\n\n.item-info {\n  display: flex;\n  align-items: center;\n  gap: var(--cg-space-2);\n  flex: 1;\n  min-width: 0;\n}\n\n.item-name {\n  font-family: var(--cg-font-mono);\n  color: var(--cg-color-text-primary);\n  font-size: var(--cg-font-size-xs);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.item-subtitle {\n  color: var(--cg-color-text-muted);\n  font-size: var(--cg-font-size-xs);\n  flex-shrink: 0;\n}\n\n.no-action {\n  color: var(--cg-color-warning);\n  font-style: italic;\n  font-size: var(--cg-font-size-xs);\n  white-space: nowrap;\n}\n\n/* Reuse badge styles from MissingResourcesPopup */\n.queued-badge,\n.installing-badge,\n.failed-badge,\n.installed-badge {\n  font-size: var(--cg-font-size-xs);\n  font-weight: var(--cg-font-weight-medium);\n  padding: var(--cg-space-1) var(--cg-space-2);\n  border-radius: var(--cg-radius-sm);\n  white-space: nowrap;\n}\n\n.queued-badge {\n  color: var(--cg-color-warning);\n  background: color-mix(in srgb, var(--cg-color-warning) 15%, transparent);\n}\n\n.installing-badge {\n  color: var(--cg-color-accent);\n  background: color-mix(in srgb, var(--cg-color-accent) 15%, transparent);\n}\n\n.failed-badge {\n  color: var(--cg-color-error);\n  background: color-mix(in srgb, var(--cg-color-error) 15%, transparent);\n  cursor: help;\n}\n\n.installed-badge {\n  color: var(--cg-color-success);\n  background: color-mix(in srgb, var(--cg-color-success) 15%, transparent);\n}\n\u003c/style\u003e\n\\`\\`\\`\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any other beads that don't touch frontend/src/components/\n\n**Cannot Run In Parallel With:**\n- cgm-xei (integration bead) - but that's a dependency, not conflict\n\n**Blocking Reason:**\n- cgm-xei depends on this component existing to import it\n\n---\n\n## Estimated Scope\n- **Size:** Medium (~50 lines template, ~50 lines script, ~70 lines style = ~170 total)\n- **Risk:** Low (new isolated component, no existing code modified)\n\n---\n\n## Acceptance Criteria\n- [ ] Component file created at \\`frontend/src/components/MissingResourcesDetailModal.vue\\`\n- [ ] Renders BaseModal with title prop displayed in header\n- [ ] Shows item count in detail-header (\"6 items\")\n- [ ] Bulk action button appears when \u003e1 actionable items\n- [ ] Bulk action button disabled when allDone\n- [ ] Each item displays name (monospace, ellipsis on overflow)\n- [ ] Each item displays subtitle if provided\n- [ ] Actionable items show: Download/Install button OR state badge (Queued/Installing/Installed/Failed)\n- [ ] Non-actionable items show: disabled reason text in warning color\n- [ ] Failed badge shows tooltip with error message on hover\n- [ ] Close button emits 'close' event\n- [ ] Individual action button emits 'action' with item\n- [ ] Bulk action button emits 'bulk-action'\n\n---\n\n## Testing Requirements\n- Manual testing only (no automated tests needed for UI component)\n- Test with models data: 10 items, mix of canDownload true/false\n- Test with packages data: 10 items with varying node counts\n- Verify scroll behavior with 20+ items\n- Verify badge states render with correct colors\n- Verify ellipsis on long filenames","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T14:52:05.258126953-05:00","created_by":"ubuntu","updated_at":"2026-01-28T15:17:16.376272386-05:00","closed_at":"2026-01-28T15:17:16.376272386-05:00","close_reason":"Closed"}
{"id":"cgm-v3s","title":"[Epic] Manual Model Addition to Workflows","notes":"## Context \u0026 Goal\n\nCustom nodes (e.g., VoiceVibe) load models programmatically from paths like `models/vibevoice/...` without using standard ComfyUI model loader nodes. The comfygit model detection pipeline only discovers models through workflow node widget parsing, so these custom-loaded models are invisible ‚Äî the environment shows \\\"No models\\\" even though models are required.\n\n**Goal:** Allow users to manually add existing workspace models to specific workflows in the environment manifest, so the full model dependency picture is tracked and shareable.\n\n### Design Decisions (from discussion)\n1. **Per-workflow scoping** ‚Äî models are added to a specific workflow, not environment-wide\n2. **Resolve against local index** ‚Äî models must already exist in the workspace model index (no URL-only/download intents)\n3. **Separate UI from Download** ‚Äî dedicated \\\"Add Model\\\" action, not overloading the download button\n4. **Criticality is user-modifiable** ‚Äî required/flexible/optional selectable at add time\n5. **Browse local models only** ‚Äî users pick from workspace index, no external URL entry\n\n### Architecture Summary\n- Core: `EnvironmentModelManager.add_manual_model()` + `remove_manual_model()` wrapping existing `pyproject.workflows.add_workflow_model()` and `ManifestWorkflowModel(nodes=[])`\n- Backend: New `POST/DELETE /v2/comfygit/models/environment/manual` endpoints\n- Frontend: New `AddModelModal.vue` + modifications to `ModelsEnvSection.vue`\n\n### Child Beads\nSee dependent task/subtask beads for implementation details.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-30T14:31:41.489479325-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:31:41.489479325-05:00"}
{"id":"cgm-v93","title":"Create frontend HuggingFace URL parser utility","notes":"## Context \u0026 Goal\n\nCreate a TypeScript URL parser for the frontend that detects HuggingFace repo URLs vs direct file URLs. This enables the download modal to show \"Browse Repo Files\" button when user pastes a repo URL.\n\n## Current State vs Target State\n\n**Current**: No utils directory exists, no HF URL parsing\n\n**Target** - Create `/data/projects/comfygit-ai/comfygit-manager/frontend/src/utils/huggingface.ts`:\n\n```typescript\nexport type HuggingFaceUrlKind = 'repo' | 'file' | 'unknown'\n\nexport interface HuggingFaceParsedUrl {\n  kind: HuggingFaceUrlKind\n  repoId?: string\n  revision?: string\n  path?: string // file path in repo (for kind='file')\n}\n\nfunction isHfHost(host: string): boolean {\n  const h = host.toLowerCase()\n  return h === 'huggingface.co' || h.endsWith('.huggingface.co') || h === 'hf.co'\n}\n\nexport function parseHuggingFaceUrl(rawUrl: string): HuggingFaceParsedUrl {\n  const url = rawUrl.trim()\n  if (!url) return { kind: 'unknown' }\n\n  let u: URL\n  try {\n    u = new URL(url)\n  } catch {\n    return { kind: 'unknown' }\n  }\n\n  if (!isHfHost(u.hostname)) return { kind: 'unknown' }\n\n  const parts = u.pathname.replace(/^\\/+/, '').split('/').filter(Boolean)\n\n  // Ignore datasets/spaces URLs for now (model downloader MVP)\n  if (parts[0] === 'datasets' || parts[0] === 'spaces') return { kind: 'unknown' }\n\n  if (parts.length \u003c 2) return { kind: 'unknown' }\n\n  const repoId = \\`\\${parts[0]}/\\${parts[1]}\\`\n  const rest = parts.slice(2)\n\n  // https://huggingface.co/owner/repo\n  if (rest.length === 0) {\n    return { kind: 'repo', repoId, revision: 'main' }\n  }\n\n  const marker = rest[0]\n\n  // https://huggingface.co/owner/repo/tree/main(/subdir...)\n  if (marker === 'tree') {\n    const revision = rest[1] || 'main'\n    return { kind: 'repo', repoId, revision }\n  }\n\n  // https://huggingface.co/owner/repo/resolve/main/path/to/file\n  if (marker === 'resolve') {\n    const revision = rest[1] || 'main'\n    const path = rest.slice(2).join('/')\n    if (!path) return { kind: 'repo', repoId, revision }\n    return { kind: 'file', repoId, revision, path }\n  }\n\n  // Browser file page (not direct download)\n  if (marker === 'blob') {\n    const revision = rest[1] || 'main'\n    const path = rest.slice(2).join('/')\n    if (!path) return { kind: 'repo', repoId, revision }\n    return { kind: 'file', repoId, revision, path }\n  }\n\n  // Fallback: treat as repo\n  return { kind: 'repo', repoId, revision: 'main' }\n}\n\nfunction encodePath(path: string): string {\n  return path.split('/').map(encodeURIComponent).join('/')\n}\n\nexport function buildHfResolveUrl(repoId: string, revision: string, path: string): string {\n  const [owner, repo] = repoId.split('/')\n  return \\`https://huggingface.co/\\${encodeURIComponent(owner)}/\\${encodeURIComponent(repo)}/resolve/\\${encodeURIComponent(revision)}/\\${encodePath(path)}\\`\n}\n```\n\n## Files Inventory\n\n**Files MODIFIED:** None\n\n**Files READ:** None\n\n**Files CREATED:**\n- /data/projects/comfygit-ai/comfygit-manager/frontend/src/utils/huggingface.ts\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- All other Phase 1 beads (no overlap)\n\n**Cannot Run In Parallel With:** None\n\n**Blocking Reason:** HuggingFaceRepoModal.vue and ModelIndexSection.vue need to import this\n\n## Estimated Scope\n- **Size:** Small (~80 lines)  \n- **Risk:** Low (new isolated module)\n\n## Acceptance Criteria\n- [ ] Directory `frontend/src/utils/` already exists (contains fetchWithTimeout.ts)\n- [ ] File exports parseHuggingFaceUrl and buildHfResolveUrl\n- [ ] TypeScript compiles without errors\n- [ ] Same URL patterns handled as core parser\n\n## Testing Requirements\n- Manual testing via browser console\n- Integration testing when wired into modal","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T03:49:27.834958335-05:00","created_by":"ubuntu","updated_at":"2026-01-27T21:49:24.108478027-05:00","closed_at":"2026-01-27T21:49:24.108478027-05:00","close_reason":"Closed"}
{"id":"cgm-w21","title":"Simplify MissingResourcesPopup to global setting + saved-workflow detection","notes":"## Context \u0026 Goal\n\n**Problem:** The current MissingResourcesPopup uses a per-workflow hash system that is complex and unintuitive:\n- Hash based on node IDs changes when workflow is modified\n- \"Don't show again for this workflow\" is confusing since it's actually hash-based\n- Doesn't distinguish saved vs unsaved workflows\n- Creates many localStorage entries that need cleanup\n\n**Solution:** Simplify to two checks:\n1. Skip popup for saved workflows (they're tracked in ComfyGit panel)\n2. Global \"don't show popup\" setting (single boolean, like ComfyUI)\n\n**Additional fix:** Remove \"Open ComfyGit Panel\" button - it confuses users since unsaved workflows show \"no issues\" in the panel.\n\n## Current State vs Target State\n\n### MissingResourcesPopup.vue\n\n**REMOVE these functions (lines 391-425):**\n```typescript\n// DELETE: Hash-based system\nfunction hashString(str: string): string { ... }\nfunction getWorkflowHash(workflow: any): string { ... }\nfunction shouldShowPopup(workflow: any): boolean { ... }\nfunction handleDontShowAgainChange() { ... }\n```\n\n**REPLACE analyzeWorkflow check (lines 427-431):**\n```typescript\n// OLD:\nasync function analyzeWorkflow(workflow: any) {\n  if (!shouldShowPopup(workflow)) {\n    return\n  }\n  // ...\n}\n\n// NEW:\nasync function analyzeWorkflow(workflow: any) {\n  // Skip for saved workflows - issues tracked in ComfyGit panel\n  if (workflow?.path || workflow?.filename) {\n    console.log('[ComfyGit] Workflow saved to disk, skipping popup')\n    return\n  }\n  \n  // Skip if user globally disabled popup\n  if (localStorage.getItem('comfygit:popup-disabled') === 'true') {\n    console.log('[ComfyGit] Popup globally disabled')\n    return\n  }\n  // ...\n}\n```\n\n**CHANGE checkbox label and handler (lines 122-127):**\n```vue\n\u003c!-- OLD: --\u003e\n\u003cBaseCheckbox v-model=\"dontShowAgain\" @update:model-value=\"handleDontShowAgainChange\"\u003e\n  Don't show again for this workflow\n\u003c/BaseCheckbox\u003e\n\n\u003c!-- NEW: --\u003e\n\u003cBaseCheckbox v-model=\"dontShowAgain\" @update:model-value=\"handleDontShowAgainChange\"\u003e\n  Don't show this popup\n\u003c/BaseCheckbox\u003e\n```\n\n**NEW handleDontShowAgainChange:**\n```typescript\nfunction handleDontShowAgainChange() {\n  if (dontShowAgain.value) {\n    localStorage.setItem('comfygit:popup-disabled', 'true')\n  } else {\n    localStorage.removeItem('comfygit:popup-disabled')\n  }\n}\n```\n\n**REMOVE \"Open ComfyGit Panel\" button (lines 141):**\n```vue\n\u003c!-- OLD footer: --\u003e\n\u003ctemplate #footer\u003e\n  \u003cBaseButton variant=\"secondary\" @click=\"dismiss\"\u003eDismiss\u003c/BaseButton\u003e\n  \u003cBaseButton v-if=\"hasDownloadableItems\" ...\u003eDownload All\u003c/BaseButton\u003e\n  \u003cBaseButton v-else variant=\"primary\" @click=\"openPanel\"\u003eOpen ComfyGit Panel\u003c/BaseButton\u003e\n\u003c/template\u003e\n\n\u003c!-- NEW footer: --\u003e\n\u003ctemplate #footer\u003e\n  \u003cBaseButton variant=\"secondary\" @click=\"dismiss\"\u003eDismiss\u003c/BaseButton\u003e\n  \u003cBaseButton v-if=\"hasDownloadableItems\" ...\u003eDownload All\u003c/BaseButton\u003e\n\u003c/template\u003e\n```\n\n**REMOVE openPanel function (lines 474-480)** - no longer needed\n\n**REMOVE refs no longer needed:**\n- currentWorkflowHash (line 185)\n\n**ADD auto-dismiss on save (in onMounted):**\n```typescript\n// Listen for workflow save - auto-dismiss popup\nfunction handleWorkflowSaved(event: CustomEvent) {\n  const { change_type } = event.detail\n  if ((change_type === 'created' || change_type === 'modified') \u0026\u0026 visible.value) {\n    visible.value = false\n    console.log('[ComfyGit] Workflow saved, auto-dismissing popup')\n  }\n}\n\nonMounted(() =\u003e {\n  window.addEventListener('comfygit:workflow-loaded', handleWorkflowLoaded as EventListener)\n  window.addEventListener('comfygit:workflow-changed', handleWorkflowSaved as EventListener)\n  // ... rest\n})\n\nonUnmounted(() =\u003e {\n  window.removeEventListener('comfygit:workflow-loaded', handleWorkflowLoaded as EventListener)\n  window.removeEventListener('comfygit:workflow-changed', handleWorkflowSaved as EventListener)\n  // ... rest\n})\n```\n\n### WorkspaceSettingsContent.vue\n\n**REPLACE dismissedPopupCount logic (lines 138, 178, 234-258):**\n```typescript\n// OLD:\nconst dismissedPopupCount = ref(0)\ndismissedPopupCount.value = countDismissedPopups()\nfunction countDismissedPopups(): number { ... }\nfunction resetDismissedPopups() { ... }\n\n// NEW:\nconst popupEnabled = ref(true)\n\n// In loadSettings():\npopupEnabled.value = localStorage.getItem('comfygit:popup-disabled') !== 'true'\n\n// New function:\nfunction togglePopupSetting(value: boolean) {\n  if (value) {\n    localStorage.removeItem('comfygit:popup-disabled')\n  } else {\n    localStorage.setItem('comfygit:popup-disabled', 'true')\n  }\n}\n```\n\n**REPLACE settings UI (lines 73-86):**\n```vue\n\u003c!-- OLD: --\u003e\n\u003cSettingRow\n  label=\"Dismissed Dependency Popups\"\n  description=\"Reset the 'don't show again' state for missing dependency popups when loading workflows.\"\n\u003e\n  \u003cBaseButton\n    variant=\"secondary\"\n    size=\"sm\"\n    :disabled=\"dismissedPopupCount === 0\"\n    @click=\"resetDismissedPopups\"\n  \u003e\n    {{ dismissedPopupCount \u003e 0 ? `Reset (${dismissedPopupCount})` : 'None Dismissed' }}\n  \u003c/BaseButton\u003e\n\u003c/SettingRow\u003e\n\n\u003c!-- NEW: --\u003e\n\u003cSettingRow\n  label=\"Show Missing Dependencies Popup\"\n  description=\"Show popup when loading unsaved workflows with missing nodes or models. Saved workflows are tracked in the ComfyGit panel.\"\n\u003e\n  \u003cToggle v-model=\"popupEnabled\" @update:modelValue=\"togglePopupSetting\" /\u003e\n\u003c/SettingRow\u003e\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/components/MissingResourcesPopup.vue - Simplify dismissal logic, remove panel button, add save listener\n- frontend/src/components/WorkspaceSettingsContent.vue - Replace reset button with toggle\n\n**Files READ (reference only):**\n- frontend/src/main.ts - Verify comfygit:workflow-changed event structure\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any backend tasks\n- Any other frontend components not touching these files\n\n**Cannot Run In Parallel With:**\n- Nothing blocking\n\n**Blocking Reason:** N/A - standalone task\n\n## Estimated Scope\n\n- **Size:** Medium (~100 lines changed across 2 files)\n- **Risk:** Low (isolated UI change, no backend impact)\n\n## Acceptance Criteria\n\n- [ ] Popup does NOT show for workflows with a `path` property (saved workflows)\n- [ ] Popup DOES show for in-memory workflows (no path)\n- [ ] \"Don't show this popup\" checkbox disables popup globally\n- [ ] Settings has toggle to re-enable popup\n- [ ] localStorage uses single key `comfygit:popup-disabled` instead of per-hash keys\n- [ ] No \"Open ComfyGit Panel\" button in popup footer\n- [ ] Popup auto-dismisses when `comfygit:workflow-changed` event fires with created/modified\n\n## Testing Requirements\n\n**Manual testing:**\n1. Drag workflow JSON into ComfyUI ‚Üí popup should show (if has issues)\n2. Save workflow ‚Üí popup should auto-dismiss\n3. Reload saved workflow ‚Üí popup should NOT show\n4. Check \"Don't show this popup\" ‚Üí dismiss ‚Üí load another unsaved workflow ‚Üí popup should NOT show\n5. Go to Settings ‚Üí toggle ON ‚Üí load unsaved workflow ‚Üí popup SHOULD show\n6. Verify only \"Dismiss\" and \"Download All\" buttons in footer (no \"Open Panel\")\n\n**No automated tests needed** - this is UI behavior change","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-26T03:16:19.507288452-05:00","created_by":"ubuntu","updated_at":"2026-01-26T03:20:37.34813621-05:00","closed_at":"2026-01-26T03:20:37.34813621-05:00","close_reason":"Implemented simplified popup logic: skip for saved workflows, global disable setting instead of per-hash, removed 'Open ComfyGit Panel' button, added auto-dismiss on workflow save"}
{"id":"cgm-w6s","title":"Create BranchDetailModal component","notes":"## Context \u0026 Goal\n\n**Problem:** Branch management UX puts dangerous \"Delete\" action as the first button, and users cannot easily view a branch's commit history before switching or deleting.\n\n**Solution:** Create a modal that shows branch details (commit history, metadata) when clicking a branch row. Move \"Delete\" action into this modal's footer, reducing accidental deletions.\n\n**Serves project goal:** Improve UX polish before customer release.\n\n---\n\n## Current State vs Target State\n\n### Current: BranchSection shows inline actions\n```vue\n\u003c!-- frontend/src/components/BranchSection.vue:41-58 --\u003e\n\u003ctemplate #actions\u003e\n  \u003cActionButton\n    v-if=\"!branch.is_current\"\n    variant=\"destructive\"\n    size=\"xs\"\n    @click=\"$emit('delete', branch.name)\"\n  \u003e\n    Delete\n  \u003c/ActionButton\u003e\n  \u003cActionButton\n    v-if=\"!branch.is_current\"\n    variant=\"secondary\"\n    size=\"xs\"\n    @click=\"$emit('switch', branch.name)\"\n  \u003e\n    Switch\n  \u003c/ActionButton\u003e\n\u003c/template\u003e\n```\n\n### Target: New BranchDetailModal component\n```vue\n\u003c!-- frontend/src/components/BranchDetailModal.vue (NEW) --\u003e\n\u003ctemplate\u003e\n  \u003cBaseModal size=\"md\" @close=\"$emit('close')\"\u003e\n    \u003ctemplate #header\u003e\n      \u003cdiv class=\"header-info\"\u003e\n        \u003ch3 class=\"header-title\"\u003eBRANCH\u003c/h3\u003e\n        \u003cspan class=\"branch-name\"\u003e{{ branchName }}\u003c/span\u003e\n        \u003cspan v-if=\"isCurrent\" class=\"current-badge\"\u003eCURRENT\u003c/span\u003e\n      \u003c/div\u003e\n    \u003c/template\u003e\n\n    \u003ctemplate #body\u003e\n      \u003c!-- Branch metadata --\u003e\n      \u003cdiv class=\"branch-meta\"\u003e\n        \u003cspan\u003e{{ commits.length }} commits\u003c/span\u003e\n        \u003cspan v-if=\"commitsAhead\"\u003e{{ commitsAhead }} ahead of main\u003c/span\u003e\n      \u003c/div\u003e\n      \n      \u003c!-- Commit history (scrollable) --\u003e\n      \u003cCommitList\u003e\n        \u003cCommitItem\n          v-for=\"commit in commits\"\n          :key=\"commit.hash\"\n          :hash=\"commit.short_hash\"\n          :message=\"commit.message\"\n          :relative-date=\"commit.date_relative\"\n          :clickable=\"false\"\n        /\u003e\n      \u003c/CommitList\u003e\n    \u003c/template\u003e\n\n    \u003ctemplate #footer\u003e\n      \u003cActionButton\n        v-if=\"!isCurrent\"\n        variant=\"destructive\"\n        size=\"sm\"\n        @click=\"$emit('delete', branchName)\"\n      \u003e\n        Delete Branch\n      \u003c/ActionButton\u003e\n      \u003cdiv class=\"footer-spacer\"\u003e\u003c/div\u003e\n      \u003cBaseButton\n        v-if=\"!isCurrent\"\n        variant=\"primary\"\n        @click=\"$emit('switch', branchName)\"\n      \u003e\n        Switch to Branch\n      \u003c/BaseButton\u003e\n    \u003c/template\u003e\n  \u003c/BaseModal\u003e\n\u003c/template\u003e\n```\n\n---\n\n## Files Inventory\n\n**Files CREATED:**\n- `frontend/src/components/BranchDetailModal.vue` - New modal component\n\n**Files MODIFIED (write):**\n- `frontend/src/composables/useComfyGitService.ts` (add ~15 lines) - Add `getBranchHistory(branchName)` function\n\n**Files READ (reference only):**\n- `frontend/src/components/CommitDetailModal.vue` - Reference for modal structure\n- `frontend/src/components/base/BaseModal.vue` - Modal API\n- `frontend/src/components/base/molecules/CommitList.vue` - Reuse\n- `frontend/src/components/base/molecules/CommitItem.vue` - Reuse\n- `frontend/src/types/comfygit.ts` - BranchInfo, CommitInfo types\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Any bead not touching useComfyGitService.ts or creating BranchDetailModal.vue\n\n**Cannot Run In Parallel With:**\n- cgm-xxxx (integration bead) - REASON: Integration needs this modal to exist\n\n**Blocking Reason:** Modal component must exist before BranchSection can import and use it\n\n---\n\n## Estimated Scope\n- **Size:** Medium (~150 lines for new component + ~15 lines service function)\n- **Risk:** Low (new isolated component, minimal touch to existing code)\n\n---\n\n## Acceptance Criteria\n- [ ] BranchDetailModal.vue created with props: branchName, isCurrent\n- [ ] Modal shows branch name in header with CURRENT badge if applicable\n- [ ] Modal body shows scrollable commit history using CommitList/CommitItem\n- [ ] Footer has Delete button (destructive, hidden for current branch)\n- [ ] Footer has Switch button (primary, hidden for current branch)\n- [ ] getBranchHistory(branchName) added to useComfyGitService\n- [ ] Loading state shown while fetching commits\n- [ ] Emits: close, delete, switch events\n\n---\n\n## Testing Requirements\n- Manual: Open modal, verify commits display correctly\n- Manual: Verify Delete button hidden for current branch\n- Manual: Verify Switch button works and triggers switch flow\n- No new unit tests required (component is UI-only)\n\n---\n\n## Implementation Notes\n\n1. **Service function** - Add to useComfyGitService.ts around line 338:\n```typescript\nasync function getBranchHistory(branchName: string, limit = 50): Promise\u003cLogResult\u003e {\n  if (USE_MOCK) {\n    const commits = await mockApi.getCommitHistory(limit)\n    return { commits, has_more: false, current_branch: branchName }\n  }\n  return fetchApi\u003cLogResult\u003e(`/v2/comfygit/log?branch=${encodeURIComponent(branchName)}\u0026limit=${limit}`)\n}\n```\n\n2. **Modal structure** - Follow CommitDetailModal.vue patterns for styling consistency\n\n3. **Footer layout** - Delete left (destructive), spacer, Switch right (primary)\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T20:32:14.005942247-05:00","created_by":"ubuntu","updated_at":"2026-01-28T21:07:54.384563032-05:00","closed_at":"2026-01-28T21:07:54.384563032-05:00","close_reason":"Closed"}
{"id":"cgm-wqg","title":"Wire up HF token in config.py backend API with masking","notes":"## Context \u0026 Goal\nUpdate the backend config API to support HuggingFace token get/set with proper security (masked response, never return full token).\n\n**Why it matters:** Frontend needs API endpoints to display token status and update tokens. Security requires we never expose full tokens in API responses.\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit-manager/server/api/v2/config.py`):\n\nLines 96-112 GET endpoint returns raw civitai token and null for HF:\n```python\ncivitai_token = config_manager.get_civitai_token()\n\nconfig = {\n    ...\n    \"civitai_api_key\": civitai_token,  # EXPOSES FULL TOKEN - BAD\n    \"huggingface_token\": None,  # Not yet supported\n    ...\n}\n```\n\nLines 167-170 POST endpoint ignores HF token:\n```python\n# Ignore unsupported fields for now:\n# - huggingface_token\n```\n\n**Target:**\n\nGET endpoint - mask BOTH tokens (last 4 chars or null):\n```python\n# Get API credentials\ncivitai_token = config_manager.get_civitai_token()\nhf_token = config_manager.get_huggingface_token()\n\n# Helper to mask tokens for security\ndef mask_token(token: str | None) -\u003e str | None:\n    if not token:\n        return None\n    return f\"***{token[-4:]}\" if len(token) \u003e 4 else \"****\"\n\nconfig = {\n    ...\n    \"civitai_api_key\": mask_token(civitai_token),\n    \"huggingface_token\": mask_token(hf_token),\n    ...\n}\n```\n\nPOST endpoint - handle huggingface_token:\n```python\n# Update HuggingFace token if provided\nif \"huggingface_token\" in data:\n    token = data[\"huggingface_token\"]\n    config_manager.set_huggingface_token(token)\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit-manager/server/api/v2/config.py` (lines 96-112, 167-196) - Wire up HF token with masking, also mask civitai token\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/repositories/workspace_config_repository.py` - Reference for method calls\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-5ns (model_downloader) - different file, same dependency\n\n**Cannot Run In Parallel With:**\n- cgm-487 (repository methods) - MUST complete first\n\n**Blocking Reason:**\n- Frontend beads need this API to work\n\n## Estimated Scope\n- **Size:** Small (\u003c40 lines)\n- **Risk:** Low (follows existing pattern)\n\n## Acceptance Criteria\n- [ ] GET /v2/comfygit/config returns masked HF token (***xxxx) if set\n- [ ] GET /v2/comfygit/config returns masked CivitAI token (***xxxx) if set - SECURITY FIX\n- [ ] GET /v2/comfygit/config returns null for tokens that are not set\n- [ ] POST /v2/comfygit/config with huggingface_token saves to config\n- [ ] POST /v2/comfygit/config with huggingface_token: null clears token\n- [ ] Full token is NEVER returned in API response\n\n## Testing Requirements\n- Run: `uv run pytest testing/ -v -k config`\n- Manual: Call GET config, verify masked token format for both providers\n- Manual: POST new HF token, verify it persists\n- Manual: POST null HF token, verify it clears\n\n## Security Note\nThis is a **breaking change** for the CivitAI token - it was previously returned unmasked. The frontend already treats it as a password input, so this should be transparent to users. The WorkspaceSettingsContent.vue component shows masked inputs anyway.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T15:27:03.354516279-05:00","created_by":"ubuntu","updated_at":"2026-01-29T16:25:34.079067569-05:00","closed_at":"2026-01-29T16:25:34.079067569-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-wqg","depends_on_id":"cgm-487","type":"blocks","created_at":"2026-01-29T15:27:21.414508329-05:00","created_by":"ubuntu"}]}
{"id":"cgm-x23","title":"Cleanup: Delete HuggingFaceRepoModal and rebuild frontend","notes":"## Context \u0026 Goal\n\nFinal cleanup after all components are integrated. Delete the old modal and rebuild the frontend.\n\n## Tasks\n\n1. Delete `frontend/src/components/HuggingFaceRepoModal.vue` (no longer used)\n2. Rebuild frontend: `cd frontend \u0026\u0026 bun run build`\n3. Verify build succeeds with no errors\n4. Test in browser\n\n## Files Inventory\n\n**Files DELETED:**\n- frontend/src/components/HuggingFaceRepoModal.vue\n\n**Commands to run:**\n```bash\nrm frontend/src/components/HuggingFaceRepoModal.vue\ncd frontend \u0026\u0026 bun run build\n```\n\n## Parallelization Info\n\n**Depends On:**\n- cgm-1no (integration must be complete first)\n\n## Estimated Scope\n- **Size:** Small (delete + build)\n- **Risk:** Low\n\n## Acceptance Criteria\n- [ ] HuggingFaceRepoModal.vue deleted\n- [ ] Frontend builds without errors\n- [ ] No TypeScript errors\n- [ ] Application works in browser\n\n## Testing Requirements\n- Full end-to-end test of download flow\n- Verify all tabs work\n- Verify downloads queue correctly","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-28T02:34:21.896638903-05:00","created_by":"ubuntu","updated_at":"2026-01-28T03:38:24.964818007-05:00","closed_at":"2026-01-28T03:38:24.964818007-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-x23","depends_on_id":"cgm-1no","type":"blocks","created_at":"2026-01-28T02:34:29.796564019-05:00","created_by":"ubuntu"}]}
{"id":"cgm-xei","title":"Integrate Show All buttons into MissingResourcesPopup","notes":"## Context \u0026 Goal\n\nAfter creating the MissingResourcesDetailModal component, we need to integrate it into MissingResourcesPopup.vue. This adds \"Show All\" buttons to each section that opens the detail modal, allowing users to see and interact with all missing items.\n\n**Why it matters:** Completes the feature - users can now click \"Show All\" to see the full list in a dedicated sub-modal.\n\n---\n\n## Current State vs Target State\n\n### Current State (MissingResourcesPopup.vue)\n\n**Template lines 20-66 (Missing Custom Nodes section):**\n- Shows up to 5 packages with `.slice(0, 5)`\n- \"...and X more packages\" overflow text (line 62-64)\n- \"Install All\" button in header\n\n**Template lines 84-120 (Missing Models section):**\n- Shows up to 5 models with `.slice(0, 5)` \n- \"...and X more\" overflow text (line 116-118)\n- \"Download All\" button in header\n\n**Note:** \"Unknown Nodes\" section (lines 68-82) does NOT need a detail modal - these nodes can't be installed (not in registry), so there's no action to take. Showing all of them adds no value.\n\n### Target State\n\n**1. Wrap section header actions in a container for proper layout:**\n\\`\\`\\`vue\n\u003cdiv class=\"section-header\"\u003e\n  \u003cspan class=\"section-title\"\u003eMissing Models ({{ missingModels.length }})\u003c/span\u003e\n  \u003cdiv class=\"section-actions\"\u003e\n    \u003cBaseButton \n      v-if=\"missingModels.length \u003e 5\" \n      size=\"sm\" \n      variant=\"ghost\" \n      @click=\"activeDetailView = 'models'\"\n    \u003e\n      Show All\n    \u003c/BaseButton\u003e\n    \u003cBaseButton v-if=\"downloadableModels.length \u003e 1\" ...\u003e\n      {{ allModelsQueued ? 'All Queued' : 'Download All' }}\n    \u003c/BaseButton\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\\`\\`\\`\n\n**2. Remove overflow-note divs** (lines 62-64, 116-118) - no longer needed\n\n**3. Add detail modal after main modal content (before closing BaseModal tag):**\n\\`\\`\\`vue\n\u003c!-- Detail Modal for full list view --\u003e\n\u003cMissingResourcesDetailModal\n  v-if=\"activeDetailView\"\n  :title=\"detailModalTitle\"\n  :items=\"detailModalItems\"\n  :item-type=\"activeDetailView\"\n  :queued-items=\"activeDetailView === 'models' ? queuedModels : queuedPackages\"\n  :installed-items=\"activeDetailView === 'packages' ? installedPackages : undefined\"\n  :failed-items=\"activeDetailView === 'packages' ? failedPackages : undefined\"\n  :installing-item=\"activeDetailView === 'packages' ? installingPackage : undefined\"\n  @close=\"activeDetailView = null\"\n  @action=\"handleDetailAction\"\n  @bulk-action=\"handleDetailBulkAction\"\n/\u003e\n\\`\\`\\`\n\n**4. Add script setup:**\n\\`\\`\\`typescript\nimport MissingResourcesDetailModal from './MissingResourcesDetailModal.vue'\n\nconst activeDetailView = ref\u003c'models' | 'packages' | null\u003e(null)\n\nconst detailModalTitle = computed(() =\u003e {\n  if (activeDetailView.value === 'models') return \\`Missing Models (\\${missingModels.value.length})\\`\n  if (activeDetailView.value === 'packages') return \\`Missing Custom Nodes (\\${totalMissingNodeCount.value})\\`\n  return ''\n})\n\nconst detailModalItems = computed(() =\u003e {\n  if (activeDetailView.value === 'models') {\n    return missingModels.value.map(m =\u003e ({\n      id: m.url || m.widget_value,  // url for queuedModels check, widget_value as fallback key\n      name: m.filename,\n      canAction: m.canDownload,\n      actionDisabledReason: m.canDownload ? undefined : 'Manual download required'\n    }))\n  }\n  if (activeDetailView.value === 'packages') {\n    return missingPackages.value.map(p =\u003e ({\n      id: p.package_id,\n      name: p.title,\n      subtitle: \\`(\\${p.node_count} \\${p.node_count === 1 ? 'node' : 'nodes'})\\`,\n      canAction: true  // All packages can attempt install\n    }))\n  }\n  return []\n})\n\nfunction handleDetailAction(item: { id: string }) {\n  if (activeDetailView.value === 'models') {\n    // Find by url first (for downloadable), fallback to widget_value\n    const model = missingModels.value.find(m =\u003e m.url === item.id || m.widget_value === item.id)\n    if (model) downloadModel(model)\n  } else if (activeDetailView.value === 'packages') {\n    const pkg = missingPackages.value.find(p =\u003e p.package_id === item.id)\n    if (pkg) installPackage(pkg)\n  }\n}\n\nfunction handleDetailBulkAction() {\n  if (activeDetailView.value === 'models') downloadAllModels()\n  else if (activeDetailView.value === 'packages') installAllNodes()\n}\n\\`\\`\\`\n\n**5. Add CSS for section-actions:**\n\\`\\`\\`css\n.section-actions {\n  display: flex;\n  gap: var(--cg-space-2);\n  align-items: center;\n}\n\\`\\`\\`\n\n---\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- \\`frontend/src/components/MissingResourcesPopup.vue\\`\n  - Template: lines 20-32 (packages section header), lines 62-64 (remove overflow), lines 86-97 (models section header), lines 116-118 (remove overflow), add detail modal before \u003c/BaseModal\u003e\n  - Script: add import, add state/computed/handlers (~30 lines)\n  - Style: add .section-actions class\n\n**Files READ (reference only):**\n- \\`frontend/src/components/MissingResourcesDetailModal.vue\\` - The component we're integrating (created in cgm-uiq)\n\n**Files CREATED:**\n- None\n\n---\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing - depends on cgm-uiq\n\n**Cannot Run In Parallel With:**\n- cgm-uiq (Create MissingResourcesDetailModal component) - REASON: needs the component to exist for import\n\n**Blocking Reason:**\n- This completes the feature, nothing depends on it\n\n---\n\n## Estimated Scope\n- **Size:** Medium (~60 lines template changes, ~40 lines script additions, ~5 lines CSS)\n- **Risk:** Low (additive changes to existing component, existing functionality unchanged)\n\n---\n\n## Acceptance Criteria\n- [ ] \"Show All\" button appears in Custom Nodes section when \u003e5 packages\n- [ ] \"Show All\" button appears in Models section when \u003e5 models\n- [ ] \"Show All\" button does NOT appear in Unknown Nodes section (no actionable items)\n- [ ] Clicking \"Show All\" opens MissingResourcesDetailModal with correct data\n- [ ] Model detail modal: shows all models, Download buttons for downloadable, \"Manual download required\" for others\n- [ ] Package detail modal: shows all packages with node counts, Install/Queued/Installed/Failed states\n- [ ] Actions in detail modal trigger correct handlers (downloadModel, installPackage)\n- [ ] Bulk actions work (downloadAllModels, installAllNodes)\n- [ ] Closing detail modal (X button) returns to main popup\n- [ ] State syncs: queue a model in detail modal ‚Üí see \"Queued\" badge in both views\n- [ ] Overflow notes (...and X more) are removed from both sections\n\n---\n\n## Testing Requirements\n- Load workflow with 6+ missing models ‚Üí verify \"Show All\" appears\n- Load workflow with 6+ missing packages ‚Üí verify \"Show All\" appears  \n- Open model detail ‚Üí scroll through all items ‚Üí download one ‚Üí verify \"Queued\" badge\n- Open package detail ‚Üí scroll through all items ‚Üí install one ‚Üí verify state progression\n- Close detail modal ‚Üí verify main popup still visible with updated states","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T14:52:38.665766737-05:00","created_by":"ubuntu","updated_at":"2026-01-28T15:17:16.391438816-05:00","closed_at":"2026-01-28T15:17:16.391438816-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-xei","depends_on_id":"cgm-uiq","type":"blocks","created_at":"2026-01-27T14:52:44.405431273-05:00","created_by":"ubuntu"}]}
{"id":"cgm-xha","title":"Create TokenConfigModal component for inline token management","notes":"## Context \u0026 Goal\nCreate a reusable modal component for managing API tokens (HuggingFace, CivitAI) that can be triggered from within the download modal. Users should be able to add/clear tokens without navigating to settings.\n\n**Why it matters:** When a download fails due to auth, users need a quick way to configure their token without leaving the download flow. This modal provides that inline experience.\n\n## Design Requirements (from user)\n- Modal appears inline in download modal (not a separate page)\n- Can add new token (override existing)\n- Can clear existing token\n- Shows masked status (***xxxx) if token exists\n- Works for both HuggingFace and CivitAI (reusable)\n\n## Target Component\n\n**File:** `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/download/TokenConfigModal.vue`\n\n**IMPORTANT:** BaseModal does NOT have a `show` prop. The modal is conditionally rendered with `v-if` at the call site. The modal component itself is always \"shown\" when rendered.\n\n```vue\n\u003ctemplate\u003e\n  \u003cBaseModal title=\"Configure API Token\" @close=\"$emit('close')\"\u003e\n    \u003ctemplate #body\u003e\n      \u003cdiv class=\"token-config-modal\"\u003e\n        \u003cdiv class=\"provider-info\"\u003e\n          \u003cspan class=\"provider-icon\"\u003e{{ providerIcon }}\u003c/span\u003e\n          \u003cspan class=\"provider-name\"\u003e{{ providerName }}\u003c/span\u003e\n        \u003c/div\u003e\n\n        \u003cdiv v-if=\"currentTokenMask\" class=\"current-token\"\u003e\n          \u003cspan class=\"label\"\u003eCurrent token:\u003c/span\u003e\n          \u003cspan class=\"mask\"\u003e{{ currentTokenMask }}\u003c/span\u003e\n          \u003cBaseButton variant=\"danger\" size=\"sm\" @click=\"handleClear\" :loading=\"clearing\"\u003e\n            Clear Token\n          \u003c/BaseButton\u003e\n        \u003c/div\u003e\n\n        \u003cdiv class=\"token-input-section\"\u003e\n          \u003clabel class=\"input-label\"\u003e\n            {{ currentTokenMask ? 'Replace with new token:' : 'Enter token:' }}\n          \u003c/label\u003e\n          \u003cBaseInput\n            v-model=\"newToken\"\n            type=\"password\"\n            :placeholder=\"placeholder\"\n          /\u003e\n          \u003cdiv class=\"help-text\"\u003e\n            \u003ca :href=\"helpUrl\" target=\"_blank\" rel=\"noopener\"\u003e\n              {{ helpLinkText }}\n            \u003c/a\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/template\u003e\n    \u003ctemplate #footer\u003e\n      \u003cdiv class=\"modal-actions\"\u003e\n        \u003cBaseButton variant=\"secondary\" @click=\"$emit('close')\"\u003e\n          Cancel\n        \u003c/BaseButton\u003e\n        \u003cBaseButton\n          variant=\"primary\"\n          :disabled=\"!newToken.trim()\"\n          :loading=\"saving\"\n          @click=\"handleSave\"\n        \u003e\n          Save Token\n        \u003c/BaseButton\u003e\n      \u003c/div\u003e\n    \u003c/template\u003e\n  \u003c/BaseModal\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nimport { ref, computed } from 'vue'\nimport BaseModal from '@/components/base/BaseModal.vue'\nimport BaseInput from '@/components/base/BaseInput.vue'\nimport BaseButton from '@/components/base/BaseButton.vue'\nimport { useComfyGitService } from '@/composables/useComfyGitService'\n\ntype Provider = 'huggingface' | 'civitai'\n\nconst props = defineProps\u003c{\n  provider: Provider\n  currentTokenMask: string | null  // e.g., \"***abcd\" or null\n}\u003e()\n\nconst emit = defineEmits\u003c{\n  close: []\n  saved: []\n  cleared: []\n}\u003e()\n\nconst { updateConfig } = useComfyGitService()\n\nconst newToken = ref(''‚Äã)\nconst saving = ref(false)\nconst clearing = ref(false)\n\nconst providerName = computed(() =\u003e \n  props.provider === 'huggingface' ? 'HuggingFace' : 'CivitAI'\n)\n\nconst providerIcon = computed(() =\u003e\n  props.provider === 'huggingface' ? 'ü§ó' : 'üé®'\n)\n\nconst placeholder = computed(() =\u003e\n  props.provider === 'huggingface' ? 'hf_xxxx...' : 'Enter API key...'\n)\n\nconst helpUrl = computed(() =\u003e\n  props.provider === 'huggingface'\n    ? 'https://huggingface.co/settings/tokens'\n    : 'https://civitai.com/user/account'\n)\n\nconst helpLinkText = computed(() =\u003e\n  props.provider === 'huggingface'\n    ? 'Get your HuggingFace token ‚Üí'\n    : 'Get your CivitAI API key ‚Üí'\n)\n\nasync function handleSave() {\n  if (!newToken.value.trim()) return\n  saving.value = true\n  try {\n    const updates = props.provider === 'huggingface'\n      ? { huggingface_token: newToken.value.trim() }\n      : { civitai_api_key: newToken.value.trim() }\n    await updateConfig(updates)\n    newToken.value = ''\n    emit('saved')\n    emit('close')\n  } catch (e) {\n    console.error('Failed to save token:', e)\n  } finally {\n    saving.value = false\n  }\n}\n\nasync function handleClear() {\n  clearing.value = true\n  try {\n    const updates = props.provider === 'huggingface'\n      ? { huggingface_token: null }\n      : { civitai_api_key: null }\n    await updateConfig(updates)\n    emit('cleared')\n    emit('close')\n  } catch (e) {\n    console.error('Failed to clear token:', e)\n  } finally {\n    clearing.value = false\n  }\n}\n\u003c/script\u003e\n\n\u003cstyle scoped\u003e\n.token-config-modal {\n  display: flex;\n  flex-direction: column;\n  gap: var(--cg-space-4);\n}\n\n.provider-info {\n  display: flex;\n  align-items: center;\n  gap: var(--cg-space-2);\n  font-size: var(--cg-font-size-lg);\n  font-weight: var(--cg-font-weight-medium);\n}\n\n.current-token {\n  display: flex;\n  align-items: center;\n  gap: var(--cg-space-2);\n  padding: var(--cg-space-3);\n  background: var(--cg-color-bg-tertiary);\n  border-radius: var(--cg-border-radius);\n}\n\n.current-token .label {\n  color: var(--cg-color-text-secondary);\n}\n\n.current-token .mask {\n  font-family: var(--cg-font-mono);\n  flex: 1;\n}\n\n.token-input-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--cg-space-2);\n}\n\n.input-label {\n  font-size: var(--cg-font-size-sm);\n  color: var(--cg-color-text-secondary);\n}\n\n.help-text {\n  font-size: var(--cg-font-size-xs);\n}\n\n.help-text a {\n  color: var(--cg-color-accent);\n}\n\n.modal-actions {\n  display: flex;\n  justify-content: flex-end;\n  gap: var(--cg-space-2);\n}\n\u003c/style\u003e\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- None\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/base/BaseModal.vue` - Modal pattern (uses slots: #body, #footer)\n- `/data/projects/comfygit-ai/comfygit-manager/frontend/src/composables/useComfyGitService.ts` - updateConfig method\n\n**Files CREATED:**\n- `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/download/TokenConfigModal.vue` - New reusable modal\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-yg1 (WorkspaceSettings) - different file\n- cgm-5ns (model_downloader) - different package\n\n**Cannot Run In Parallel With:**\n- cgm-wqg (backend API) - MUST complete first (API must support HF token)\n\n**Blocking Reason:**\n- HuggingFaceTab integration needs this component\n\n## Estimated Scope\n- **Size:** Medium (~120 lines)\n- **Risk:** Low (new isolated component)\n\n## Acceptance Criteria\n- [ ] Modal renders correctly (uses BaseModal with #body and #footer slots)\n- [ ] Provider-specific text/links shown for HF vs CivitAI\n- [ ] Shows current masked token if exists\n- [ ] Clear button removes token via API (with loading state)\n- [ ] Save button stores new token via API (with loading state)\n- [ ] Emits saved/cleared events for parent to react\n- [ ] Cancel button emits close event\n\n## Testing Requirements\n- Manual: Open modal, verify provider-specific content\n- Manual: Enter token, save - verify API called\n- Manual: Click clear - verify token removed\n- Build frontend: `cd frontend \u0026\u0026 bun run build`\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T15:27:49.439089787-05:00","created_by":"ubuntu","updated_at":"2026-01-29T22:30:44.79819275-05:00","closed_at":"2026-01-29T22:30:44.79819275-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-xha","depends_on_id":"cgm-wqg","type":"blocks","created_at":"2026-01-29T15:28:09.752371994-05:00","created_by":"ubuntu"}]}
{"id":"cgm-xii","title":"Update handleContinueFromAnalysis to skip Models step for download-intent-only cases","notes":"# Context \u0026 Goal\n\n## Problem\nThe `handleContinueFromAnalysis` function determines which step to navigate to after Analysis. Currently it navigates to Models step if there are download intents, but if we're skipping the Models step (per comfygit-manager-yah), this navigation logic also needs updating.\n\n## Why It Matters\nWithout this change, clicking \"Continue\" from Analysis could try to navigate to a step that doesn't exist in the wizard, causing undefined behavior.\n\n## How It Serves Project Goals\nConsistent navigation flow that matches the wizard step configuration.\n\n---\n\n# Current State vs Target State\n\n## Current Code (PROBLEM)\n\n**File:** `frontend/src/components/WorkflowResolveModal.vue` (lines 750-763)\n\n```typescript\nfunction handleContinueFromAnalysis() {\n  if (needsNodeResolution.value || hasNodesToInstall.value) {\n    currentStep.value = 'nodes'\n  } else if (needsModelResolution.value || hasDownloadIntents.value) {\n    currentStep.value = 'models'\n  } else {\n    currentStep.value = 'review'\n  }\n}\n```\n\n## Target Code (SOLUTION)\n\n```typescript\nfunction handleContinueFromAnalysis() {\n  if (needsNodeResolution.value || hasNodesToInstall.value) {\n    currentStep.value = 'nodes'\n  } else if (needsModelResolution.value) {\n    // Only go to models if user needs to make choices\n    // Download intents don't need user input - skip to review\n    currentStep.value = 'models'\n  } else {\n    currentStep.value = 'review'\n  }\n}\n```\n\n---\n\n# Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/WorkflowResolveModal.vue` (lines 750-763) - Update navigation condition\n\n**Files READ (reference only):**\n- None\n\n**Files CREATED:**\n- None\n\n---\n\n# Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-447 (different lines)\n- comfygit-manager-n2o (different lines)\n\n**Cannot Run In Parallel With:**\n- comfygit-manager-yah - REASON: Both relate to skipping Models step, should be done together or sequentially\n\n**Blocking Reason:**\n- Depends on comfygit-manager-yah being decided (same logic change)\n\n---\n\n# Estimated Scope\n\n- **Size:** Small (\u003c10 lines) - single condition change\n- **Risk:** Low (isolated navigation logic)\n\n---\n\n# Acceptance Criteria\n\n- [ ] From Analysis, clicking Continue skips Models step when only download intents exist\n- [ ] From Analysis, clicking Continue goes to Models when unresolved/ambiguous models exist\n- [ ] From Analysis, clicking Continue goes to Nodes when node resolution needed\n- [ ] Navigation matches wizardSteps configuration\n\n---\n\n# Testing Requirements\n\n**Manual Verification:**\n1. Open workflow with only download intents (no unresolved models)\n2. Click Continue from Analysis\n3. Verify you land on Review (not Models)\n4. Open workflow with unresolved models\n5. Click Continue, verify you land on Models","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-22T14:29:05.337122123-05:00","created_by":"ubuntu","updated_at":"2026-01-22T15:01:29.985687144-05:00","closed_at":"2026-01-22T15:01:29.985687144-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-xii","depends_on_id":"cgm-yah","type":"blocks","created_at":"2026-01-22T14:29:10.021851396-05:00","created_by":"ubuntu"},{"issue_id":"cgm-xii","depends_on_id":"cgm-1cj","type":"parent-child","created_at":"2026-01-22T14:30:08.812244709-05:00","created_by":"ubuntu"}]}
{"id":"cgm-y8o","title":"Populate outgoing commits in push preview API endpoint","notes":"## Context \u0026 Goal\nThe push preview modal shows \"Creating origin/main with 2 commits\" but the OUTGOING COMMITS list is empty. The backend endpoint at /v2/comfygit/remotes/{name}/push-preview hardcodes an empty commits array. The frontend template is correct ‚Äî it iterates preview.commits ‚Äî but the backend never populates it.\n\n## Current State vs Target State\n\n**Current (server/api/v2/remotes.py:404-415):**\n```python\nreturn web.json_response({\n    \"remote\": name,\n    \"branch\": branch,\n    \"commits_ahead\": sync_status[\"ahead\"],\n    \"commits\": [],  # Commit details require git plumbing commands\n    ...\n})\n```\n\n**Target:** Fetch actual outgoing commits by reusing existing `get_version_history()` with a new `rev_range` parameter. Three changes needed:\n\n### A) Add rev_range parameter to git_history() (core utility)\n\n**File:** /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/utils/git.py\n**Lines:** 376-413\n\n**Current signature:**\n```python\ndef git_history(\n    repo_path: Path,\n    file_path: Path | None = None,\n    pretty: str | None = None,\n    max_count: int | None = None,\n    follow: bool = False,\n    oneline: bool = False,\n) -\u003e str:\n```\n\n**Target:** Add `rev_range: str | None = None` parameter. Insert `if rev_range: cmd.append(rev_range)` BEFORE the file_path block (rev_range must come before `--`).\n\n### B) Add rev_range parameter to get_version_history() (GitManager)\n\n**File:** /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/git_manager.py\n**Lines:** 255-285\n\n**Current signature:**\n```python\ndef get_version_history(self, limit: int = 10) -\u003e list[dict]:\n```\n\n**Target:** Add `rev_range: str | None = None` parameter. Pass it through to `git_history()`:\n```python\ndef get_version_history(self, limit: int = 10, rev_range: str | None = None) -\u003e list[dict]:\n    ...\n    result = git_history(\n        self.repo_path,\n        max_count=limit,\n        pretty=\"format:%h|%D|%s|%ai|%cr\",\n        rev_range=rev_range,\n    )\n    ...\n```\n\nThis reuses all existing parsing logic (hash, refs, message, date, date_relative).\n\n### C) Call get_version_history from push-preview endpoint\n\n**File:** server/api/v2/remotes.py\n**Lines:** 400-415\n\n**Target:** Replace `\"commits\": []` with actual data. Use `is_first_push` (already computed at line 394) to decide the approach:\n\n```python\n# Fetch outgoing commits\ncommits_ahead = sync_status[\"ahead\"]\nif commits_ahead \u003e 0:\n    try:\n        if is_first_push:\n            # Remote branch doesn't exist - just get last N commits\n            outgoing = await run_sync(\n                env.git_manager.get_version_history, commits_ahead\n            )\n        else:\n            # Get commits ahead of remote using revision range\n            outgoing = await run_sync(\n                env.git_manager.get_version_history,\n                commits_ahead,\n                f\"{name}/{branch}..HEAD\",\n            )\n    except Exception:\n        outgoing = []\nelse:\n    outgoing = []\n\nreturn web.json_response({\n    \"remote\": name,\n    \"branch\": branch,\n    \"commits_ahead\": commits_ahead,\n    \"commits\": outgoing,\n    ...\n})\n```\n\n**IMPORTANT - First push handling:**\n`get_sync_status()` (git_manager.py:671-675) already handles the first-push case: when `remote/{branch}` doesn't exist, it counts all local commits via `git_rev_list_count_single` and returns `{\"ahead\": local_count, \"behind\": 0, \"remote_branch_exists\": False}`. So `commits_ahead` is always correct. For first push, we DON'T use a rev_range ‚Äî just `get_version_history(limit=commits_ahead)` to get the last N commits.\n\n### D) Update existing tests\n\n**CRITICAL:** The test fixture at testing/integration/panel/conftest.py:32 creates `mock_env.git_manager = Mock()`. After this change, the endpoint calls `env.git_manager.get_version_history(...)`. On a generic Mock, this returns another Mock object. When `web.json_response()` tries to serialize it to JSON, it will **fail with a TypeError** because Mock objects aren't JSON-serializable.\n\n**Fix:** Add default mock in conftest.py:32-36:\n```python\nmock_env.git_manager = Mock()\nmock_env.git_manager.get_version_history = Mock(return_value=[])\n```\n\n**Also update test_success_with_outgoing_commits** (test_remotes_endpoints.py:737-758) to verify commits are returned:\n```python\nmock_environment.git_manager.get_version_history = Mock(return_value=[\n    {\"hash\": \"abc1234\", \"refs\": \"\", \"message\": \"Test commit\", \"date\": \"2025-01-15 11:00:00\", \"date_relative\": \"1 hour ago\"}\n])\n# ... then assert data[\"commits\"][0][\"hash\"] == \"abc1234\"\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/utils/git.py (lines 376-383) - Add rev_range param to git_history\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/git_manager.py (lines 255-269) - Add rev_range param to get_version_history, pass through to git_history\n- server/api/v2/remotes.py (lines 400-415) - Fetch \u0026 return outgoing commits\n- testing/integration/panel/conftest.py (line 32-36) - Add get_version_history default mock\n- testing/integration/panel/test_remotes_endpoints.py (lines 737-758) - Update test to mock and assert commits\n\n**Files READ (reference only):**\n- frontend/src/components/base/molecules/PushModal.vue (lines 82-88) - Confirms frontend iterates commits with: commit.short_hash || commit.hash.slice(0,7), commit.message, commit.date_relative || commit.relative_date\n- frontend/src/types/comfygit.ts (lines 66-74, 492-503) - CommitInfo interface: hash, short_hash?, message, date, date_relative?, relative_date?, refs?\n- /data/projects/comfygit-ai/comfygit/packages/core/src/comfygit_core/managers/git_manager.py (lines 638-682) - get_sync_status shows first-push returns ahead=local_count with remote_branch_exists=False\n\n## Field mapping (backend ‚Üí frontend):\n- get_version_history returns: `{hash, refs, message, date, date_relative}`\n- Frontend CommitInfo expects: `{hash, short_hash?, message, date, date_relative?, relative_date?, refs?}`\n- `hash` from backend is a 7-char short hash (from git %h) ‚Äî frontend fallback `commit.hash.slice(0,7)` works fine\n- `refs` from backend is a string ‚Äî frontend expects optional `string[]` ‚Äî but the PushModal template doesn't display refs so this is irrelevant\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-thb (info icon fix) ‚Äî no file overlap\n\n**Cannot Run In Parallel With:**\n- Nothing\n\n## Estimated Scope\n- **Size:** Medium (~60 lines across 5 files)\n- **Risk:** Medium (touches core library, but additive-only: new optional param)\n\n## Acceptance Criteria\n- [ ] Push preview endpoint returns actual commit objects in the commits array\n- [ ] Each commit has: hash, refs, message, date, date_relative (matching get_version_history output)\n- [ ] Frontend PushModal renders the commit list with hash, message, and relative date\n- [ ] First-push scenario (no remote branch) returns last N commits without using rev_range\n- [ ] Normal push scenario uses origin/branch..HEAD rev_range\n- [ ] All existing tests pass: uv run pytest testing/integration/panel/test_remotes_endpoints.py -v\n- [ ] Updated test verifies commits array is populated\n\n## Testing Requirements\n- **Existing tests that WILL break without updates:** TestPushPreviewEndpoint (all 5 tests) ‚Äî need get_version_history mock in conftest\n- **Test to update:** test_success_with_outgoing_commits ‚Äî add get_version_history mock with sample data, assert commits in response\n- **Manual verification:** Open push modal in ComfyUI, verify commit list appears","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-30T14:02:19.171193619-05:00","created_by":"ubuntu","updated_at":"2026-01-30T14:15:55.200340327-05:00","closed_at":"2026-01-30T14:15:55.200340327-05:00","close_reason":"Implemented by sprint run-1769800134274552135"}
{"id":"cgm-yah","title":"Skip Models step when only download intents exist (no user choices needed)","notes":"# Context \u0026 Goal\n\n## Problem\nWhen a workflow has models with download URLs embedded (via `properties.models`), the Models step still shows but displays \"No models need resolution\" or an unhelpful empty interface. The user has no choices to make - the models already have known download sources.\n\n## Why It Matters\nUsers are forced to click through an empty/useless screen. This wastes time and confuses users who wonder why they're seeing a \"Models\" step with nothing to do.\n\n## How It Serves Project Goals\nStreamlined UX with fewer unnecessary clicks. Users only see steps where they have actual decisions to make.\n\n---\n\n# Current State vs Target State\n\n## Current Code (PROBLEM)\n\n**File:** `frontend/src/components/WorkflowResolveModal.vue` (lines 431-434)\n\n```typescript\n// Show Models step if there are unresolved/ambiguous OR download intents to review\nif (needsModelResolution.value || hasDownloadIntents.value) {\n  steps.push({ id: 'models', label: 'Models' })\n}\n```\n\nThe step shows whenever there are download intents, even if user has no choices to make.\n\n## Target Code (SOLUTION)\n\n```typescript\n// Show Models step ONLY if user needs to make choices (unresolved/ambiguous)\n// Download intents don't require user input - they're auto-confirmed\nif (needsModelResolution.value) {\n  steps.push({ id: 'models', label: 'Models' })\n}\n```\n\n---\n\n# Files Inventory\n\n**Files MODIFIED (write):**\n- `frontend/src/components/WorkflowResolveModal.vue` (lines 431-434) - Remove hasDownloadIntents from condition\n\n**Files READ (reference only):**\n- `frontend/src/components/WorkflowResolveModal.vue` - Understanding step flow\n\n**Files CREATED:**\n- None\n\n---\n\n# Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-447 (different lines in same file - 636 vs 431)\n\n**Cannot Run In Parallel With:**\n- Any task modifying wizardSteps computed (lines 420-444)\n\n**Blocking Reason:**\n- None - this is a leaf task\n\n---\n\n# Estimated Scope\n\n- **Size:** Small (\u003c10 lines) - single condition change\n- **Risk:** Low (isolated logic change)\n\n---\n\n# Acceptance Criteria\n\n- [ ] When workflow has ONLY download intents (no unresolved/ambiguous), Models step is skipped\n- [ ] When workflow has unresolved OR ambiguous models, Models step still shows\n- [ ] When workflow has both download intents AND unresolved models, Models step shows\n- [ ] Navigation flow goes Analysis ‚Üí Review when only intents exist\n\n---\n\n# Testing Requirements\n\n**Manual Verification:**\n1. Open a workflow where all missing models have download URLs (property_download_intent)\n2. Verify step indicators show: Analysis ‚Üí Review (no Models step)\n3. Open a workflow with truly unresolved models (no URL)\n4. Verify Models step appears","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-22T14:28:29.094496459-05:00","created_by":"ubuntu","updated_at":"2026-01-22T14:46:23.453157695-05:00","closed_at":"2026-01-22T14:46:23.453157695-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-yah","depends_on_id":"cgm-1cj","type":"parent-child","created_at":"2026-01-22T14:30:08.780768897-05:00","created_by":"ubuntu"}]}
{"id":"cgm-yc3","title":"Install matching manager version from GitHub during env creation","description":"## Context \u0026 Goal\n\nWhen creating a new managed environment, comfygit-manager is installed from the Comfy Registry\nvia `env.node_manager.add_node(\"comfygit-manager\")`. The registry returns whatever version it\nconsiders \"latest\" -- but registry approval can lag behind actual releases. This caused a real\nissue: v0.0.17 was published but the registry still served v0.0.16 (status: Pending), so new\nenvironments got a stale manager version.\n\n**Goal:** When the environment factory runs inside a ComfyUI process that already has\ncomfygit-manager installed (the normal panel-triggered flow), install the **same version**\nfrom our GitHub repo using the version tag. Fall back to registry for CLI-triggered creation\nwhere the manager package is not installed.\n\nThis gives us full control over release cadence for our own bootstrapping infrastructure\nwithout depending on a third-party registry approval timeline.\n\n## Current State vs Target State\n\n### Current Code\n\n**File:** `core/src/comfygit_core/constants.py:74-75`\n```python\n# The manager node ID - used for environment creation and migration logic.\nMANAGER_NODE_ID = 'comfygit-manager'\n```\n\n**File:** `core/src/comfygit_core/factories/environment_factory.py:260-276`\n```python\n# Phase: Install comfygit-manager as tracked node (85%)\n_progress(\"install_manager\", \"Installing comfygit-manager\", 85)\ntry:\n    from ..constants import MANAGER_NODE_ID\n    logger.info(f\"Installing {MANAGER_NODE_ID} as tracked node...\")\n    env.node_manager.add_node(MANAGER_NODE_ID)\n    logger.info(f\"{MANAGER_NODE_ID} installed successfully\")\n\n    # Upgrade workspace schema if this is a legacy workspace\n    # (new envs with per-env manager = modern workspace)\n    if workspace.upgrade_schema_if_needed():\n        logger.info(\"Upgraded workspace to schema v2 (per-environment manager)\")\nexcept Exception as e:\n    # Manager installation failure is non-fatal - environment still works\n    logger.warning(f\"Could not install {MANAGER_NODE_ID}: {e}\")\n    logger.warning(\"Environment will work but manager panel will be unavailable\")\n_complete(\"install_manager\")\n```\n\n### Target Code\n\n**File:** `constants.py` -- add new constant after line 75:\n```python\nMANAGER_NODE_ID = 'comfygit-manager'\nMANAGER_GITHUB_URL = 'https://github.com/comfygit-ai/comfygit-manager'\n```\n\n**File:** `environment_factory.py` -- replace the install_manager phase:\n```python\n# Phase: Install comfygit-manager as tracked node (85%)\n_progress(\"install_manager\", \"Installing comfygit-manager\", 85)\ntry:\n    from ..constants import MANAGER_GITHUB_URL, MANAGER_NODE_ID\n\n    # Determine install identifier:\n    # If running inside a ComfyUI instance with manager installed,\n    # use GitHub + version tag for immediate availability (no registry delay).\n    # Otherwise (CLI context), fall back to registry ID.\n    identifier = MANAGER_NODE_ID  # Default: registry lookup\n    try:\n        from importlib.metadata import version as pkg_version\n        current_version = pkg_version(MANAGER_NODE_ID)\n        if current_version and \"dev\" not in current_version:\n            identifier = f\"{MANAGER_GITHUB_URL}@v{current_version}\"\n            logger.info(f\"Detected manager v{current_version}, installing from GitHub\")\n    except Exception:\n        logger.info(f\"Manager version not detected, installing from registry\")\n\n    env.node_manager.add_node(identifier)\n    logger.info(f\"{MANAGER_NODE_ID} installed successfully\")\n\n    # Upgrade workspace schema if this is a legacy workspace\n    # (new envs with per-env manager = modern workspace)\n    if workspace.upgrade_schema_if_needed():\n        logger.info(\"Upgraded workspace to schema v2 (per-environment manager)\")\nexcept Exception as e:\n    # Manager installation failure is non-fatal - environment still works\n    logger.warning(f\"Could not install {MANAGER_NODE_ID}: {e}\")\n    logger.warning(\"Environment will work but manager panel will be unavailable\")\n_complete(\"install_manager\")\n```\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `packages/core/src/comfygit_core/constants.py` (line 75) -- add MANAGER_GITHUB_URL constant\n- `packages/core/src/comfygit_core/factories/environment_factory.py` (lines 260-276) -- version detection + GitHub install logic\n\n**Files READ (reference only):**\n- `packages/core/src/comfygit_core/managers/node_manager.py` -- verify add_node() handles GitHub URLs with @version\n- `packages/core/src/comfygit_core/services/node_lookup_service.py` -- verify find_node() parses @version from GitHub URLs\n- `packages/core/tests/integration/test_per_environment_manager.py` -- existing test patterns\n\n**Files CREATED:**\n- None (add test to existing test file)\n\n## Parallelization Info\n\n**Can Run In Parallel With:** Any bead not touching core library factory/constants\n**Cannot Run In Parallel With:** Anything modifying environment_factory.py or constants.py\n**Blocking Reason:** N/A -- this is a standalone change\n\n## Estimated Scope\n- **Size:** Small (less than 50 lines changed)\n- **Risk:** Medium -- touches the environment creation pipeline in core, but change is small and has clean fallback to existing behavior\n\n## Design Decisions\n\n1. **importlib.metadata vs reading pyproject.toml** -- importlib.metadata is the standard Python way to query installed package versions. Works regardless of install method (pip, uv, editable).\n\n2. **dev version guard** -- if version contains \"dev\" (e.g. 0.0.18.dev1), skip GitHub tag lookup since dev versions will not have release tags. Fall back to registry.\n\n3. **Graceful fallback** -- any failure in version detection falls through to the existing registry-based install. CLI-triggered creation (where comfygit-manager is not installed) works exactly as before.\n\n4. **GitHub tag convention** -- tags follow the pattern v{version} (e.g. v0.0.17). The _is_valid_git_ref() function in node_lookup_service.py already handles these (starts with v + digit = True).\n\n5. **Security** -- GitHub repo is owned by the same org. HTTPS clone with pinned tag is deterministic and at least as secure as registry CDN downloads. No new attack surface.\n\n## Acceptance Criteria\n- [ ] New environments created from panel (manager installed) get the same manager version as source\n- [ ] New environments created from CLI (no manager installed) fall back to registry install\n- [ ] Dev versions (containing \"dev\") fall back to registry install\n- [ ] If GitHub is unreachable, the install_manager phase fails gracefully (non-fatal, env still usable)\n- [ ] MANAGER_GITHUB_URL constant exists in constants.py\n\n## Testing Requirements\n\n**Existing tests:** test_per_environment_manager.py covers manager status tracking but not the install-from-GitHub flow.\n\n**New tests needed (add to environment factory tests or per-env manager tests):**\n1. Mock importlib.metadata.version() to return \"0.0.17\" -\u003e verify add_node called with GitHub URL\n2. Mock importlib.metadata.version() to raise PackageNotFoundError -\u003e verify add_node called with registry ID\n3. Mock importlib.metadata.version() to return \"0.0.18.dev1\" -\u003e verify add_node called with registry ID\n\nThese are unit tests that mock the node_manager.add_node call and importlib.metadata.version.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-02-02T20:28:17.017687169-05:00","created_by":"ubuntu","updated_at":"2026-02-02T21:31:18.449903756-05:00","closed_at":"2026-02-02T21:31:18.449903756-05:00","close_reason":"Closed"}
{"id":"cgm-yg1","title":"Add HF token to WorkspaceSettingsContent.vue","notes":"## Context \u0026 Goal\nAdd HuggingFace token input to the API Credentials section of WorkspaceSettingsContent.vue, following the same pattern as CivitAI.\n\n**Why it matters:** Users need a place to configure their HF token persistently. The Settings page is the natural home for this.\n\n## Current State vs Target State\n\n**Current** (`/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/WorkspaceSettingsContent.vue`):\n\nLines 27-42 - Only CivitAI:\n```vue\n\u003cSectionGroup title=\"API CREDENTIALS\"\u003e\n  \u003cdiv class=\"settings-section\"\u003e\n    \u003cSettingRow\n      label=\"CivitAI API Key\"\n      description=\"API key for downloading models from CivitAI\"\n    \u003e\n      \u003cTextInput\n        v-model=\"civitaiToken\"\n        type=\"password\"\n        placeholder=\"Enter CivitAI API key...\"\n        :style=\"{ minWidth: '300px' }\"\n      /\u003e\n    \u003c/SettingRow\u003e\n  \u003c/div\u003e\n\u003c/SectionGroup\u003e\n```\n\n**Target:**\n```vue\n\u003cSectionGroup title=\"API CREDENTIALS\"\u003e\n  \u003cdiv class=\"settings-section\"\u003e\n    \u003cSettingRow\n      label=\"CivitAI API Key\"\n      description=\"API key for downloading models from CivitAI\"\n    \u003e\n      \u003cTextInput\n        v-model=\"civitaiToken\"\n        type=\"password\"\n        placeholder=\"Enter CivitAI API key...\"\n        :style=\"{ minWidth: '300px' }\"\n        @input=\"civitaiTokenDirty = true\"\n      /\u003e\n    \u003c/SettingRow\u003e\n\n    \u003cSettingRow\n      label=\"HuggingFace Token\"\n      description=\"Access token for downloading gated/private models from HuggingFace\"\n    \u003e\n      \u003cTextInput\n        v-model=\"huggingfaceToken\"\n        type=\"password\"\n        placeholder=\"Enter HuggingFace token...\"\n        :style=\"{ minWidth: '300px' }\"\n        @input=\"hfTokenDirty = true\"\n      /\u003e\n    \u003c/SettingRow\u003e\n  \u003c/div\u003e\n\u003c/SectionGroup\u003e\n```\n\nAlso update script section:\n\nLine 125 - Add refs:\n```typescript\nconst huggingfaceToken = ref\u003cstring\u003e('')\nconst civitaiTokenDirty = ref(false)\nconst hfTokenDirty = ref(false)\n```\n\nLines 143-151 - Update hasChanges computed:\n```typescript\nconst hasChanges = computed(() =\u003e {\n  if (!originalConfig.value) return false\n\n  const civitaiChanged = civitaiTokenDirty.value\n  const hfChanged = hfTokenDirty.value\n  const extraArgsChanged = comfyuiExtraArgs.value !== argsToString(originalConfig.value.comfyui_extra_args || [])\n\n  return civitaiChanged || hfChanged || extraArgsChanged\n})\n```\n\nLines 161-163 - Update loadSettings:\n```typescript\ncivitaiToken.value = config.value.civitai_api_key || ''\nhuggingfaceToken.value = config.value.huggingface_token || ''\ncivitaiTokenDirty.value = false\nhfTokenDirty.value = false\n```\n\nLines 183-191 - Update saveSettings:\n```typescript\n// Only send tokens if user actually modified them (dirty tracking prevents saving masked values)\nif (civitaiTokenDirty.value) {\n  updates.civitai_api_key = civitaiToken.value || null\n}\nif (hfTokenDirty.value) {\n  updates.huggingface_token = huggingfaceToken.value || null\n}\n```\n\nLines 213-218 - Update resetSettings:\n```typescript\nfunction resetSettings() {\n  if (originalConfig.value) {\n    civitaiToken.value = originalConfig.value.civitai_api_key || ''\n    huggingfaceToken.value = originalConfig.value.huggingface_token || ''\n    comfyuiExtraArgs.value = argsToString(originalConfig.value.comfyui_extra_args || [])\n    civitaiTokenDirty.value = false\n    hfTokenDirty.value = false\n    saveStatus.value = null\n  }\n}\n```\n\n## Important: Masked Token Behavior\n\nSince the API returns masked tokens (e.g., \"***abcd\"), BOTH civitai and HF inputs will show masked values. To prevent accidentally saving the mask as the actual token, we use **dirty tracking** for BOTH tokens:\n\n1. `civitaiTokenDirty` and `hfTokenDirty` refs track if user modified the field\n2. Only send token in update payload if dirty flag is true\n3. Reset dirty flags on load and reset\n\nThis ensures:\n- Saving without touching token fields ‚Üí no change to stored tokens\n- Clearing a field and saving ‚Üí token is removed (null)\n- Entering new token and saving ‚Üí token is updated\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- `/data/projects/comfygit-ai/comfygit-manager/frontend/src/components/WorkspaceSettingsContent.vue` - Add HF token input and dirty tracking for BOTH tokens\n\n**Files READ (reference only):**\n- `/data/projects/comfygit-ai/comfygit-manager/frontend/src/types/comfygit.ts` - ConfigSettings interface (already has huggingface_token at line 352)\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-xha (TokenConfigModal) - different file\n\n**Cannot Run In Parallel With:**\n- cgm-wqg (backend API) - MUST complete first (API must work)\n\n**Blocking Reason:**\n- None (leaf node for settings UI)\n\n## Estimated Scope\n- **Size:** Small (~50 lines)\n- **Risk:** Low (template addition following existing pattern)\n\n## Acceptance Criteria\n- [ ] HuggingFace Token input appears in API CREDENTIALS section\n- [ ] Both inputs show masked value (***xxxx) when token is configured\n- [ ] Clearing input and saving removes the token\n- [ ] Entering new token and saving updates the token\n- [ ] Saving unchanged masked value does NOT accidentally set token to masked string\n- [ ] CivitAI also has dirty tracking (both tokens consistent)\n- [ ] hasChanges detects token modifications via dirty flags\n- [ ] Reset restores original masked value AND resets dirty flags\n\n## Testing Requirements\n- Manual: Open settings, verify HF field appears below CivitAI\n- Manual: Set token, save, reload - verify masked display\n- Manual: Clear token, save - verify removed\n- Manual: Leave token unchanged, save - verify no accidental update\n- Manual: Verify same behavior for CivitAI token\n- Build frontend: `cd frontend \u0026\u0026 bun run build`","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-29T15:27:21.430867831-05:00","created_by":"ubuntu","updated_at":"2026-01-29T22:17:37.515472035-05:00","closed_at":"2026-01-29T22:17:37.515472035-05:00","close_reason":"Implemented HuggingFace token input in WorkspaceSettingsContent.vue with dirty tracking for both CivitAI and HF tokens. Built frontend successfully.","dependencies":[{"issue_id":"cgm-yg1","depends_on_id":"cgm-wqg","type":"blocks","created_at":"2026-01-29T15:27:49.4246017-05:00","created_by":"ubuntu"}]}
{"id":"cgm-z5o","title":"Intercept ComfyUI Missing Resources Popup","description":"Replace ComfyUI's built-in missing nodes/models popup with ComfyGit's own UI. This ensures models are downloaded to correct locations and custom nodes are installed through ComfyGit's managed environment system.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-23T00:35:39.012722836-05:00","created_by":"ubuntu","updated_at":"2026-01-23T02:10:23.11572377-05:00","closed_at":"2026-01-23T02:10:23.11572377-05:00","close_reason":"All subtasks completed - popup interception system fully implemented"}
{"id":"cgm-z5o.1","title":"Add /v2/comfygit/workflow/analyze-json endpoint","notes":"## Context \u0026 Goal\n\nAdd a new backend endpoint that accepts raw workflow JSON and returns analysis results. This enables analyzing workflows that are loaded in the browser but not yet saved to disk.\n\n**Prerequisite:** Core library bead cg-2ro (WorkflowDependencyParser refactor) must be completed first.\n\n**Why it matters:** This is the backend half of the \"intercept missing resources popup\" feature. The frontend extension will call this endpoint with the workflow JSON when a workflow is loaded.\n\n## Current State vs Target State\n\n**Current:** No endpoint exists for analyzing in-memory workflow JSON. Only `/v2/comfygit/workflow/{name}/analyze` which requires workflow to be saved on disk (lines 624-709).\n\n**Target:** New endpoint `/v2/comfygit/workflow/analyze-json` that:\n1. Accepts POST with workflow JSON in body\n2. Parses workflow using Workflow.from_json()\n3. Uses WorkflowDependencyParser with Workflow object (not path)\n4. Returns analysis results matching existing analyze endpoint format\n\n## Target Code\n\nAdd after line 709 in `server/api/v2/workflows.py`:\n\n\\`\\`\\`python\n@routes.post(\"/v2/comfygit/workflow/analyze-json\")\n@requires_environment\nasync def analyze_workflow_json(request: web.Request, env) -\u003e web.Response:\n    \"\"\"Analyze workflow JSON directly without requiring file on disk.\n    \n    Used for analyzing workflows loaded in browser before save.\n    Request body: { \"workflow\": \u003cworkflow_json_object\u003e, \"name\": \"optional_name\" }\n    \"\"\"\n    try:\n        body = await request.json()\n    except Exception:\n        return web.json_response({\"error\": \"Invalid JSON body\"}, status=400)\n    \n    workflow_data = body.get(\"workflow\")\n    workflow_name = body.get(\"name\", \"unsaved\")\n    \n    if not workflow_data:\n        return web.json_response({\"error\": \"Missing workflow data\"}, status=400)\n    \n    # Parse workflow from JSON (no file needed)\n    from comfygit_core.models.workflow import Workflow\n    try:\n        workflow = Workflow.from_json(workflow_data)\n    except Exception as e:\n        return web.json_response({\"error\": f\"Invalid workflow format: {e}\"}, status=400)\n    \n    # Use WorkflowDependencyParser with Workflow object (requires cg-2ro refactor)\n    from comfygit_core.analyzers.workflow_dependency_parser import WorkflowDependencyParser\n    parser = WorkflowDependencyParser(\n        workflow=workflow,\n        workflow_name=workflow_name,\n        cec_path=env.cec_path\n    )\n    dependencies = parser.analyze_dependencies()\n    \n    # Use the same resolution logic as analyze_workflow\n    # Note: We create a temporary resolution context without pyproject access\n    # since this workflow isn't saved yet\n    result = await run_sync(\n        env.workflow_manager.resolve_workflow,\n        dependencies\n    )\n    \n    # Determine uninstalled nodes (same logic as analyze_workflow lines 641-648)\n    # For unsaved workflows, check against environment's installed packages\n    installed_packages = set(env.workflow_manager.get_installed_package_ids())\n    uninstalled_set = {\n        n.package_id for n in result.nodes_resolved \n        if n.package_id and n.package_id not in installed_packages\n    }\n    \n    # Same stats calculation as analyze_workflow (lines 652-676)\n    nodes_needing_installation = sum(\n        1 for n in result.nodes_resolved if n.package_id in uninstalled_set\n    )\n    packages_needing_installation = len(uninstalled_set)\n    needs_user_input = bool(\n        result.nodes_unresolved or result.nodes_ambiguous or\n        result.models_unresolved or result.models_ambiguous\n    )\n    download_intents_count = sum(\n        1 for m in result.models_resolved\n        if m.match_type in (\"download_intent\", \"property_download_intent\")\n    )\n    is_fully_resolved = (\n        not needs_user_input\n        and nodes_needing_installation == 0\n        and download_intents_count == 0\n    )\n    \n    # Transform to frontend format (same structure as analyze_workflow lines 678-707)\n    response = {\n        \"workflow\": workflow_name,\n        \"nodes\": {\n            \"resolved\": [_serialize_resolved_node(n, workflow_name, uninstalled_set) for n in result.nodes_resolved],\n            \"unresolved\": [_serialize_unresolved_node(n, workflow_name) for n in result.nodes_unresolved],\n            \"ambiguous\": [\n                amb for amb in [_serialize_ambiguous_node(opts, workflow_name, uninstalled_set) for opts in result.nodes_ambiguous]\n                if amb is not None\n            ]\n        },\n        \"models\": {\n            \"resolved\": [_serialize_resolved_model(m) for m in result.models_resolved],\n            \"unresolved\": [_serialize_unresolved_model(m, workflow_name) for m in result.models_unresolved],\n            \"ambiguous\": [\n                amb for amb in [_serialize_ambiguous_model(opts) for opts in result.models_ambiguous]\n                if amb is not None\n            ]\n        },\n        \"stats\": {\n            \"total_nodes\": len(result.nodes_resolved) + len(result.nodes_unresolved) + len(result.nodes_ambiguous),\n            \"total_models\": len(result.models_resolved) + len(result.models_unresolved) + len(result.models_ambiguous),\n            \"download_intents\": download_intents_count,\n            \"nodes_needing_installation\": nodes_needing_installation,\n            \"packages_needing_installation\": packages_needing_installation,\n            \"needs_user_input\": needs_user_input,\n            \"is_fully_resolved\": is_fully_resolved,\n            \"models_with_category_mismatch\": sum(1 for m in result.models_resolved if getattr(m, 'has_category_mismatch', False))\n        }\n    }\n    \n    return web.json_response(response)\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- server/api/v2/workflows.py - add new endpoint after line 709 (~80 lines)\n\n**Files READ (reference only):**\n- server/api/v2/workflows.py (lines 624-709) - existing analyze_workflow for reference\n- server/api/v2/workflows.py (lines 720-760) - _serialize_* helper functions\n- server/cgm_core/decorators.py - requires_environment decorator\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Frontend extension registration bead cgm-z5o.2 (no file overlap)\n- Frontend popup component bead cgm-z5o.3 (no file overlap)\n\n**Cannot Run In Parallel With:**\n- Any other bead modifying workflows.py\n\n**Blocking Reason:**\n- Frontend needs this endpoint to get analysis results for in-browser workflows\n- **CRITICAL:** Depends on core library bead cg-2ro being completed first (WorkflowDependencyParser refactor)\n\n## Estimated Scope\n- **Size:** Medium (80-100 lines)\n- **Risk:** Low (new endpoint, doesn't modify existing code, reuses existing helpers)\n\n## Acceptance Criteria\n- [ ] Endpoint accepts POST with workflow JSON in body\n- [ ] Returns 400 if workflow data is missing or invalid\n- [ ] Returns 400 if workflow JSON can't be parsed (malformed)\n- [ ] Returns analysis results matching /workflow/{name}/analyze format exactly\n- [ ] Works with workflows containing subgraphs (ComfyUI v1.24.3+)\n- [ ] Node types correctly classified as builtin vs custom\n- [ ] Model references extracted with URLs from properties.models\n- [ ] Uninstalled packages correctly identified\n\n## Testing Requirements\n- Add test in testing/integration/panel/test_workflows.py\n- Test with valid workflow JSON (use existing test fixtures)\n- Test with invalid/malformed JSON\n- Test with workflow containing subgraphs\n- Verify response format matches existing analyze endpoint\n- Test with workflow that has missing nodes\n- Test with workflow that has missing models\n\n## Notes on Dependencies\n\nThis endpoint will NOT work until cg-2ro is complete. The call:\n\\`\\`\\`python\nparser = WorkflowDependencyParser(\n    workflow=workflow,  # Workflow object, not Path\n    ...\n)\n\\`\\`\\`\n...requires the refactored constructor that accepts Workflow objects.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T00:36:05.506281441-05:00","created_by":"ubuntu","updated_at":"2026-01-23T01:36:51.218972805-05:00","closed_at":"2026-01-23T01:36:51.218972805-05:00","close_reason":"Endpoint implemented with 12 passing tests. Uses core library's refactored WorkflowDependencyParser (cg-2ro).","dependencies":[{"issue_id":"cgm-z5o.1","depends_on_id":"cgm-z5o","type":"parent-child","created_at":"2026-01-23T00:36:05.507351558-05:00","created_by":"ubuntu"}]}
{"id":"cgm-z5o.2","title":"Register ComfyGit extension to intercept workflow load","notes":"## Context \u0026 Goal\n\nRegister a ComfyGit extension with ComfyUI's extension system to:\n1. Disable ComfyUI's built-in missing nodes/models warning popups\n2. Hook into beforeConfigureGraph to capture workflow data when workflows are loaded\n3. Trigger ComfyGit's own analysis flow\n\n**Why it matters:** This is the entry point for the \"intercept missing resources popup\" feature. Without this, ComfyUI shows its own popups which download models to wrong locations.\n\n## Current State vs Target State\n\n**Current:** ComfyGit registers extension `Comfy.ComfyGitPanel` in main.ts (lines 479-789) with a `setup()` hook. It does NOT hook into workflow loading.\n\n**Target:** Extend the existing extension registration to:\n1. Hook beforeConfigureGraph to disable ComfyUI warnings and capture workflow\n2. Dispatch custom event that our popup component can listen to\n\n## Target Code\n\nModify the existing extension in `frontend/src/main.ts` around line 480:\n\n\\`\\`\\`typescript\n// Register extension\napp.registerExtension({\n  name: 'Comfy.ComfyGitPanel',\n\n  // NEW: Hook into workflow loading to intercept missing resources\n  async beforeConfigureGraph(graphData, missingNodeTypes) {\n    // Disable ComfyUI's built-in popups by modifying the workflow data\n    // Note: We can't directly access settingStore from our bundle, \n    // but we can intercept here before the dialogs are shown\n    \n    // Store for later use by afterConfigureGraph\n    (window as any).__comfygit_pending_workflow = {\n      graphData,\n      missingNodeTypes,\n      timestamp: Date.now()\n    }\n  },\n\n  async afterConfigureGraph(missingNodeTypes) {\n    const pending = (window as any).__comfygit_pending_workflow\n    if (!pending) return\n    delete (window as any).__comfygit_pending_workflow\n    \n    // Dispatch event for our popup component\n    window.dispatchEvent(new CustomEvent('comfygit:workflow-loaded', {\n      detail: {\n        workflow: pending.graphData,\n        missingNodeTypes: missingNodeTypes,\n        timestamp: pending.timestamp\n      }\n    }))\n  },\n\n  async setup() {\n    // ... existing setup code (unchanged)\n  }\n})\n\\`\\`\\`\n\n**CRITICAL INSIGHT:** We cannot easily access ComfyUI's `useSettingStore` from our bundle because it's part of their Vue app context. However, looking at the ComfyUI source, the settings are checked INSIDE `loadGraphData()` right before showing dialogs. The extension hooks `beforeConfigureGraph` and `afterConfigureGraph` are called during this process.\n\n**Alternative approach if settings can't be disabled:** Show our popup AFTER ComfyUI's popup appears, then immediately close ComfyUI's using DOM manipulation:\n\\`\\`\\`typescript\n// In afterConfigureGraph, after a small delay:\nsetTimeout(() =\u003e {\n  // Find and close ComfyUI's dialog\n  const comfyDialog = document.querySelector('[data-dialog-key=\"global-missing-nodes\"]')\n  if (comfyDialog) {\n    // Close it programmatically\n    comfyDialog.closest('.p-dialog')?.remove()\n  }\n}, 100)\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/main.ts (lines 479-490) - add beforeConfigureGraph and afterConfigureGraph hooks to existing extension\n\n**Files CREATED:**\n- None (reusing existing extension registration)\n\n**Files READ (reference only):**\n- /tmp/ComfyUI_frontend/src/types/comfy.ts (lines 232-243) - ComfyExtension interface for hook signatures\n- /tmp/ComfyUI_frontend/src/scripts/app.ts - how hooks are called\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend endpoint bead cgm-z5o.1 (different files)\n- Popup component bead cgm-z5o.3 (different files, though this bead is logically prerequisite)\n\n**Cannot Run In Parallel With:**\n- Any bead modifying main.ts\n\n**Blocking Reason:**\n- Popup component needs this to receive the workflow-loaded event\n\n## Estimated Scope\n- **Size:** Small (~30-40 lines added to existing code)\n- **Risk:** Medium (interacts with ComfyUI's internal APIs which may change)\n\n## Acceptance Criteria\n- [ ] Extension hooks beforeConfigureGraph and afterConfigureGraph are registered\n- [ ] Custom event 'comfygit:workflow-loaded' is dispatched with workflow data\n- [ ] Event contains graphData (the workflow JSON) and missingNodeTypes array\n- [ ] No errors in console when ComfyUI loads\n- [ ] Works with both new workflows and loaded workflows\n- [ ] Works with workflows containing subgraphs\n\n## Testing Requirements\n- Manual testing: Load ComfyUI, load a workflow, verify console shows event dispatch\n- Manual testing: Verify event.detail.workflow contains actual workflow data\n- Manual testing: Verify event.detail.missingNodeTypes contains any missing nodes\n- E2E test: Playwright test that verifies event is dispatched on workflow load\n\n## Important Notes\n\n1. **ComfyExtension interface** (from /tmp/ComfyUI_frontend/src/types/comfy.ts:232-243):\n   - beforeConfigureGraph(graphData: ComfyWorkflowJSON, missingNodeTypes: MissingNodeType[]): Promise\u003cvoid\u003e | void\n   - afterConfigureGraph(missingNodeTypes: MissingNodeType[]): Promise\u003cvoid\u003e | void\n\n2. **MissingNodeType** is either a string or an object with type/hint/action\n\n3. **Settings issue**: ComfyUI's settings are in a Pinia store that we don't have access to from our standalone bundle. We may need to explore alternative approaches like:\n   - Using ComfyUI's internal API if exposed\n   - DOM manipulation to close their dialogs\n   - Local storage settings (ComfyUI may read from localStorage)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T00:36:35.511077745-05:00","created_by":"ubuntu","updated_at":"2026-01-23T01:24:48.053429728-05:00","closed_at":"2026-01-23T01:24:48.053429728-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-z5o.2","depends_on_id":"cgm-z5o","type":"parent-child","created_at":"2026-01-23T00:36:35.511790153-05:00","created_by":"ubuntu"}]}
{"id":"cgm-z5o.3","title":"Create MissingResourcesPopup Vue component","notes":"## Context \u0026 Goal\n\nCreate a Vue component that shows when a workflow is loaded with missing nodes or models. This replaces ComfyUI's built-in popup with ComfyGit's own UI that:\n1. Uses ComfyGit's backend for accurate analysis\n2. Downloads models to correct ComfyGit-managed locations\n3. Installs nodes through ComfyGit's managed environment\n\n**Why it matters:** The built-in ComfyUI popup downloads models to a \"downloads\" folder and doesn't integrate with ComfyGit's environment management.\n\n## Current State vs Target State\n\n**Current:** No popup component for missing resources when loading workflows. ComfyUI shows its own popup.\n\n**Target:** New Vue component that:\n1. Listens for 'comfygit:workflow-loaded' event (dispatched by cgm-z5o.2)\n2. Calls /v2/comfygit/workflow/analyze-json endpoint (created by cgm-z5o.1)\n3. If issues found, shows modal with resolution options\n4. Integrates with existing resolution flow\n\n## Target Code\n\nCreate `frontend/src/components/MissingResourcesPopup.vue`:\n\n\\`\\`\\`vue\n\u003ctemplate\u003e\n  \u003cBaseModal \n    v-model:visible=\"isVisible\" \n    header=\"Missing Dependencies\"\n    :style=\"{ width: '500px' }\"\n    :closable=\"true\"\n    @hide=\"dismiss\"\n  \u003e\n    \u003cdiv v-if=\"loading\" class=\"loading-state\"\u003e\n      \u003ci class=\"pi pi-spin pi-spinner\" style=\"font-size: 1.5rem\" /\u003e\n      \u003cspan style=\"margin-left: 8px\"\u003eAnalyzing workflow...\u003c/span\u003e\n    \u003c/div\u003e\n    \n    \u003cdiv v-else-if=\"analysis \u0026\u0026 hasIssues\" class=\"analysis-results\"\u003e\n      \u003c!-- Missing Nodes Section --\u003e\n      \u003cdiv v-if=\"missingNodes.length \u003e 0\" class=\"section\"\u003e\n        \u003cdiv class=\"section-header\"\u003e\n          \u003cspan class=\"section-icon\"\u003eüì¶\u003c/span\u003e\n          \u003cspan\u003eMissing Custom Nodes ({{ missingNodes.length }})\u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"item-list\"\u003e\n          \u003cdiv v-for=\"node in missingNodes.slice(0, 5)\" :key=\"node.node_type\" class=\"item\"\u003e\n            \u003ccode class=\"node-type\"\u003e{{ node.node_type }}\u003c/code\u003e\n            \u003cspan v-if=\"node.package_id\" class=\"package-info\"\u003e\n              ‚Üí {{ node.package_title || node.package_id }}\n            \u003c/span\u003e\n            \u003cspan v-else class=\"not-found\"\u003eNot found in registry\u003c/span\u003e\n          \u003c/div\u003e\n          \u003cdiv v-if=\"missingNodes.length \u003e 5\" class=\"overflow-note\"\u003e\n            ...and {{ missingNodes.length - 5 }} more\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \n      \u003c!-- Missing Models Section --\u003e\n      \u003cdiv v-if=\"missingModels.length \u003e 0\" class=\"section\"\u003e\n        \u003cdiv class=\"section-header\"\u003e\n          \u003cspan class=\"section-icon\"\u003eüé®\u003c/span\u003e\n          \u003cspan\u003eMissing Models ({{ missingModels.length }})\u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"item-list\"\u003e\n          \u003cdiv v-for=\"model in missingModels.slice(0, 5)\" :key=\"model.widget_value\" class=\"item\"\u003e\n            \u003cspan class=\"model-name\"\u003e{{ model.widget_value }}\u003c/span\u003e\n            \u003cspan v-if=\"model.has_download_url\" class=\"has-url\"\u003e\n              \u003ci class=\"pi pi-download\" /\u003e Can auto-download\n            \u003c/span\u003e\n            \u003cspan v-else class=\"no-url\"\u003eManual download required\u003c/span\u003e\n          \u003c/div\u003e\n          \u003cdiv v-if=\"missingModels.length \u003e 5\" class=\"overflow-note\"\u003e\n            ...and {{ missingModels.length - 5 }} more\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \n      \u003c!-- Actions --\u003e\n      \u003cdiv class=\"actions\"\u003e\n        \u003cBaseButton @click=\"openPanel\" label=\"Open ComfyGit Panel\" /\u003e\n        \u003cBaseButton @click=\"dismiss\" label=\"Dismiss\" severity=\"secondary\" /\u003e\n      \u003c/div\u003e\n      \n      \u003c!-- Tip --\u003e\n      \u003cdiv class=\"tip\"\u003e\n        \u003ci class=\"pi pi-info-circle\" /\u003e\n        \u003cspan\u003eSave this workflow to track it in ComfyGit and enable dependency resolution.\u003c/span\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \n    \u003cdiv v-else-if=\"error\" class=\"error-state\"\u003e\n      \u003ci class=\"pi pi-exclamation-triangle\" /\u003e\n      \u003cspan\u003e{{ error }}\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/BaseModal\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nimport { ref, computed, onMounted, onUnmounted } from 'vue'\nimport BaseModal from './base/BaseModal.vue'\nimport BaseButton from './base/BaseButton.vue'\n\ninterface WorkflowLoadedEvent extends CustomEvent {\n  detail: {\n    workflow: any\n    missingNodeTypes: (string | { type: string })[]\n    timestamp: number\n  }\n}\n\nconst isVisible = ref(false)\nconst loading = ref(false)\nconst error = ref\u003cstring | null\u003e(null)\nconst analysis = ref\u003cany\u003e(null)\n\nconst hasIssues = computed(() =\u003e {\n  return missingNodes.value.length \u003e 0 || missingModels.value.length \u003e 0\n})\n\nconst missingNodes = computed(() =\u003e {\n  if (!analysis.value) return []\n  // Nodes that aren't installed\n  const resolved = analysis.value.nodes.resolved.filter((n: any) =\u003e !n.is_installed)\n  const unresolved = analysis.value.nodes.unresolved\n  return [...resolved, ...unresolved]\n})\n\nconst missingModels = computed(() =\u003e {\n  if (!analysis.value) return []\n  // Models that need download or aren't resolved\n  const needsDownload = analysis.value.models.resolved.filter((m: any) =\u003e \n    m.match_type === 'download_intent' || \n    m.match_type === 'property_download_intent' ||\n    m.match_type === 'not_found'\n  )\n  const unresolved = analysis.value.models.unresolved.map((m: any) =\u003e ({\n    ...m.reference,\n    has_download_url: false\n  }))\n  return [...needsDownload, ...unresolved]\n})\n\nasync function handleWorkflowLoaded(event: WorkflowLoadedEvent) {\n  const { workflow, missingNodeTypes } = event.detail\n  \n  // Quick check: if ComfyUI found no missing nodes, might still have missing models\n  // Always analyze to be sure, but only show UI if there are issues\n  loading.value = true\n  error.value = null\n  isVisible.value = true\n  \n  try {\n    // Call our backend endpoint\n    const response = await fetch('/v2/comfygit/workflow/analyze-json', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ workflow, name: 'unsaved' })\n    })\n    \n    if (!response.ok) {\n      const err = await response.json()\n      throw new Error(err.error || 'Failed to analyze workflow')\n    }\n    \n    analysis.value = await response.json()\n    \n    // Auto-dismiss if no issues found\n    if (!hasIssues.value) {\n      isVisible.value = false\n    }\n  } catch (e) {\n    console.error('[ComfyGit] Failed to analyze workflow:', e)\n    error.value = e instanceof Error ? e.message : 'Unknown error'\n    // Don't show error UI for now - just log and dismiss\n    isVisible.value = false\n  } finally {\n    loading.value = false\n  }\n}\n\nfunction openPanel() {\n  // Use existing showPanel function via custom event\n  // main.ts listens for this and calls showPanel()\n  window.dispatchEvent(new CustomEvent('comfygit:open-panel', {\n    detail: { initialView: 'workflows' }\n  }))\n  isVisible.value = false\n}\n\nfunction dismiss() {\n  isVisible.value = false\n  analysis.value = null\n}\n\nonMounted(() =\u003e {\n  window.addEventListener('comfygit:workflow-loaded', handleWorkflowLoaded as EventListener)\n})\n\nonUnmounted(() =\u003e {\n  window.removeEventListener('comfygit:workflow-loaded', handleWorkflowLoaded as EventListener)\n})\n\u003c/script\u003e\n\n\u003cstyle scoped\u003e\n.loading-state {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 2rem;\n}\n\n.section {\n  margin-bottom: 1rem;\n}\n\n.section-header {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  font-weight: 600;\n  margin-bottom: 0.5rem;\n}\n\n.section-icon {\n  font-size: 1.2rem;\n}\n\n.item-list {\n  background: var(--surface-ground);\n  border-radius: 4px;\n  padding: 0.5rem;\n}\n\n.item {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.25rem 0.5rem;\n  font-size: 0.875rem;\n}\n\n.node-type {\n  font-family: monospace;\n  background: var(--surface-100);\n  padding: 0.125rem 0.375rem;\n  border-radius: 2px;\n}\n\n.package-info {\n  color: var(--primary-color);\n}\n\n.not-found, .no-url {\n  color: var(--orange-500);\n  font-style: italic;\n}\n\n.has-url {\n  color: var(--green-500);\n}\n\n.overflow-note {\n  padding: 0.25rem 0.5rem;\n  color: var(--text-color-secondary);\n  font-style: italic;\n}\n\n.actions {\n  display: flex;\n  gap: 0.5rem;\n  justify-content: flex-end;\n  margin-top: 1rem;\n}\n\n.tip {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  margin-top: 1rem;\n  padding: 0.5rem;\n  background: var(--surface-ground);\n  border-radius: 4px;\n  font-size: 0.875rem;\n  color: var(--text-color-secondary);\n}\n\n.error-state {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 1rem;\n  color: var(--red-500);\n}\n\u003c/style\u003e\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/main.ts - mount popup component and add event listener for open-panel (~15 lines)\n\n**Files CREATED:**\n- frontend/src/components/MissingResourcesPopup.vue - new component (~180 lines)\n\n**Files READ (reference only):**\n- frontend/src/components/WorkflowResolveModal.vue - reference for styling patterns\n- frontend/src/components/base/BaseModal.vue - modal component\n- frontend/src/components/base/BaseButton.vue - button component\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Backend endpoint bead cgm-z5o.1 (different files)\n\n**Cannot Run In Parallel With:**\n- Integration bead cgm-z5o.4 (both modify main.ts)\n\n**Blocking Reason:**\n- This component is part of the final integration, but the Vue component itself can be developed independently\n\n## Estimated Scope\n- **Size:** Medium (180-200 lines)\n- **Risk:** Low (new component following existing patterns)\n\n## Acceptance Criteria\n- [ ] Component listens for 'comfygit:workflow-loaded' event\n- [ ] Shows loading state while analyzing\n- [ ] Displays missing nodes with package suggestions\n- [ ] Displays missing models with download availability indicator\n- [ ] \"Open ComfyGit Panel\" button dispatches 'comfygit:open-panel' event\n- [ ] Auto-dismisses if no issues found\n- [ ] Styled consistently with existing ComfyGit UI (BaseModal, etc.)\n- [ ] Limits displayed items to 5 with \"and X more\" overflow\n\n## Testing Requirements\n- Manual testing: Load workflow with missing nodes, verify popup appears\n- Manual testing: Verify missing nodes/models are listed correctly\n- Manual testing: Verify \"Open ComfyGit Panel\" opens the panel to workflows view\n- Manual testing: Verify popup auto-dismisses for valid workflow\n- E2E test: Playwright test for popup flow\n\n## Design Notes\n\nThe popup should be lightweight and informational. It's NOT meant to be the full resolution wizard. Instead, it:\n1. Alerts the user that dependencies are missing\n2. Shows a summary of what's missing (max 5 items + overflow)\n3. Directs them to the ComfyGit panel for full resolution\n\nThis keeps the popup simple while leveraging existing resolution UI in the panel.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-23T00:37:11.370320101-05:00","created_by":"ubuntu","updated_at":"2026-01-23T01:47:53.401039147-05:00","closed_at":"2026-01-23T01:47:53.401039147-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-z5o.3","depends_on_id":"cgm-z5o","type":"parent-child","created_at":"2026-01-23T00:37:11.371969529-05:00","created_by":"ubuntu"},{"issue_id":"cgm-z5o.3","depends_on_id":"cgm-z5o.2","type":"blocks","created_at":"2026-01-23T00:37:43.899434774-05:00","created_by":"ubuntu"}]}
{"id":"cgm-z5o.4","title":"Wire up missing resources flow and add service method","notes":"## Context \u0026 Goal\n\nComplete the missing resources flow by:\n1. Mounting MissingResourcesPopup in main.ts\n2. Adding event listener for 'comfygit:open-panel' to open panel from popup\n3. Ensuring event flow works end-to-end\n\n**Why it matters:** This connects all the pieces together into a working feature.\n\n## Current State vs Target State\n\n**Current:** Individual pieces exist but aren't connected:\n- cgm-z5o.1: Backend endpoint exists\n- cgm-z5o.2: Extension hooks dispatch 'comfygit:workflow-loaded' event\n- cgm-z5o.3: Popup component exists but isn't mounted\n\n**Target:** Complete flow:\n1. User loads workflow ‚Üí extension hooks fire ‚Üí event dispatched\n2. Popup receives event ‚Üí calls backend ‚Üí shows results\n3. User clicks \"Open Panel\" ‚Üí popup dispatches event ‚Üí panel opens\n\n## Target Code\n\n### Add to main.ts (after line 44):\n\n\\`\\`\\`typescript\nimport MissingResourcesPopup from './components/MissingResourcesPopup.vue'\n\n// Missing resources popup container\nlet missingResourcesContainer: HTMLElement | null = null\nlet missingResourcesApp: ReturnType\u003ctypeof createApp\u003e | null = null\n\\`\\`\\`\n\n### Add to setup() function (around line 524, after mountDownloadQueue()):\n\n\\`\\`\\`typescript\n// Mount missing resources popup\nmountMissingResourcesPopup()\n\n// Listen for open-panel event from popup\nwindow.addEventListener('comfygit:open-panel', (event: CustomEvent) =\u003e {\n  const initialView = event.detail?.initialView\n  showPanel(initialView)\n})\n\\`\\`\\`\n\n### Add new function (after mountDownloadQueue function, around line 288):\n\n\\`\\`\\`typescript\nfunction mountMissingResourcesPopup() {\n  if (missingResourcesContainer) return // Already mounted\n\n  missingResourcesContainer = document.createElement('div')\n  missingResourcesContainer.className = 'comfygit-missing-resources-root'\n\n  missingResourcesApp = createApp({\n    render: () =\u003e h(MissingResourcesPopup)\n  })\n\n  missingResourcesApp.mount(missingResourcesContainer)\n  document.body.appendChild(missingResourcesContainer)\n  console.log('[ComfyGit] Missing resources popup mounted')\n}\n\\`\\`\\`\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- frontend/src/main.ts - add import, mount popup, add event listener (~20 lines)\n\n**Files READ (reference only):**\n- frontend/src/components/MissingResourcesPopup.vue - verify integration\n- frontend/src/main.ts (existing pattern at lines 274-287) - mountDownloadQueue for reference\n\n**Files CREATED:**\n- None\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- Nothing - this is the final integration bead\n\n**Cannot Run In Parallel With:**\n- cgm-z5o.3 (popup component) - must be complete first\n- Any bead modifying main.ts\n\n**Blocking Reason:**\n- This is the final integration bead - depends on cgm-z5o.1, cgm-z5o.2, cgm-z5o.3\n\n## Estimated Scope\n- **Size:** Small (~20 lines)\n- **Risk:** Low (straightforward wiring following existing patterns)\n\n## Acceptance Criteria\n- [ ] MissingResourcesPopup is imported in main.ts\n- [ ] mountMissingResourcesPopup function exists and is called in setup()\n- [ ] 'comfygit:open-panel' event listener opens panel with initialView\n- [ ] Complete flow works: load workflow ‚Üí see popup (if issues) ‚Üí click \"Open Panel\" ‚Üí panel opens\n- [ ] Build succeeds without errors\n- [ ] No console errors during flow\n\n## Testing Requirements\n- Manual E2E test: full flow from workflow load to popup to panel\n- Verify popup appears for workflow with missing nodes\n- Verify popup auto-dismisses for valid workflow\n- Verify \"Open Panel\" opens to workflows view\n- Verify production build works\n\n## Integration Checklist\n\n1. [ ] Extension dispatches 'comfygit:workflow-loaded' on workflow load (cgm-z5o.2)\n2. [ ] Popup receives event and calls backend (cgm-z5o.3)\n3. [ ] Backend returns analysis in correct format (cgm-z5o.1)\n4. [ ] Popup displays results correctly (cgm-z5o.3)\n5. [ ] \"Open Panel\" dispatches 'comfygit:open-panel' event (cgm-z5o.3)\n6. [ ] main.ts listens for 'comfygit:open-panel' and calls showPanel() (this bead)\n7. [ ] Panel opens to workflows view (existing functionality)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-23T00:37:35.37763413-05:00","created_by":"ubuntu","updated_at":"2026-01-23T01:57:01.228959432-05:00","closed_at":"2026-01-23T01:57:01.228959432-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cgm-z5o.4","depends_on_id":"cgm-z5o","type":"parent-child","created_at":"2026-01-23T00:37:35.378382446-05:00","created_by":"ubuntu"},{"issue_id":"cgm-z5o.4","depends_on_id":"cgm-z5o.1","type":"blocks","created_at":"2026-01-23T00:37:57.492032854-05:00","created_by":"ubuntu"},{"issue_id":"cgm-z5o.4","depends_on_id":"cgm-z5o.2","type":"blocks","created_at":"2026-01-23T00:37:57.504389317-05:00","created_by":"ubuntu"},{"issue_id":"cgm-z5o.4","depends_on_id":"cgm-z5o.3","type":"blocks","created_at":"2026-01-23T00:37:57.517964204-05:00","created_by":"ubuntu"}]}
{"id":"cgm-z9g","title":"Bug: Missing Dependencies popup shows in non-managed environments","notes":"## Context \u0026 Goal\n\nWhen comfygit-manager is installed into a **non-managed** ComfyUI environment (i.e., one not inside a ComfyGit workspace), the \\\"Missing Dependencies\\\" popup still appears on workflow load. This popup should only show in managed environments ‚Äî non-managed environments should fall through to ComfyUI's native missing resource warnings instead.\n\nThis mirrors the existing pattern where the Manager button is hidden for non-managed environments.\n\n## Root Cause\n\nTwo problems in \\`frontend/src/main.ts\\`:\n\n1. **\\`beforeConfigureGraph\\` (lines 540-553) unconditionally suppresses ComfyUI's native warnings** ‚Äî it always sets \\`ShowMissingModelsWarning\\` and \\`ShowMissingNodesWarning\\` to false, even in non-managed mode\n2. **\\`afterConfigureGraph\\` (lines 555-564) unconditionally dispatches \\`comfygit:workflow-loaded\\`** ‚Äî triggers the MissingResourcesPopup regardless of environment type\n\nAdditionally, \\`MissingResourcesPopup.vue\\` has no awareness of managed state at all (no props, no check).\n\n### Race Condition Detail\n\n\\`currentSetupState\\` defaults to \\`'managed'\\` at line 61. The \\`fetchSetupStatus()\\` call happens at line 623 inside \\`setup()\\`. The graph hooks (\\`beforeConfigureGraph\\`, \\`afterConfigureGraph\\`) are registered at extension definition time and may fire before \\`setup()\\` completes its await. This means even after we add state checks, the default value matters ‚Äî it must default to a **safe** (non-managed) value.\n\n## Current State\n\n\\`\\`\\`typescript\n// main.ts line 61 ‚Äî defaults to managed (WRONG for safety)\nlet currentSetupState: SetupState = 'managed'\n\n// main.ts lines 540-553 ‚Äî always suppresses native warnings\nasync beforeConfigureGraph(graphData: any, _missingNodeTypes: any[]) {\n    try {\n      await Promise.all([\n        app.ui.settings.setSettingValueAsync('Comfy.Workflow.ShowMissingModelsWarning', false),\n        app.ui.settings.setSettingValueAsync('Comfy.Workflow.ShowMissingNodesWarning', false)\n      ])\n    } catch (e) {\n      console.warn('[ComfyGit] Failed to disable built-in warnings:', e)\n    }\n    ;(window as any).__comfygit_pending_workflow = graphData\n  },\n\n// main.ts lines 555-564 ‚Äî always dispatches event\nasync afterConfigureGraph(_missingNodeTypes: any[]) {\n    const workflow = (window as any).__comfygit_pending_workflow\n    if (!workflow) return\n    delete (window as any).__comfygit_pending_workflow\n    window.dispatchEvent(new CustomEvent('comfygit:workflow-loaded', {\n      detail: { workflow }\n    }))\n  },\n\\`\\`\\`\n\n## Target State\n\n\\`\\`\\`typescript\n// main.ts line 61 ‚Äî safe default (non-managed)\nlet currentSetupState: SetupState = 'no_workspace'\n\n// main.ts beforeConfigureGraph ‚Äî only suppress when managed\nasync beforeConfigureGraph(graphData: any, _missingNodeTypes: any[]) {\n    if (currentSetupState === 'managed') {\n      try {\n        await Promise.all([\n          app.ui.settings.setSettingValueAsync('Comfy.Workflow.ShowMissingModelsWarning', false),\n          app.ui.settings.setSettingValueAsync('Comfy.Workflow.ShowMissingNodesWarning', false)\n        ])\n      } catch (e) {\n        console.warn('[ComfyGit] Failed to disable built-in warnings:', e)\n      }\n    }\n    ;(window as any).__comfygit_pending_workflow = graphData\n  },\n\n// main.ts afterConfigureGraph ‚Äî only dispatch when managed\nasync afterConfigureGraph(_missingNodeTypes: any[]) {\n    if (currentSetupState !== 'managed') return\n    const workflow = (window as any).__comfygit_pending_workflow\n    if (!workflow) return\n    delete (window as any).__comfygit_pending_workflow\n    window.dispatchEvent(new CustomEvent('comfygit:workflow-loaded', {\n      detail: { workflow }\n    }))\n  },\n\\`\\`\\`\n\nNo changes needed to MissingResourcesPopup.vue ‚Äî gating the event dispatch in main.ts is sufficient since that's the only trigger path. The popup component is a standalone Vue app mounted via createApp (line 356-357) with no props.\n\n## Files Inventory\n\n**Files MODIFIED (write):**\n- \\`frontend/src/main.ts\\` (lines 61, 540-553, 555-564) - change default state, gate hooks on managed state\n\n**Files READ (reference only):**\n- \\`frontend/src/components/MissingResourcesPopup.vue\\` - verify no other trigger paths\n- \\`server/api/v2/setup.py\\` - understand SetupStatus response shape\n\n**Files CREATED:** None\n\n**Build artifact regenerated:**\n- \\`js/comfygit-panel.js\\` + \\`js/comfygit-panel.css\\` ‚Äî must run \\`cd frontend \u0026\u0026 npm run build\\` after changes\n\n## Parallelization Info\n\n**Can Run In Parallel With:**\n- cgm-er5 (Core model methods ‚Äî no file overlap)\n- cgm-94k (Backend API endpoints ‚Äî no file overlap)\n- cgm-ssk (different Vue component, different part of main.ts)\n\n**Cannot Run In Parallel With:**\n- cgm-io5 (may touch main.ts for frontend integration)\n- cgm-q9i (may touch main.ts or shared composables)\n\n## Estimated Scope\n- **Size:** Small (\u003c50 lines changed)\n- **Risk:** Low ‚Äî isolated to hook gating logic, no shared state mutation\n\n## Acceptance Criteria\n- [ ] Loading a workflow in a non-managed environment shows ComfyUI's **native** missing resource warnings (not comfygit's popup)\n- [ ] Loading a workflow in a managed environment still shows the comfygit Missing Dependencies popup\n- [ ] The default \\`currentSetupState\\` is \\`'no_workspace'\\` (safe default)\n- [ ] On first page load in a managed environment, once \\`fetchSetupStatus\\` resolves, subsequent workflow loads show the comfygit popup correctly\n- [ ] Frontend builds cleanly (\\`cd frontend \u0026\u0026 npm run build\\`)\n\n## Testing Requirements\n\n**Manual Testing:**\n1. Install comfygit-manager in a non-managed ComfyUI at \\`/data/comfyui/envs/test2/ComfyUI\\`\n2. Load a workflow with missing models/nodes\n3. Verify ComfyUI's native popup appears, NOT the comfygit popup\n4. Then test in a managed environment to verify comfygit popup still works\n\n**No automated test changes needed** ‚Äî the existing test suite doesn't cover main.ts extension hooks (these are ComfyUI runtime hooks). MissingResourcesPopup.vue tests (if any) should still pass since the component itself is unchanged.\n\n## Implementation Notes\n\n- The default change from \\`'managed'\\` to \\`'no_workspace'\\` is safe because all other consumers of \\`currentSetupState\\` already handle non-managed states correctly (commit button disabled, panel shows setup wizard, etc.)\n- We still always store \\`graphData\\` in \\`__comfygit_pending_workflow\\` in beforeConfigureGraph (needed for the managed case), but just skip the settings suppression\n- The \\`afterConfigureGraph\\` early-return when not managed also cleans up the stored workflow data implicitly (it won't be read, and next beforeConfigureGraph overwrites it)","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-02T20:26:00.961877712-05:00","created_by":"ubuntu","updated_at":"2026-02-02T20:30:54.207693579-05:00","closed_at":"2026-02-02T20:30:54.207693579-05:00","close_reason":"Implemented: default state changed to no_workspace, beforeConfigureGraph and afterConfigureGraph gated on managed state"}
